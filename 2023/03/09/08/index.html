<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>kubelet 创建pod源码分析 | lizhewei'Blog</title><meta name="author" content="lizhewei,tyutlizhewei@163.com"><meta name="copyright" content="lizhewei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本来基于 kubernetnes : v1.25.4 之前那篇文章对 kubelet 的工作原理做了简单的介绍，接下来，我们对 pod 创建的流程中，kubelet 创建 pod 进行一个详细的分析。 我们先回顾一下创建 pod 的整体流程。下面这张图是比较经典的创建 pod 的流程图，其中可以看到 apiserver 处于比较核心的位置，集群中的各个功能模块的所有源数据增删改查都是通过 apis">
<meta property="og:type" content="article">
<meta property="og:title" content="kubelet 创建pod源码分析">
<meta property="og:url" content="http://lizhewei91.github.io/2023/03/09/08/index.html">
<meta property="og:site_name" content="lizhewei&#39;Blog">
<meta property="og:description" content="本来基于 kubernetnes : v1.25.4 之前那篇文章对 kubelet 的工作原理做了简单的介绍，接下来，我们对 pod 创建的流程中，kubelet 创建 pod 进行一个详细的分析。 我们先回顾一下创建 pod 的整体流程。下面这张图是比较经典的创建 pod 的流程图，其中可以看到 apiserver 处于比较核心的位置，集群中的各个功能模块的所有源数据增删改查都是通过 apis">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2023-03-09T02:33:08.000Z">
<meta property="article:modified_time" content="2023-03-10T03:56:45.663Z">
<meta property="article:author" content="lizhewei">
<meta property="article:tag" content="kubelet">
<meta property="article:tag" content="cri">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://lizhewei91.github.io/2023/03/09/08/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'kubelet 创建pod源码分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: flase,
  isToc: true,
  postUpdate: '2023-03-10 11:56:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="lizhewei'Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">lizhewei'Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">kubelet 创建pod源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-09T02:33:08.000Z" title="发表于 2023-03-09 10:33:08">2023-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-10T03:56:45.663Z" title="更新于 2023-03-10 11:56:45">2023-03-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/kubelet/">kubelet</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="kubelet 创建pod源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>本来基于 kubernetnes : v1.25.4</p>
<p>之前那篇文章对 kubelet 的工作原理做了简单的介绍，接下来，我们对 pod 创建的流程中，kubelet 创建 pod 进行一个详细的分析。</p>
<p>我们先回顾一下创建 pod 的整体流程。下面这张图是比较经典的创建 pod 的流程图，其中可以看到 apiserver 处于比较核心的位置，集群中的各个功能模块的所有源数据增删改查都是通过 apiserver 操作 etcd，当你需要获取合操作这些数据时，通过 apiserver 的REST接口来实现。</p>
<img src="/2023/03/09/08/v2-acda9a15fbd02755201b4412d7ca83ce_r.jpg" class="" title="img">



<h1 id="kubelet工作原理"><a href="#kubelet工作原理" class="headerlink" title="kubelet工作原理"></a>kubelet工作原理</h1><p>kubelet 的工作主要是围绕一个 SyncLoop 来展开，借助 go channel，各组件监听 loop 消费事件，或者往里面生产 pod 相关的事件，整个控制循环由事件驱动运行。可以用下图来表示：</p>
<img src="/2023/03/09/08/2020-08-02-161409.jpg" class="" title="img">

<p>比如新建 pod 过程中，当一个 pod 被调度到某个 node 之后，就会触发 Kubelet 在循环控制里注册的 handler，如上图中的 HandlePods 部分。此时，Kubelet 检查 pod 在 Kubelet 内存中的状态，判断这是需要创建的 pod，从而触发 Handler 里的 ADD 事件对应的逻辑处理。</p>
<h1 id="SyncLoop"><a href="#SyncLoop" class="headerlink" title="SyncLoop"></a>SyncLoop</h1><p>我们来看下这个主循环 SyncLoop：</p>
<p><em><u>/pkg/kubelet/kubelet.go#2009</u></em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> syncLoop(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler) &#123;</span><br><span class="line">	klog.InfoS(<span class="string">&quot;Starting kubelet main sync loop&quot;</span>)</span><br><span class="line">	<span class="comment">// The syncTicker wakes up kubelet to checks if there are any pod workers</span></span><br><span class="line">	<span class="comment">// that need to be sync&#x27;d. A one-second period is sufficient because the</span></span><br><span class="line">	<span class="comment">// sync interval is defaulted to 10s.</span></span><br><span class="line">	syncTicker := time.NewTicker(time.Second)</span><br><span class="line">	<span class="keyword">defer</span> syncTicker.Stop()</span><br><span class="line">	housekeepingTicker := time.NewTicker(housekeepingPeriod)</span><br><span class="line">	<span class="keyword">defer</span> housekeepingTicker.Stop()</span><br><span class="line">	plegCh := kl.pleg.Watch()</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		base   = <span class="number">100</span> * time.Millisecond</span><br><span class="line">		max    = <span class="number">5</span> * time.Second</span><br><span class="line">		factor = <span class="number">2</span></span><br><span class="line">	)</span><br><span class="line">	duration := base</span><br><span class="line">	<span class="comment">// Responsible for checking limits in resolv.conf</span></span><br><span class="line">	<span class="comment">// The limits do not have anything to do with individual pods</span></span><br><span class="line">	<span class="comment">// Since this is called in syncLoop, we don&#x27;t need to call it anywhere else</span></span><br><span class="line">	<span class="keyword">if</span> kl.dnsConfigurer != <span class="literal">nil</span> &amp;&amp; kl.dnsConfigurer.ResolverConfig != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		kl.dnsConfigurer.CheckLimitsForResolvConf()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := kl.runtimeState.runtimeErrors(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.ErrorS(err, <span class="string">&quot;Skipping pod synchronization&quot;</span>)</span><br><span class="line">			<span class="comment">// exponential backoff</span></span><br><span class="line">			time.Sleep(duration)</span><br><span class="line">			duration = time.Duration(math.Min(<span class="type">float64</span>(max), factor*<span class="type">float64</span>(duration)))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// reset backoff if we have a success</span></span><br><span class="line">		duration = base</span><br><span class="line"></span><br><span class="line">		kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">		<span class="keyword">if</span> !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SyncLoop 起了一个死循环，循环里只调用了 syncLoopIteration 方法。而 syncLoopIteration 会对传入的所有 channel 遍历，发现任何一个管道有消息就交给 handler 去处理。</p>
<p>这些 channel 包括：</p>
<ul>
<li><strong>configCh：</strong>该 channel 的生产者为 kubeDeps 对象中的 PodConfig 子模块提供，该模块将同时监听来自 file，http，apiserver 的 pod 信息的变化，一旦某个来源的 pod 信息发生了更新，就会向这个 channel 生产相关事件。</li>
<li><strong>plegCh：</strong>该 channel 的生产者为 pleg 子模块，该模块会周期性地向容器运行时查询当前所有容器的状态，如果状态发生变化，则向这个 channel 生产事件。</li>
<li><strong>syncCh：</strong>定时同步最新保存的 pod 状态。</li>
<li><strong>health manager :</strong> livenessManager、readinessManager、startupManager 健康检查发现某个 pod 不可用，Kubelet 将根据 Pod 的 restartPolicy 自动执行正确的操作。</li>
<li><strong>houseKeepingCh：</strong>housekeeping 事件的管道，做 pod 清理工作。</li>
</ul>
<h2 id="syncLoopIteration"><a href="#syncLoopIteration" class="headerlink" title="syncLoopIteration"></a>syncLoopIteration</h2><p><em><u>/pkg/kubelet/kubelet.go#2083</u></em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> syncLoopIteration(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span><br><span class="line">	syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">case</span> u, open := &lt;-configCh:</span><br><span class="line">		<span class="comment">// Update from a config source; dispatch it to the right handler</span></span><br><span class="line">		<span class="comment">// callback.</span></span><br><span class="line">		<span class="keyword">if</span> !open &#123;</span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Update channel is closed, exiting the sync loop&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> u.Op &#123;</span><br><span class="line">		<span class="keyword">case</span> kubetypes.ADD:</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop ADD&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">			<span class="comment">// After restarting, kubelet will get all existing pods through</span></span><br><span class="line">			<span class="comment">// ADD as if they are new pods. These pods will then go through the</span></span><br><span class="line">			<span class="comment">// admission process and *may* be rejected. This can be resolved</span></span><br><span class="line">			<span class="comment">// once we have checkpointing.</span></span><br><span class="line">			handler.HandlePodAdditions(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.UPDATE:</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop UPDATE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">			handler.HandlePodUpdates(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.REMOVE:</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop REMOVE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">			handler.HandlePodRemoves(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.RECONCILE:</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop RECONCILE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">			handler.HandlePodReconcile(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.DELETE:</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop DELETE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">			<span class="comment">// DELETE is treated as a UPDATE because of graceful deletion.</span></span><br><span class="line">			handler.HandlePodUpdates(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.SET:</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> Do we want to support this?</span></span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Kubelet does not support snapshot update&quot;</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Invalid operation type received&quot;</span>, <span class="string">&quot;operation&quot;</span>, u.Op)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		kl.sourcesReady.AddSource(u.Source)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> e := &lt;-plegCh:</span><br><span class="line">		<span class="keyword">if</span> e.Type == pleg.ContainerStarted &#123;</span><br><span class="line">			<span class="comment">// record the most recent time we observed a container start for this pod.</span></span><br><span class="line">			<span class="comment">// this lets us selectively invalidate the runtimeCache when processing a delete for this pod</span></span><br><span class="line">			<span class="comment">// to make sure we don&#x27;t miss handling graceful termination for containers we reported as having started.</span></span><br><span class="line">			kl.lastContainerStartedTime.Add(e.ID, time.Now())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> isSyncPodWorthy(e) &#123;</span><br><span class="line">			<span class="comment">// PLEG event for a pod; sync it.</span></span><br><span class="line">			<span class="keyword">if</span> pod, ok := kl.podManager.GetPodByUID(e.ID); ok &#123;</span><br><span class="line">				klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop (PLEG): event for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;event&quot;</span>, e)</span><br><span class="line">				handler.HandlePodSyncs([]*v1.Pod&#123;pod&#125;)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// If the pod no longer exists, ignore the event.</span></span><br><span class="line">				klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (PLEG): pod does not exist, ignore irrelevant event&quot;</span>, <span class="string">&quot;event&quot;</span>, e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> e.Type == pleg.ContainerDied &#123;</span><br><span class="line">			<span class="keyword">if</span> containerID, ok := e.Data.(<span class="type">string</span>); ok &#123;</span><br><span class="line">				kl.cleanUpContainersInPod(e.ID, containerID)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> &lt;-syncCh:</span><br><span class="line">		<span class="comment">// Sync pods waiting for sync</span></span><br><span class="line">		podsToSync := kl.getPodsToSync()</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(podsToSync) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (SYNC) pods&quot;</span>, <span class="string">&quot;total&quot;</span>, <span class="built_in">len</span>(podsToSync), <span class="string">&quot;pods&quot;</span>, klog.KObjs(podsToSync))</span><br><span class="line">		handler.HandlePodSyncs(podsToSync)</span><br><span class="line">	<span class="keyword">case</span> update := &lt;-kl.livenessManager.Updates():</span><br><span class="line">		<span class="keyword">if</span> update.Result == proberesults.Failure &#123;</span><br><span class="line">			handleProbeSync(kl, update, handler, <span class="string">&quot;liveness&quot;</span>, <span class="string">&quot;unhealthy&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> update := &lt;-kl.readinessManager.Updates():</span><br><span class="line">		ready := update.Result == proberesults.Success</span><br><span class="line">		kl.statusManager.SetContainerReadiness(update.PodUID, update.ContainerID, ready)</span><br><span class="line"></span><br><span class="line">		status := <span class="string">&quot;&quot;</span></span><br><span class="line">		<span class="keyword">if</span> ready &#123;</span><br><span class="line">			status = <span class="string">&quot;ready&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		handleProbeSync(kl, update, handler, <span class="string">&quot;readiness&quot;</span>, status)</span><br><span class="line">	<span class="keyword">case</span> update := &lt;-kl.startupManager.Updates():</span><br><span class="line">		started := update.Result == proberesults.Success</span><br><span class="line">		kl.statusManager.SetContainerStartup(update.PodUID, update.ContainerID, started)</span><br><span class="line"></span><br><span class="line">		status := <span class="string">&quot;unhealthy&quot;</span></span><br><span class="line">		<span class="keyword">if</span> started &#123;</span><br><span class="line">			status = <span class="string">&quot;started&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		handleProbeSync(kl, update, handler, <span class="string">&quot;startup&quot;</span>, status)</span><br><span class="line">	<span class="keyword">case</span> &lt;-housekeepingCh:</span><br><span class="line">		<span class="keyword">if</span> !kl.sourcesReady.AllReady() &#123;</span><br><span class="line">			<span class="comment">// If the sources aren&#x27;t ready or volume manager has not yet synced the states,</span></span><br><span class="line">			<span class="comment">// skip housekeeping, as we may accidentally delete pods from unready sources.</span></span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (housekeeping, skipped): sources aren&#x27;t ready yet&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			start := time.Now()</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (housekeeping)&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> err := handler.HandlePodCleanups(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">&quot;Failed cleaning pods&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			duration := time.Since(start)</span><br><span class="line">			<span class="keyword">if</span> duration &gt; housekeepingWarningDuration &#123;</span><br><span class="line">				klog.ErrorS(fmt.Errorf(<span class="string">&quot;housekeeping took too long&quot;</span>), <span class="string">&quot;Housekeeping took longer than 15s&quot;</span>, <span class="string">&quot;seconds&quot;</span>, duration.Seconds())</span><br><span class="line">			&#125;</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (housekeeping) end&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建pod过程"><a href="#创建pod过程" class="headerlink" title="创建pod过程"></a>创建pod过程</h1><p>Kubelet 创建 pod 的过程是由 configCh 中的 ADD 事件触发的，那么下面主要看下 Kubelet 接收到 ADD 事件后的主要流程。</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>当 configCh 中出现了 ADD 事件，loop 会触发 SyncHandler 的 HandlePodAdditions 方法。这个方法的流程可以用下面这张流程图描述：</p>
<img src="/2023/03/09/08/handlePodAdditions.png" class="" title="handlePodAdditions">

<ul>
<li><p>首先 handler 会将所有的 pod 安装创建时间进行排序，然后逐个进行处理。</p>
</li>
<li><p>然后将 pod 添加到 podManager 中，以方便后续操作；然后判断其是否为 mirror pod，如果是将作为 mirror pod 处理，否则按照正常 pod 处理。</p>
<p>这里解释一下 mirror pod： mirror pod 是 static pod 在 kueblet 在 apiserver 创建的一份副本。由于 static pod 是由 Kubelet 直接管理的，apiserver 并不会感知到 static pod 的存在，其生命周期都由 Kubelet 直接托管。为了可以通过 kubectl 命令查看对应的 pod，并且可以通过 kubectl logs 命令直接查看到static pod 的日志信息，Kubelet 通过 apiserver 为每一个 static pod 创建一个对应的 mirror pod。</p>
</li>
<li><p>接着判断 pod 是否能再该节点上运行，也就是所谓的 Kubelet 中的 pod 准入控制，准入控制主要包括这几方面：</p>
</li>
</ul>
<ol>
<li>节点是否满足 pod 的亲和性规则</li>
<li>节点是否有足够的资源分配给 pod</li>
<li>节点是否使用 HostNetwork 或者 HostIPC，若使用了，是否在节点的白名单里</li>
<li>/proc 挂载目录满足要求</li>
<li>pod 是否配置且是否配置正确的 AppArmor</li>
</ol>
<ul>
<li>当所有的条件都满足后，最后触发 podWorker 同步 pod。</li>
</ul>
<p>HandlePodAdditions 对应的代码如下：</p>
<p><u><em>/pkg/kubelet/kubelet.go#2238</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> HandlePodAdditions(pods []*v1.Pod) &#123;</span><br><span class="line">	start := kl.clock.Now()</span><br><span class="line">	sort.Sort(sliceutils.PodsByCreationTime(pods))</span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		existingPods := kl.podManager.GetPods()</span><br><span class="line">		<span class="comment">// Always add the pod to the pod manager. Kubelet relies on the pod</span></span><br><span class="line">		<span class="comment">// manager as the source of truth for the desired state. If a pod does</span></span><br><span class="line">		<span class="comment">// not exist in the pod manager, it means that it has been deleted in</span></span><br><span class="line">		<span class="comment">// the apiserver and no action (other than cleanup) is required.</span></span><br><span class="line">		kl.podManager.AddPod(pod)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> kubetypes.IsMirrorPod(pod) &#123;</span><br><span class="line">			kl.handleMirrorPod(pod, start)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Only go through the admission process if the pod is not requested</span></span><br><span class="line">		<span class="comment">// for termination by another part of the kubelet. If the pod is already</span></span><br><span class="line">		<span class="comment">// using resources (previously admitted), the pod worker is going to be</span></span><br><span class="line">		<span class="comment">// shutting it down. If the pod hasn&#x27;t started yet, we know that when</span></span><br><span class="line">		<span class="comment">// the pod worker is invoked it will also avoid setting up the pod, so</span></span><br><span class="line">		<span class="comment">// we simply avoid doing any work.</span></span><br><span class="line">		<span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line">			<span class="comment">// We failed pods that we rejected, so activePods include all admitted</span></span><br><span class="line">			<span class="comment">// pods that are alive.</span></span><br><span class="line">			activePods := kl.filterOutInactivePods(existingPods)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check if we can admit the pod; if not, reject it.</span></span><br><span class="line">			<span class="keyword">if</span> ok, reason, message := kl.canAdmitPod(activePods, pod); !ok &#123;</span><br><span class="line">				kl.rejectPod(pod, reason, message)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		mirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)</span><br><span class="line">		kl.dispatchWork(pod, kubetypes.SyncPodCreate, mirrorPod, start)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="podWorkers-的工作"><a href="#podWorkers-的工作" class="headerlink" title="podWorkers 的工作"></a>podWorkers 的工作</h3><p>接下来看看 podWorker 的工作。podWorker 维护了一个 map 叫 podUpdates (map[types.UID]chan podWork)，以 pod uid 为 key，为每个 pod 维护一个 channel；当 pod 有事件过来的时候，首先从这个 map 里获取对应的 channel，然后启动一个 goroutine 监听这个 channel，并执行 managePodLoop；另一方面 podWorker 向这个 channel 中传入需要同步的 pod。</p>
<p>managePodLoop 接收到事件后，会先从 pod cache 中获取该 pod 最新的 status，以确保当前处理的 pod 是最新状态；然后调用 syncPod 方法，将其同步后的结果记录在 workQueue 中，等待下一次定时同步任务处理。</p>
<p>整个过程如下图所示：</p>
<img src="/2023/03/09/08/2020-08-02-161428.jpg" class="" title="img">

<p>podWorker 中处理 pod 事件的代码：</p>
<p><u><em>/pkg/kubelet/pod_workers.go#557</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span></span> UpdatePod(options UpdatePodOptions) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// allow testing of delays in the pod update channel</span></span><br><span class="line">		<span class="keyword">var</span> outCh &lt;-<span class="keyword">chan</span> podWork</span><br><span class="line">		<span class="keyword">if</span> p.workerChannelFn != <span class="literal">nil</span> &#123;</span><br><span class="line">			outCh = p.workerChannelFn(uid, podUpdates)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			outCh = podUpdates</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Creating a new pod worker either means this is a new pod, or that the</span></span><br><span class="line">		<span class="comment">// kubelet just restarted. In either case the kubelet is willing to believe</span></span><br><span class="line">		<span class="comment">// the status of the pod for the first pod worker sync. See corresponding</span></span><br><span class="line">		<span class="comment">// comment in syncPod.</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> runtime.HandleCrash()</span><br><span class="line">			p.managePodLoop(outCh)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dispatch a request to the pod worker if none are running</span></span><br><span class="line">	<span class="keyword">if</span> !status.IsWorking() &#123;</span><br><span class="line">		status.working = <span class="literal">true</span></span><br><span class="line">		podUpdates &lt;- work</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>managePodLoop 函数，会根据 update.WorkType 类型，去分别执行 syncTerminatedPodFn、syncTerminatingPodFn、syncPodFn方法去调用</p>
<p><u><em>/pkg/kubelet/pod_worker.go#877</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span></span> managePodLoop(podUpdates &lt;-<span class="keyword">chan</span> podWork) &#123;</span><br><span class="line">	<span class="keyword">var</span> lastSyncTime time.Time</span><br><span class="line">	<span class="keyword">var</span> podStarted <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> update := <span class="keyword">range</span> podUpdates &#123;</span><br><span class="line">		pod := update.Options.Pod</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// Take the appropriate action (illegal phases are prevented by UpdatePod)</span></span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> update.WorkType == TerminatedPodWork:</span><br><span class="line">				err = p.syncTerminatedPodFn(ctx, pod, status)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> update.WorkType == TerminatingPodWork:</span><br><span class="line">				<span class="keyword">var</span> gracePeriod *<span class="type">int64</span></span><br><span class="line">				<span class="keyword">if</span> opt := update.Options.KillPodOptions; opt != <span class="literal">nil</span> &#123;</span><br><span class="line">					gracePeriod = opt.PodTerminationGracePeriodSecondsOverride</span><br><span class="line">				&#125;</span><br><span class="line">				podStatusFn := p.acknowledgeTerminating(pod)</span><br><span class="line"></span><br><span class="line">				err = p.syncTerminatingPodFn(ctx, pod, status, update.Options.RunningPod, gracePeriod, podStatusFn)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				isTerminal, err = p.syncPodFn(ctx, update.Options.UpdateType, pod, update.Options.MirrorPod, status)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			lastSyncTime = time.Now()</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;()</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// queue a retry if necessary, then put the next event in the channel if any</span></span><br><span class="line">		p.completeWork(pod, phaseTransition, err)</span><br><span class="line">		<span class="keyword">if</span> start := update.Options.StartTime; !start.IsZero() &#123;</span><br><span class="line">			metrics.PodWorkerDuration.WithLabelValues(update.Options.UpdateType.String()).Observe(metrics.SinceInSeconds(start))</span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Processing pod event done&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID, <span class="string">&quot;updateType&quot;</span>, update.WorkType)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="syncPod"><a href="#syncPod" class="headerlink" title="syncPod"></a>syncPod</h3><p>上述 podWorker 在 managePodLoop 中调用的 syncPodFn 方法，其实是 Kubelet 对象的 SyncPod 方法，在文件 pkg/kubelet/kubelet.go 中。</p>
<p>这个方法是真正与 container runtime 层交互的。首先，如果正在创建，记录pod worker启动延迟；设置podIP为hostIP；然后判断是否可以在节点上运行，这里就是上面讲到的 Kubelet 的准入控制；再判断 CNI 插件是否 ready，如果不 ready，则只在 pod 使用 host network 的时候创建并更新 pod 的 cgroups；接着再判断是否是静态 pod，如果是就创建相应的 mirror pod；然后创建 pod 需要挂载的目录；最后调用 runtime 的 syncPod。整个流程如下所示：</p>
<img src="/2023/03/09/08/syncPod-8419730.png" class="" title="syncPod">

<p><u><em>/pkg/kubelet/kubelet.go#1522</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> syncPod(ctx context.Context, updateType kubetypes.SyncPodType, pod, mirrorPod *v1.Pod, podStatus *kubecontainer.PodStatus) (isTerminal <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;syncPod enter&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;syncPod exit&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID, <span class="string">&quot;isTerminal&quot;</span>, isTerminal)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Latency measurements for the main workflow are relative to the</span></span><br><span class="line">	<span class="comment">// first time the pod was seen by kubelet.</span></span><br><span class="line">	<span class="keyword">var</span> firstSeenTime time.Time</span><br><span class="line">	<span class="keyword">if</span> firstSeenTimeStr, ok := pod.Annotations[kubetypes.ConfigFirstSeenAnnotationKey]; ok &#123;</span><br><span class="line">		firstSeenTime = kubetypes.ConvertToTimestamp(firstSeenTimeStr).Get()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Record pod worker start latency if being created</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> make pod workers record their own latencies</span></span><br><span class="line">	<span class="keyword">if</span> updateType == kubetypes.SyncPodCreate &#123;</span><br><span class="line">		<span class="keyword">if</span> !firstSeenTime.IsZero() &#123;</span><br><span class="line">			<span class="comment">// This is the first time we are syncing the pod. Record the latency</span></span><br><span class="line">			<span class="comment">// since kubelet first saw the pod if firstSeenTime is set.</span></span><br><span class="line">			metrics.PodWorkerStartDuration.Observe(metrics.SinceInSeconds(firstSeenTime))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;First seen time not recorded for pod&quot;</span>,</span><br><span class="line">				<span class="string">&quot;podUID&quot;</span>, pod.UID,</span><br><span class="line">				<span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Generate final API pod status with pod and status manager status</span></span><br><span class="line">	apiPodStatus := kl.generateAPIPodStatus(pod, podStatus)</span><br><span class="line">	<span class="comment">// The pod IP may be changed in generateAPIPodStatus if the pod is using host network. (See #24576)</span></span><br><span class="line">	<span class="comment">// TODO(random-liu): After writing pod spec into container labels, check whether pod is using host network, and</span></span><br><span class="line">	<span class="comment">// set pod IP to hostIP directly in runtime.GetPodStatus</span></span><br><span class="line">	podStatus.IPs = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(apiPodStatus.PodIPs))</span><br><span class="line">	<span class="keyword">for</span> _, ipInfo := <span class="keyword">range</span> apiPodStatus.PodIPs &#123;</span><br><span class="line">		podStatus.IPs = <span class="built_in">append</span>(podStatus.IPs, ipInfo.IP)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(podStatus.IPs) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(apiPodStatus.PodIP) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		podStatus.IPs = []<span class="type">string</span>&#123;apiPodStatus.PodIP&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the pod is terminal, we don&#x27;t need to continue to setup the pod</span></span><br><span class="line">	<span class="keyword">if</span> apiPodStatus.Phase == v1.PodSucceeded || apiPodStatus.Phase == v1.PodFailed &#123;</span><br><span class="line">		kl.statusManager.SetPodStatus(pod, apiPodStatus)</span><br><span class="line">		isTerminal = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> isTerminal, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the pod should not be running, we request the pod&#x27;s containers be stopped. This is not the same</span></span><br><span class="line">	<span class="comment">// as termination (we want to stop the pod, but potentially restart it later if soft admission allows</span></span><br><span class="line">	<span class="comment">// it later). Set the status and phase appropriately</span></span><br><span class="line">	runnable := kl.canRunPod(pod)</span><br><span class="line">	<span class="keyword">if</span> !runnable.Admit &#123;</span><br><span class="line">		<span class="comment">// Pod is not runnable; and update the Pod and Container statuses to why.</span></span><br><span class="line">		<span class="keyword">if</span> apiPodStatus.Phase != v1.PodFailed &amp;&amp; apiPodStatus.Phase != v1.PodSucceeded &#123;</span><br><span class="line">			apiPodStatus.Phase = v1.PodPending</span><br><span class="line">		&#125;</span><br><span class="line">		apiPodStatus.Reason = runnable.Reason</span><br><span class="line">		apiPodStatus.Message = runnable.Message</span><br><span class="line">		<span class="comment">// Waiting containers are not creating.</span></span><br><span class="line">		<span class="keyword">const</span> waitingReason = <span class="string">&quot;Blocked&quot;</span></span><br><span class="line">		<span class="keyword">for</span> _, cs := <span class="keyword">range</span> apiPodStatus.InitContainerStatuses &#123;</span><br><span class="line">			<span class="keyword">if</span> cs.State.Waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">				cs.State.Waiting.Reason = waitingReason</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, cs := <span class="keyword">range</span> apiPodStatus.ContainerStatuses &#123;</span><br><span class="line">			<span class="keyword">if</span> cs.State.Waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">				cs.State.Waiting.Reason = waitingReason</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Record the time it takes for the pod to become running</span></span><br><span class="line">	<span class="comment">// since kubelet first saw the pod if firstSeenTime is set.</span></span><br><span class="line">	existingStatus, ok := kl.statusManager.GetPodStatus(pod.UID)</span><br><span class="line">	<span class="keyword">if</span> !ok || existingStatus.Phase == v1.PodPending &amp;&amp; apiPodStatus.Phase == v1.PodRunning &amp;&amp;</span><br><span class="line">		!firstSeenTime.IsZero() &#123;</span><br><span class="line">		metrics.PodStartDuration.Observe(metrics.SinceInSeconds(firstSeenTime))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kl.statusManager.SetPodStatus(pod, apiPodStatus)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pods that are not runnable must be stopped - return a typed error to the pod worker</span></span><br><span class="line">	<span class="keyword">if</span> !runnable.Admit &#123;</span><br><span class="line">		klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;Pod is not runnable and must have running containers stopped&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID, <span class="string">&quot;message&quot;</span>, runnable.Message)</span><br><span class="line">		<span class="keyword">var</span> syncErr <span class="type">error</span></span><br><span class="line">		p := kubecontainer.ConvertPodStatusToRunningPod(kl.getRuntime().Type(), podStatus)</span><br><span class="line">		<span class="keyword">if</span> err := kl.killPod(pod, p, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToKillPod, <span class="string">&quot;error killing pod: %v&quot;</span>, err)</span><br><span class="line">			syncErr = fmt.Errorf(<span class="string">&quot;error killing pod: %v&quot;</span>, err)</span><br><span class="line">			utilruntime.HandleError(syncErr)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// There was no error killing the pod, but the pod cannot be run.</span></span><br><span class="line">			<span class="comment">// Return an error to signal that the sync loop should back off.</span></span><br><span class="line">			syncErr = fmt.Errorf(<span class="string">&quot;pod cannot be run: %s&quot;</span>, runnable.Message)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, syncErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the network plugin is not ready, only start the pod if it uses the host network</span></span><br><span class="line">	<span class="keyword">if</span> err := kl.runtimeState.networkErrors(); err != <span class="literal">nil</span> &amp;&amp; !kubecontainer.IsHostNetworkPod(pod) &#123;</span><br><span class="line">		kl.recorder.Eventf(pod, v1.EventTypeWarning, events.NetworkNotReady, <span class="string">&quot;%s: %v&quot;</span>, NetworkNotReadyErrorMsg, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;%s: %v&quot;</span>, NetworkNotReadyErrorMsg, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ensure the kubelet knows about referenced secrets or configmaps used by the pod</span></span><br><span class="line">	<span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line">		<span class="keyword">if</span> kl.secretManager != <span class="literal">nil</span> &#123;</span><br><span class="line">			kl.secretManager.RegisterPod(pod)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> kl.configMapManager != <span class="literal">nil</span> &#123;</span><br><span class="line">			kl.configMapManager.RegisterPod(pod)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create Cgroups for the pod and apply resource parameters</span></span><br><span class="line">	<span class="comment">// to them if cgroups-per-qos flag is enabled.</span></span><br><span class="line">	pcm := kl.containerManager.NewPodContainerManager()</span><br><span class="line">	<span class="comment">// If pod has already been terminated then we need not create</span></span><br><span class="line">	<span class="comment">// or update the pod&#x27;s cgroup</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> once context cancellation is added this check can be removed</span></span><br><span class="line">	<span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line">		<span class="comment">// When the kubelet is restarted with the cgroups-per-qos</span></span><br><span class="line">		<span class="comment">// flag enabled, all the pod&#x27;s running containers</span></span><br><span class="line">		<span class="comment">// should be killed intermittently and brought back up</span></span><br><span class="line">		<span class="comment">// under the qos cgroup hierarchy.</span></span><br><span class="line">		<span class="comment">// Check if this is the pod&#x27;s first sync</span></span><br><span class="line">		firstSync := <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> _, containerStatus := <span class="keyword">range</span> apiPodStatus.ContainerStatuses &#123;</span><br><span class="line">			<span class="keyword">if</span> containerStatus.State.Running != <span class="literal">nil</span> &#123;</span><br><span class="line">				firstSync = <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Don&#x27;t kill containers in pod if pod&#x27;s cgroups already</span></span><br><span class="line">		<span class="comment">// exists or the pod is running for the first time</span></span><br><span class="line">		podKilled := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> !pcm.Exists(pod) &amp;&amp; !firstSync &#123;</span><br><span class="line">			p := kubecontainer.ConvertPodStatusToRunningPod(kl.getRuntime().Type(), podStatus)</span><br><span class="line">			<span class="keyword">if</span> err := kl.killPod(pod, p, <span class="literal">nil</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">				podKilled = <span class="literal">true</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">&quot;KillPod failed&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podStatus&quot;</span>, podStatus)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Create and Update pod&#x27;s Cgroups</span></span><br><span class="line">		<span class="comment">// Don&#x27;t create cgroups for run once pod if it was killed above</span></span><br><span class="line">		<span class="comment">// The current policy is not to restart the run once pods when</span></span><br><span class="line">		<span class="comment">// the kubelet is restarted with the new flag as run once pods are</span></span><br><span class="line">		<span class="comment">// expected to run only once and if the kubelet is restarted then</span></span><br><span class="line">		<span class="comment">// they are not expected to run again.</span></span><br><span class="line">		<span class="comment">// We don&#x27;t create and apply updates to cgroup if its a run once pod and was killed above</span></span><br><span class="line">		<span class="keyword">if</span> !(podKilled &amp;&amp; pod.Spec.RestartPolicy == v1.RestartPolicyNever) &#123;</span><br><span class="line">			<span class="keyword">if</span> !pcm.Exists(pod) &#123;</span><br><span class="line">				<span class="keyword">if</span> err := kl.containerManager.UpdateQOSCgroups(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;Failed to update QoS cgroups while syncing pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> err := pcm.EnsureExists(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToCreatePodContainer, <span class="string">&quot;unable to ensure pod container exists: %v&quot;</span>, err)</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;failed to ensure that the pod: %v cgroups exist and are correctly applied: %v&quot;</span>, pod.UID, err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create Mirror Pod for Static Pod if it doesn&#x27;t already exist</span></span><br><span class="line">	<span class="keyword">if</span> kubetypes.IsStaticPod(pod) &#123;</span><br><span class="line">		deleted := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> mirrorPod != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> mirrorPod.DeletionTimestamp != <span class="literal">nil</span> || !kl.podManager.IsMirrorPodOf(mirrorPod, pod) &#123;</span><br><span class="line">				<span class="comment">// The mirror pod is semantically different from the static pod. Remove</span></span><br><span class="line">				<span class="comment">// it. The mirror pod will get recreated later.</span></span><br><span class="line">				klog.InfoS(<span class="string">&quot;Trying to delete pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, mirrorPod.ObjectMeta.UID)</span><br><span class="line">				podFullName := kubecontainer.GetPodFullName(pod)</span><br><span class="line">				<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">				deleted, err = kl.podManager.DeleteMirrorPod(podFullName, &amp;mirrorPod.ObjectMeta.UID)</span><br><span class="line">				<span class="keyword">if</span> deleted &#123;</span><br><span class="line">					klog.InfoS(<span class="string">&quot;Deleted mirror pod because it is outdated&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(mirrorPod))</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					klog.ErrorS(err, <span class="string">&quot;Failed deleting mirror pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(mirrorPod))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> mirrorPod == <span class="literal">nil</span> || deleted &#123;</span><br><span class="line">			node, err := kl.GetNode()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> || node.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;No need to create a mirror pod, since node has been removed from the cluster&quot;</span>, <span class="string">&quot;node&quot;</span>, klog.KRef(<span class="string">&quot;&quot;</span>, <span class="type">string</span>(kl.nodeName)))</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Creating a mirror pod for static pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">				<span class="keyword">if</span> err := kl.podManager.CreateMirrorPod(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					klog.ErrorS(err, <span class="string">&quot;Failed creating a mirror pod for&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make data directories for the pod</span></span><br><span class="line">	<span class="keyword">if</span> err := kl.makePodDataDirs(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToMakePodDataDirectories, <span class="string">&quot;error making pod data directories: %v&quot;</span>, err)</span><br><span class="line">		klog.ErrorS(err, <span class="string">&quot;Unable to make pod data directories for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Volume manager will not mount volumes for terminating pods</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> once context cancellation is added this check can be removed</span></span><br><span class="line">	<span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line">		<span class="comment">// Wait for volumes to attach/mount</span></span><br><span class="line">		<span class="keyword">if</span> err := kl.volumeManager.WaitForAttachAndMount(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedMountVolume, <span class="string">&quot;Unable to attach or mount volumes: %v&quot;</span>, err)</span><br><span class="line">			klog.ErrorS(err, <span class="string">&quot;Unable to attach or mount volumes for pod; skipping pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fetch the pull secrets for the pod</span></span><br><span class="line">	pullSecrets := kl.getPullSecretsForPod(pod)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ensure the pod is being probed</span></span><br><span class="line">	kl.probeManager.AddPod(pod)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call the container runtime&#x27;s SyncPod callback</span></span><br><span class="line">	result := kl.containerRuntime.SyncPod(pod, podStatus, pullSecrets, kl.backOff)</span><br><span class="line">	kl.reasonCache.Update(pod.UID, result)</span><br><span class="line">	<span class="keyword">if</span> err := result.Error(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Do not return error if the only failures were pods in backoff</span></span><br><span class="line">		<span class="keyword">for</span> _, r := <span class="keyword">range</span> result.SyncResults &#123;</span><br><span class="line">			<span class="keyword">if</span> r.Error != kubecontainer.ErrCrashLoopBackOff &amp;&amp; r.Error != images.ErrImagePullBackOff &#123;</span><br><span class="line">				<span class="comment">// Do not record an event here, as we keep all event logging for sync pod failures</span></span><br><span class="line">				<span class="comment">// local to container runtime, so we get better errors.</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://lizhewei91.github.io">lizhewei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lizhewei91.github.io/2023/03/09/08/">http://lizhewei91.github.io/2023/03/09/08/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lizhewei91.github.io" target="_blank">lizhewei'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/kubelet/">kubelet</a><a class="post-meta__tags" href="/tags/cri/">cri</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="wechat,qq,weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/03/07/15/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">kubelet volume manager源码分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/11/14/" title="kubelet 工作原理分析"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-11</div><div class="title">kubelet 工作原理分析</div></div></a></div><div><a href="/2023/01/16/19/" title="kubelet-device-manager 源码分析"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-16</div><div class="title">kubelet-device-manager 源码分析</div></div></a></div><div><a href="/2023/03/07/15/" title="kubelet volume manager源码分析"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-07</div><div class="title">kubelet volume manager源码分析</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#kubelet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">kubelet工作原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SyncLoop"><span class="toc-number">2.</span> <span class="toc-text">SyncLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#syncLoopIteration"><span class="toc-number">2.1.</span> <span class="toc-text">syncLoopIteration</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BApod%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">创建pod过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler"><span class="toc-number">3.0.1.</span> <span class="toc-text">Handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#podWorkers-%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.0.2.</span> <span class="toc-text">podWorkers 的工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#syncPod"><span class="toc-number">3.0.3.</span> <span class="toc-text">syncPod</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By lizhewei</div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'TzKJNF9IUQQPM30gWiY4lC8Y-gzGzoHsz',
      appKey: '2s3a4u4FAlmBuQf3dpgXnY9V',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>