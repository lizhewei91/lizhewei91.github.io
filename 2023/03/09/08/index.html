<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>kubelet 创建 pod 源码分析 | lizhewei&#39;s Blog</title>
  <meta name="description" content="本来基于 kubernetnes : v1.25.4 之前那篇文章对 kubelet 的工作原理做了简单的介绍，接下来，我们对 pod 创建的流程中，kubelet 创建 pod 进行一个详细的分析。       SyncLoop我们来看下这个主循环 SyncLoop： &#x2F;pkg&#x2F;kubelet&#x2F;kubelet.go#2009 func (kl *Kubelet) syncLoop(updates">
<meta property="og:type" content="article">
<meta property="og:title" content="kubelet 创建 pod 源码分析">
<meta property="og:url" content="http://lizhewei91.github.io/2023/03/09/08/index.html">
<meta property="og:site_name" content="lizhewei&#39;Blog">
<meta property="og:description" content="本来基于 kubernetnes : v1.25.4 之前那篇文章对 kubelet 的工作原理做了简单的介绍，接下来，我们对 pod 创建的流程中，kubelet 创建 pod 进行一个详细的分析。       SyncLoop我们来看下这个主循环 SyncLoop： &#x2F;pkg&#x2F;kubelet&#x2F;kubelet.go#2009 func (kl *Kubelet) syncLoop(updates">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lizhewei91.github.io/2023/03/09/08/kubelet-create-pod/kubelet-arch.jpg">
<meta property="og:image" content="http://lizhewei91.github.io/2023/03/09/08/handlePodAdditions.png">
<meta property="og:image" content="http://lizhewei91.github.io/2023/03/09/08/2020-08-02-161428.jpg">
<meta property="og:image" content="http://lizhewei91.github.io/2023/03/09/08/syncPod-8419730.png">
<meta property="article:published_time" content="2023-03-09T02:33:08.000Z">
<meta property="article:modified_time" content="2023-06-01T13:31:53.206Z">
<meta property="article:author" content="lizhewei">
<meta property="article:tag" content="kubelet">
<meta property="article:tag" content="创建pod流程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lizhewei91.github.io/2023/03/09/08/kubelet-create-pod/kubelet-arch.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="http://lizhewei91.github.io/2023/03/09/08/index.html">
  
    <link rel="alternate" href="/atom.xml" title="lizhewei&#39;Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/lizhewei91" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">李哲伟</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Cloud Native Developer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Beijing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/lizhewei91" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/NUMA/">NUMA</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/device-plugins/">device-plugins</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gin/">gin</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gpu-operator/">gpu-operator</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gpushare/">gpushare</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s-swagger-ui/">k8s-swagger-ui</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kube-scheduler/">kube-scheduler</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kubeadm/">kubeadm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kubectl-%E6%8F%92%E4%BB%B6/">kubectl 插件</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kubelet/">kubelet</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nexus/">nexus</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nvidia-time-slicing/">nvidia/time-slicing</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/operator/">operator</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/pprof/">pprof</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reloader/">reloader</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webhook/">webhook</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%83%A8%E7%BD%B2k8s%E9%9B%86%E7%BE%A4/">部署k8s集群</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%95%9C%E5%83%8F/">镜像</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/NUMA/" rel="tag">NUMA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/buildx/" rel="tag">buildx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code-generator/" rel="tag">code-generator</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/configMap/" rel="tag">configMap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/device-manager/" rel="tag">device-manager</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/device-plugins/" rel="tag">device-plugins</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker-repositories/" rel="tag">docker-repositories</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gin/" rel="tag">gin</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gpu/" rel="tag">gpu</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gpu-operator/" rel="tag">gpu-operator</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gpushare/" rel="tag">gpushare</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jwt/" rel="tag">jwt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s-swagger-ui/" rel="tag">k8s-swagger-ui</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/krew/" rel="tag">krew</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kube-scheduler/" rel="tag">kube-scheduler</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kube-scheduler%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">kube-scheduler基础知识</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kube-scheduler%E6%89%A9%E5%B1%95/" rel="tag">kube-scheduler扩展</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubeadm/" rel="tag">kubeadm</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubebuilder/" rel="tag">kubebuilder</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubectl-plugins/" rel="tag">kubectl-plugins</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubelet/" rel="tag">kubelet</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubevirt-gpu-device-plugin/" rel="tag">kubevirt-gpu-device-plugin</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/manifest/" rel="tag">manifest</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/multiple-schedulers/" rel="tag">multiple-schedulers</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nexus/" rel="tag">nexus</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-%E8%8A%82%E7%82%B9%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D/" rel="tag">node 节点资源分配</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nvidia/" rel="tag">nvidia</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nvidia-gpu-operator/" rel="tag">nvidia/gpu-operator</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nvidia-gpu-share/" rel="tag">nvidia/gpu-share</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nvidia-time-slicing/" rel="tag">nvidia/time-slicing</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/operator/" rel="tag">operator</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pprof/" rel="tag">pprof</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reloader/" rel="tag">reloader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scheduler-extender/" rel="tag">scheduler-extender</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scheduler-framework/" rel="tag">scheduler-framework</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/secret/" rel="tag">secret</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webhook/" rel="tag">webhook</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9B%E5%BB%BApod%E6%B5%81%E7%A8%8B/" rel="tag">创建pod流程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" rel="tag">性能分析</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%83%A8%E7%BD%B2k8s%E9%9B%86%E7%BE%A4/" rel="tag">部署k8s集群</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SyncLoop"><span class="toc-number">1.</span> <span class="toc-text">SyncLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#syncLoopIteration"><span class="toc-number">1.1.</span> <span class="toc-text">syncLoopIteration</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BApod%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">创建pod过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Handler"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">Handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#podWorkers-%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">podWorkers 的工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#syncPod"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">syncPod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">创建容器</span></a></li></ol></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-kubelet-create-pod" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      kubelet 创建 pod 源码分析
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/03/09/08/" class="article-date">
	  <time datetime="2023-03-09T02:33:08.000Z" itemprop="datePublished">2023-03-09</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/kubelet/">kubelet</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/kubelet/" rel="tag">kubelet</a>, <a class="article-tag-link-link" href="/tags/%E5%88%9B%E5%BB%BApod%E6%B5%81%E7%A8%8B/" rel="tag">创建pod流程</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/03/09/08/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 5.9k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 34(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>本来基于 kubernetnes : v1.25.4</p>
<p>之前那篇文章对 kubelet 的工作原理做了简单的介绍，接下来，我们对 pod 创建的流程中，kubelet 创建 pod 进行一个详细的分析。</p>
<img src="kubelet-create-pod/kubelet-arch.jpg" alt="kubelet-arch"  />





<h1 id="SyncLoop"><a href="#SyncLoop" class="headerlink" title="SyncLoop"></a>SyncLoop</h1><p>我们来看下这个主循环 SyncLoop：</p>
<p><em><u>/pkg/kubelet/kubelet.go#2009</u></em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> syncLoop(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler) &#123;</span><br><span class="line">	klog.InfoS(<span class="string">&quot;Starting kubelet main sync loop&quot;</span>)</span><br><span class="line">	<span class="comment">// The syncTicker wakes up kubelet to checks if there are any pod workers</span></span><br><span class="line">	<span class="comment">// that need to be sync&#x27;d. A one-second period is sufficient because the</span></span><br><span class="line">	<span class="comment">// sync interval is defaulted to 10s.</span></span><br><span class="line">	syncTicker := time.NewTicker(time.Second)</span><br><span class="line">	<span class="keyword">defer</span> syncTicker.Stop()</span><br><span class="line">	housekeepingTicker := time.NewTicker(housekeepingPeriod)</span><br><span class="line">	<span class="keyword">defer</span> housekeepingTicker.Stop()</span><br><span class="line">	plegCh := kl.pleg.Watch()</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		base   = <span class="number">100</span> * time.Millisecond</span><br><span class="line">		max    = <span class="number">5</span> * time.Second</span><br><span class="line">		factor = <span class="number">2</span></span><br><span class="line">	)</span><br><span class="line">	duration := base</span><br><span class="line">	<span class="comment">// Responsible for checking limits in resolv.conf</span></span><br><span class="line">	<span class="comment">// The limits do not have anything to do with individual pods</span></span><br><span class="line">	<span class="comment">// Since this is called in syncLoop, we don&#x27;t need to call it anywhere else</span></span><br><span class="line">	<span class="keyword">if</span> kl.dnsConfigurer != <span class="literal">nil</span> &amp;&amp; kl.dnsConfigurer.ResolverConfig != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		kl.dnsConfigurer.CheckLimitsForResolvConf()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := kl.runtimeState.runtimeErrors(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.ErrorS(err, <span class="string">&quot;Skipping pod synchronization&quot;</span>)</span><br><span class="line">			<span class="comment">// exponential backoff</span></span><br><span class="line">			time.Sleep(duration)</span><br><span class="line">			duration = time.Duration(math.Min(<span class="type">float64</span>(max), factor*<span class="type">float64</span>(duration)))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// reset backoff if we have a success</span></span><br><span class="line">		duration = base</span><br><span class="line"></span><br><span class="line">		kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">		<span class="keyword">if</span> !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SyncLoop 起了一个死循环，循环里只调用了 syncLoopIteration 方法。而 syncLoopIteration 会对传入的所有 channel 遍历，发现任何一个管道有消息就交给 handler 去处理。</p>
<p>这些 channel 包括：</p>
<ul>
<li><strong>configCh：</strong>该 channel 的生产者为 kubeDeps 对象中的 PodConfig 子模块提供，该模块将同时监听来自 file，http，apiserver 的 pod 信息的变化，一旦某个来源的 pod 信息发生了更新，就会向这个 channel 生产相关事件。</li>
<li><strong>plegCh：</strong>该 channel 的生产者为 pleg 子模块，该模块会周期性地向容器运行时查询当前所有容器的状态，如果状态发生变化，则向这个 channel 生产事件。</li>
<li><strong>syncCh：</strong>定时同步最新保存的 pod 状态。</li>
<li><strong>health manager :</strong> livenessManager、readinessManager、startupManager 健康检查发现某个 pod 不可用，Kubelet 将根据 Pod 的 restartPolicy 自动执行正确的操作。</li>
<li><strong>houseKeepingCh：</strong>housekeeping 事件的管道，做 pod 清理工作。</li>
</ul>
<h2 id="syncLoopIteration"><a href="#syncLoopIteration" class="headerlink" title="syncLoopIteration"></a>syncLoopIteration</h2><p><em><u>/pkg/kubelet/kubelet.go#2083</u></em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> syncLoopIteration(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span><br><span class="line">	syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">case</span> u, open := &lt;-configCh:</span><br><span class="line">		<span class="comment">// Update from a config source; dispatch it to the right handler</span></span><br><span class="line">		<span class="comment">// callback.</span></span><br><span class="line">		<span class="keyword">if</span> !open &#123;</span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Update channel is closed, exiting the sync loop&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> u.Op &#123;</span><br><span class="line">		<span class="keyword">case</span> kubetypes.ADD:</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop ADD&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">			<span class="comment">// After restarting, kubelet will get all existing pods through</span></span><br><span class="line">			<span class="comment">// ADD as if they are new pods. These pods will then go through the</span></span><br><span class="line">			<span class="comment">// admission process and *may* be rejected. This can be resolved</span></span><br><span class="line">			<span class="comment">// once we have checkpointing.</span></span><br><span class="line">			handler.HandlePodAdditions(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.UPDATE:</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop UPDATE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">			handler.HandlePodUpdates(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.REMOVE:</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop REMOVE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">			handler.HandlePodRemoves(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.RECONCILE:</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop RECONCILE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">			handler.HandlePodReconcile(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.DELETE:</span><br><span class="line">			klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop DELETE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">			<span class="comment">// DELETE is treated as a UPDATE because of graceful deletion.</span></span><br><span class="line">			handler.HandlePodUpdates(u.Pods)</span><br><span class="line">		<span class="keyword">case</span> kubetypes.SET:</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> Do we want to support this?</span></span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Kubelet does not support snapshot update&quot;</span>)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Invalid operation type received&quot;</span>, <span class="string">&quot;operation&quot;</span>, u.Op)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		kl.sourcesReady.AddSource(u.Source)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> e := &lt;-plegCh:</span><br><span class="line">		<span class="keyword">if</span> e.Type == pleg.ContainerStarted &#123;</span><br><span class="line">			<span class="comment">// record the most recent time we observed a container start for this pod.</span></span><br><span class="line">			<span class="comment">// this lets us selectively invalidate the runtimeCache when processing a delete for this pod</span></span><br><span class="line">			<span class="comment">// to make sure we don&#x27;t miss handling graceful termination for containers we reported as having started.</span></span><br><span class="line">			kl.lastContainerStartedTime.Add(e.ID, time.Now())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> isSyncPodWorthy(e) &#123;</span><br><span class="line">			<span class="comment">// PLEG event for a pod; sync it.</span></span><br><span class="line">			<span class="keyword">if</span> pod, ok := kl.podManager.GetPodByUID(e.ID); ok &#123;</span><br><span class="line">				klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop (PLEG): event for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;event&quot;</span>, e)</span><br><span class="line">				handler.HandlePodSyncs([]*v1.Pod&#123;pod&#125;)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// If the pod no longer exists, ignore the event.</span></span><br><span class="line">				klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (PLEG): pod does not exist, ignore irrelevant event&quot;</span>, <span class="string">&quot;event&quot;</span>, e)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> e.Type == pleg.ContainerDied &#123;</span><br><span class="line">			<span class="keyword">if</span> containerID, ok := e.Data.(<span class="type">string</span>); ok &#123;</span><br><span class="line">				kl.cleanUpContainersInPod(e.ID, containerID)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> &lt;-syncCh:</span><br><span class="line">		<span class="comment">// Sync pods waiting for sync</span></span><br><span class="line">		podsToSync := kl.getPodsToSync()</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(podsToSync) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (SYNC) pods&quot;</span>, <span class="string">&quot;total&quot;</span>, <span class="built_in">len</span>(podsToSync), <span class="string">&quot;pods&quot;</span>, klog.KObjs(podsToSync))</span><br><span class="line">		handler.HandlePodSyncs(podsToSync)</span><br><span class="line">	<span class="keyword">case</span> update := &lt;-kl.livenessManager.Updates():</span><br><span class="line">		<span class="keyword">if</span> update.Result == proberesults.Failure &#123;</span><br><span class="line">			handleProbeSync(kl, update, handler, <span class="string">&quot;liveness&quot;</span>, <span class="string">&quot;unhealthy&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> update := &lt;-kl.readinessManager.Updates():</span><br><span class="line">		ready := update.Result == proberesults.Success</span><br><span class="line">		kl.statusManager.SetContainerReadiness(update.PodUID, update.ContainerID, ready)</span><br><span class="line"></span><br><span class="line">		status := <span class="string">&quot;&quot;</span></span><br><span class="line">		<span class="keyword">if</span> ready &#123;</span><br><span class="line">			status = <span class="string">&quot;ready&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		handleProbeSync(kl, update, handler, <span class="string">&quot;readiness&quot;</span>, status)</span><br><span class="line">	<span class="keyword">case</span> update := &lt;-kl.startupManager.Updates():</span><br><span class="line">		started := update.Result == proberesults.Success</span><br><span class="line">		kl.statusManager.SetContainerStartup(update.PodUID, update.ContainerID, started)</span><br><span class="line"></span><br><span class="line">		status := <span class="string">&quot;unhealthy&quot;</span></span><br><span class="line">		<span class="keyword">if</span> started &#123;</span><br><span class="line">			status = <span class="string">&quot;started&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		handleProbeSync(kl, update, handler, <span class="string">&quot;startup&quot;</span>, status)</span><br><span class="line">	<span class="keyword">case</span> &lt;-housekeepingCh:</span><br><span class="line">		<span class="keyword">if</span> !kl.sourcesReady.AllReady() &#123;</span><br><span class="line">			<span class="comment">// If the sources aren&#x27;t ready or volume manager has not yet synced the states,</span></span><br><span class="line">			<span class="comment">// skip housekeeping, as we may accidentally delete pods from unready sources.</span></span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (housekeeping, skipped): sources aren&#x27;t ready yet&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			start := time.Now()</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (housekeeping)&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> err := handler.HandlePodCleanups(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">&quot;Failed cleaning pods&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			duration := time.Since(start)</span><br><span class="line">			<span class="keyword">if</span> duration &gt; housekeepingWarningDuration &#123;</span><br><span class="line">				klog.ErrorS(fmt.Errorf(<span class="string">&quot;housekeeping took too long&quot;</span>), <span class="string">&quot;Housekeeping took longer than 15s&quot;</span>, <span class="string">&quot;seconds&quot;</span>, duration.Seconds())</span><br><span class="line">			&#125;</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (housekeeping) end&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建pod过程"><a href="#创建pod过程" class="headerlink" title="创建pod过程"></a>创建pod过程</h3><p>Kubelet 创建 pod 的过程是由 configCh 中的 ADD 事件触发的，那么下面主要看下 Kubelet 接收到 ADD 事件后的主要流程。</p>
<h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>当 configCh 中出现了 ADD 事件，loop 会触发 SyncHandler 的 HandlePodAdditions 方法。这个方法的流程可以用下面这张流程图描述：</p>
<img src="/2023/03/09/08/handlePodAdditions.png" class="" title="handlePodAdditions">

<ul>
<li><p>首先 handler 会将所有的 pod 安装创建时间进行排序，然后逐个进行处理。</p>
</li>
<li><p>然后将 pod 添加到 podManager 中，以方便后续操作；然后判断其是否为 mirror pod，如果是将作为 mirror pod 处理，否则按照正常 pod 处理。</p>
<p>这里解释一下 mirror pod： mirror pod 是 static pod 在 kueblet 在 apiserver 创建的一份副本。由于 static pod 是由 Kubelet 直接管理的，apiserver 并不会感知到 static pod 的存在，其生命周期都由 Kubelet 直接托管。为了可以通过 kubectl 命令查看对应的 pod，并且可以通过 kubectl logs 命令直接查看到static pod 的日志信息，Kubelet 通过 apiserver 为每一个 static pod 创建一个对应的 mirror pod。</p>
</li>
<li><p>接着判断 pod 是否能再该节点上运行，也就是所谓的 Kubelet 中的 pod 准入控制，准入控制主要包括这几方面：</p>
</li>
</ul>
<ol>
<li>节点是否满足 pod 的亲和性规则</li>
<li>节点是否有足够的资源分配给 pod</li>
<li>节点是否使用 HostNetwork 或者 HostIPC，若使用了，是否在节点的白名单里</li>
<li>/proc 挂载目录满足要求</li>
<li>pod 是否配置且是否配置正确的 AppArmor</li>
</ol>
<ul>
<li>当所有的条件都满足后，最后触发 podWorker 同步 pod。</li>
</ul>
<p>HandlePodAdditions 对应的代码如下：</p>
<p><u><em>/pkg/kubelet/kubelet.go#2238</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> HandlePodAdditions(pods []*v1.Pod) &#123;</span><br><span class="line">	start := kl.clock.Now()</span><br><span class="line">	sort.Sort(sliceutils.PodsByCreationTime(pods))</span><br><span class="line">	<span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">		existingPods := kl.podManager.GetPods()</span><br><span class="line">		<span class="comment">// Always add the pod to the pod manager. Kubelet relies on the pod</span></span><br><span class="line">		<span class="comment">// manager as the source of truth for the desired state. If a pod does</span></span><br><span class="line">		<span class="comment">// not exist in the pod manager, it means that it has been deleted in</span></span><br><span class="line">		<span class="comment">// the apiserver and no action (other than cleanup) is required.</span></span><br><span class="line">		kl.podManager.AddPod(pod)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> kubetypes.IsMirrorPod(pod) &#123;</span><br><span class="line">			kl.handleMirrorPod(pod, start)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Only go through the admission process if the pod is not requested</span></span><br><span class="line">		<span class="comment">// for termination by another part of the kubelet. If the pod is already</span></span><br><span class="line">		<span class="comment">// using resources (previously admitted), the pod worker is going to be</span></span><br><span class="line">		<span class="comment">// shutting it down. If the pod hasn&#x27;t started yet, we know that when</span></span><br><span class="line">		<span class="comment">// the pod worker is invoked it will also avoid setting up the pod, so</span></span><br><span class="line">		<span class="comment">// we simply avoid doing any work.</span></span><br><span class="line">		<span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line">			<span class="comment">// We failed pods that we rejected, so activePods include all admitted</span></span><br><span class="line">			<span class="comment">// pods that are alive.</span></span><br><span class="line">			activePods := kl.filterOutInactivePods(existingPods)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check if we can admit the pod; if not, reject it.</span></span><br><span class="line">			<span class="keyword">if</span> ok, reason, message := kl.canAdmitPod(activePods, pod); !ok &#123;</span><br><span class="line">				kl.rejectPod(pod, reason, message)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		mirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)</span><br><span class="line">		kl.dispatchWork(pod, kubetypes.SyncPodCreate, mirrorPod, start)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="podWorkers-的工作"><a href="#podWorkers-的工作" class="headerlink" title="podWorkers 的工作"></a>podWorkers 的工作</h4><p>接下来看看 podWorker 的工作。podWorker 维护了一个 map 叫 podUpdates (map[types.UID]chan podWork)，以 pod uid 为 key，为每个 pod 维护一个 channel；当 pod 有事件过来的时候，首先从这个 map 里获取对应的 channel，然后启动一个 goroutine 监听这个 channel，并执行 managePodLoop；另一方面 podWorker 向这个 channel 中传入需要同步的 pod。</p>
<p>managePodLoop 接收到事件后，会先从 pod cache 中获取该 pod 最新的 status，以确保当前处理的 pod 是最新状态；然后调用 syncPod 方法，将其同步后的结果记录在 workQueue 中，等待下一次定时同步任务处理。</p>
<p>整个过程如下图所示：</p>
<img src="/2023/03/09/08/2020-08-02-161428.jpg" class="" title="img">

<p>podWorker 中处理 pod 事件的代码：</p>
<p><u><em>/pkg/kubelet/pod_workers.go#557</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span></span> UpdatePod(options UpdatePodOptions) &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// allow testing of delays in the pod update channel</span></span><br><span class="line">		<span class="keyword">var</span> outCh &lt;-<span class="keyword">chan</span> podWork</span><br><span class="line">		<span class="keyword">if</span> p.workerChannelFn != <span class="literal">nil</span> &#123;</span><br><span class="line">			outCh = p.workerChannelFn(uid, podUpdates)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			outCh = podUpdates</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Creating a new pod worker either means this is a new pod, or that the</span></span><br><span class="line">		<span class="comment">// kubelet just restarted. In either case the kubelet is willing to believe</span></span><br><span class="line">		<span class="comment">// the status of the pod for the first pod worker sync. See corresponding</span></span><br><span class="line">		<span class="comment">// comment in syncPod.</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> runtime.HandleCrash()</span><br><span class="line">			p.managePodLoop(outCh)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dispatch a request to the pod worker if none are running</span></span><br><span class="line">	<span class="keyword">if</span> !status.IsWorking() &#123;</span><br><span class="line">		status.working = <span class="literal">true</span></span><br><span class="line">		podUpdates &lt;- work</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>managePodLoop 函数，会根据 update.WorkType 类型，去分别执行 syncTerminatedPodFn、syncTerminatingPodFn、syncPodFn方法去调用</p>
<p><u><em>/pkg/kubelet/pod_worker.go#877</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span></span> managePodLoop(podUpdates &lt;-<span class="keyword">chan</span> podWork) &#123;</span><br><span class="line">	<span class="keyword">var</span> lastSyncTime time.Time</span><br><span class="line">	<span class="keyword">var</span> podStarted <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> update := <span class="keyword">range</span> podUpdates &#123;</span><br><span class="line">		pod := update.Options.Pod</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// Take the appropriate action (illegal phases are prevented by UpdatePod)</span></span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> update.WorkType == TerminatedPodWork:</span><br><span class="line">				err = p.syncTerminatedPodFn(ctx, pod, status)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> update.WorkType == TerminatingPodWork:</span><br><span class="line">				<span class="keyword">var</span> gracePeriod *<span class="type">int64</span></span><br><span class="line">				<span class="keyword">if</span> opt := update.Options.KillPodOptions; opt != <span class="literal">nil</span> &#123;</span><br><span class="line">					gracePeriod = opt.PodTerminationGracePeriodSecondsOverride</span><br><span class="line">				&#125;</span><br><span class="line">				podStatusFn := p.acknowledgeTerminating(pod)</span><br><span class="line"></span><br><span class="line">				err = p.syncTerminatingPodFn(ctx, pod, status, update.Options.RunningPod, gracePeriod, podStatusFn)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				isTerminal, err = p.syncPodFn(ctx, update.Options.UpdateType, pod, update.Options.MirrorPod, status)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			lastSyncTime = time.Now()</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;()</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// queue a retry if necessary, then put the next event in the channel if any</span></span><br><span class="line">		p.completeWork(pod, phaseTransition, err)</span><br><span class="line">		<span class="keyword">if</span> start := update.Options.StartTime; !start.IsZero() &#123;</span><br><span class="line">			metrics.PodWorkerDuration.WithLabelValues(update.Options.UpdateType.String()).Observe(metrics.SinceInSeconds(start))</span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Processing pod event done&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID, <span class="string">&quot;updateType&quot;</span>, update.WorkType)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="syncPod"><a href="#syncPod" class="headerlink" title="syncPod"></a>syncPod</h4><p>上述 podWorker 在 managePodLoop 中调用的 syncPodFn 方法，其实是 Kubelet 对象的 SyncPod 方法，在文件 pkg/kubelet/kubelet.go 中。</p>
<p>这个方法是真正与 container runtime 层交互的。首先，如果正在创建，记录pod worker启动延迟；设置podIP为hostIP；然后判断是否可以在节点上运行，这里就是上面讲到的 Kubelet 的准入控制；再判断 CNI 插件是否 ready，如果不 ready，则只在 pod 使用 host network 的时候创建并更新 pod 的 cgroups；接着再判断是否是静态 pod，如果是就创建相应的 mirror pod；然后创建 pod 需要挂载的目录；最后调用 runtime 的 syncPod。整个流程如下所示：</p>
<img src="/2023/03/09/08/syncPod-8419730.png" class="" title="syncPod">

<p><u><em>/pkg/kubelet/kubelet.go#1522</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> syncPod(ctx context.Context, updateType kubetypes.SyncPodType, pod, mirrorPod *v1.Pod, podStatus *kubecontainer.PodStatus) (isTerminal <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;syncPod enter&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;syncPod exit&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID, <span class="string">&quot;isTerminal&quot;</span>, isTerminal)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Latency measurements for the main workflow are relative to the</span></span><br><span class="line">	<span class="comment">// first time the pod was seen by kubelet.</span></span><br><span class="line">	<span class="keyword">var</span> firstSeenTime time.Time</span><br><span class="line">	<span class="keyword">if</span> firstSeenTimeStr, ok := pod.Annotations[kubetypes.ConfigFirstSeenAnnotationKey]; ok &#123;</span><br><span class="line">		firstSeenTime = kubetypes.ConvertToTimestamp(firstSeenTimeStr).Get()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Record pod worker start latency if being created</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> make pod workers record their own latencies</span></span><br><span class="line">	<span class="keyword">if</span> updateType == kubetypes.SyncPodCreate &#123;</span><br><span class="line">		<span class="keyword">if</span> !firstSeenTime.IsZero() &#123;</span><br><span class="line">			<span class="comment">// This is the first time we are syncing the pod. Record the latency</span></span><br><span class="line">			<span class="comment">// since kubelet first saw the pod if firstSeenTime is set.</span></span><br><span class="line">			metrics.PodWorkerStartDuration.Observe(metrics.SinceInSeconds(firstSeenTime))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;First seen time not recorded for pod&quot;</span>,</span><br><span class="line">				<span class="string">&quot;podUID&quot;</span>, pod.UID,</span><br><span class="line">				<span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Generate final API pod status with pod and status manager status</span></span><br><span class="line">	apiPodStatus := kl.generateAPIPodStatus(pod, podStatus)</span><br><span class="line">	<span class="comment">// The pod IP may be changed in generateAPIPodStatus if the pod is using host network. (See #24576)</span></span><br><span class="line">	<span class="comment">// TODO(random-liu): After writing pod spec into container labels, check whether pod is using host network, and</span></span><br><span class="line">	<span class="comment">// set pod IP to hostIP directly in runtime.GetPodStatus</span></span><br><span class="line">	podStatus.IPs = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(apiPodStatus.PodIPs))</span><br><span class="line">	<span class="keyword">for</span> _, ipInfo := <span class="keyword">range</span> apiPodStatus.PodIPs &#123;</span><br><span class="line">		podStatus.IPs = <span class="built_in">append</span>(podStatus.IPs, ipInfo.IP)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(podStatus.IPs) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(apiPodStatus.PodIP) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		podStatus.IPs = []<span class="type">string</span>&#123;apiPodStatus.PodIP&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the pod is terminal, we don&#x27;t need to continue to setup the pod</span></span><br><span class="line">	<span class="keyword">if</span> apiPodStatus.Phase == v1.PodSucceeded || apiPodStatus.Phase == v1.PodFailed &#123;</span><br><span class="line">		kl.statusManager.SetPodStatus(pod, apiPodStatus)</span><br><span class="line">		isTerminal = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> isTerminal, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the pod should not be running, we request the pod&#x27;s containers be stopped. This is not the same</span></span><br><span class="line">	<span class="comment">// as termination (we want to stop the pod, but potentially restart it later if soft admission allows</span></span><br><span class="line">	<span class="comment">// it later). Set the status and phase appropriately</span></span><br><span class="line">	runnable := kl.canRunPod(pod)</span><br><span class="line">	<span class="keyword">if</span> !runnable.Admit &#123;</span><br><span class="line">		<span class="comment">// Pod is not runnable; and update the Pod and Container statuses to why.</span></span><br><span class="line">		<span class="keyword">if</span> apiPodStatus.Phase != v1.PodFailed &amp;&amp; apiPodStatus.Phase != v1.PodSucceeded &#123;</span><br><span class="line">			apiPodStatus.Phase = v1.PodPending</span><br><span class="line">		&#125;</span><br><span class="line">		apiPodStatus.Reason = runnable.Reason</span><br><span class="line">		apiPodStatus.Message = runnable.Message</span><br><span class="line">		<span class="comment">// Waiting containers are not creating.</span></span><br><span class="line">		<span class="keyword">const</span> waitingReason = <span class="string">&quot;Blocked&quot;</span></span><br><span class="line">		<span class="keyword">for</span> _, cs := <span class="keyword">range</span> apiPodStatus.InitContainerStatuses &#123;</span><br><span class="line">			<span class="keyword">if</span> cs.State.Waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">				cs.State.Waiting.Reason = waitingReason</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, cs := <span class="keyword">range</span> apiPodStatus.ContainerStatuses &#123;</span><br><span class="line">			<span class="keyword">if</span> cs.State.Waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">				cs.State.Waiting.Reason = waitingReason</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Record the time it takes for the pod to become running</span></span><br><span class="line">	<span class="comment">// since kubelet first saw the pod if firstSeenTime is set.</span></span><br><span class="line">	existingStatus, ok := kl.statusManager.GetPodStatus(pod.UID)</span><br><span class="line">	<span class="keyword">if</span> !ok || existingStatus.Phase == v1.PodPending &amp;&amp; apiPodStatus.Phase == v1.PodRunning &amp;&amp;</span><br><span class="line">		!firstSeenTime.IsZero() &#123;</span><br><span class="line">		metrics.PodStartDuration.Observe(metrics.SinceInSeconds(firstSeenTime))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kl.statusManager.SetPodStatus(pod, apiPodStatus)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pods that are not runnable must be stopped - return a typed error to the pod worker</span></span><br><span class="line">	<span class="keyword">if</span> !runnable.Admit &#123;</span><br><span class="line">		klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;Pod is not runnable and must have running containers stopped&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID, <span class="string">&quot;message&quot;</span>, runnable.Message)</span><br><span class="line">		<span class="keyword">var</span> syncErr <span class="type">error</span></span><br><span class="line">		p := kubecontainer.ConvertPodStatusToRunningPod(kl.getRuntime().Type(), podStatus)</span><br><span class="line">		<span class="keyword">if</span> err := kl.killPod(pod, p, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToKillPod, <span class="string">&quot;error killing pod: %v&quot;</span>, err)</span><br><span class="line">			syncErr = fmt.Errorf(<span class="string">&quot;error killing pod: %v&quot;</span>, err)</span><br><span class="line">			utilruntime.HandleError(syncErr)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// There was no error killing the pod, but the pod cannot be run.</span></span><br><span class="line">			<span class="comment">// Return an error to signal that the sync loop should back off.</span></span><br><span class="line">			syncErr = fmt.Errorf(<span class="string">&quot;pod cannot be run: %s&quot;</span>, runnable.Message)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, syncErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the network plugin is not ready, only start the pod if it uses the host network</span></span><br><span class="line">	<span class="keyword">if</span> err := kl.runtimeState.networkErrors(); err != <span class="literal">nil</span> &amp;&amp; !kubecontainer.IsHostNetworkPod(pod) &#123;</span><br><span class="line">		kl.recorder.Eventf(pod, v1.EventTypeWarning, events.NetworkNotReady, <span class="string">&quot;%s: %v&quot;</span>, NetworkNotReadyErrorMsg, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;%s: %v&quot;</span>, NetworkNotReadyErrorMsg, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ensure the kubelet knows about referenced secrets or configmaps used by the pod</span></span><br><span class="line">	<span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line">		<span class="keyword">if</span> kl.secretManager != <span class="literal">nil</span> &#123;</span><br><span class="line">			kl.secretManager.RegisterPod(pod)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> kl.configMapManager != <span class="literal">nil</span> &#123;</span><br><span class="line">			kl.configMapManager.RegisterPod(pod)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create Cgroups for the pod and apply resource parameters</span></span><br><span class="line">	<span class="comment">// to them if cgroups-per-qos flag is enabled.</span></span><br><span class="line">	pcm := kl.containerManager.NewPodContainerManager()</span><br><span class="line">	<span class="comment">// If pod has already been terminated then we need not create</span></span><br><span class="line">	<span class="comment">// or update the pod&#x27;s cgroup</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> once context cancellation is added this check can be removed</span></span><br><span class="line">	<span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line">		<span class="comment">// When the kubelet is restarted with the cgroups-per-qos</span></span><br><span class="line">		<span class="comment">// flag enabled, all the pod&#x27;s running containers</span></span><br><span class="line">		<span class="comment">// should be killed intermittently and brought back up</span></span><br><span class="line">		<span class="comment">// under the qos cgroup hierarchy.</span></span><br><span class="line">		<span class="comment">// Check if this is the pod&#x27;s first sync</span></span><br><span class="line">		firstSync := <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> _, containerStatus := <span class="keyword">range</span> apiPodStatus.ContainerStatuses &#123;</span><br><span class="line">			<span class="keyword">if</span> containerStatus.State.Running != <span class="literal">nil</span> &#123;</span><br><span class="line">				firstSync = <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Don&#x27;t kill containers in pod if pod&#x27;s cgroups already</span></span><br><span class="line">		<span class="comment">// exists or the pod is running for the first time</span></span><br><span class="line">		podKilled := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> !pcm.Exists(pod) &amp;&amp; !firstSync &#123;</span><br><span class="line">			p := kubecontainer.ConvertPodStatusToRunningPod(kl.getRuntime().Type(), podStatus)</span><br><span class="line">			<span class="keyword">if</span> err := kl.killPod(pod, p, <span class="literal">nil</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">				podKilled = <span class="literal">true</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				klog.ErrorS(err, <span class="string">&quot;KillPod failed&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podStatus&quot;</span>, podStatus)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Create and Update pod&#x27;s Cgroups</span></span><br><span class="line">		<span class="comment">// Don&#x27;t create cgroups for run once pod if it was killed above</span></span><br><span class="line">		<span class="comment">// The current policy is not to restart the run once pods when</span></span><br><span class="line">		<span class="comment">// the kubelet is restarted with the new flag as run once pods are</span></span><br><span class="line">		<span class="comment">// expected to run only once and if the kubelet is restarted then</span></span><br><span class="line">		<span class="comment">// they are not expected to run again.</span></span><br><span class="line">		<span class="comment">// We don&#x27;t create and apply updates to cgroup if its a run once pod and was killed above</span></span><br><span class="line">		<span class="keyword">if</span> !(podKilled &amp;&amp; pod.Spec.RestartPolicy == v1.RestartPolicyNever) &#123;</span><br><span class="line">			<span class="keyword">if</span> !pcm.Exists(pod) &#123;</span><br><span class="line">				<span class="keyword">if</span> err := kl.containerManager.UpdateQOSCgroups(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;Failed to update QoS cgroups while syncing pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> err := pcm.EnsureExists(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToCreatePodContainer, <span class="string">&quot;unable to ensure pod container exists: %v&quot;</span>, err)</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;failed to ensure that the pod: %v cgroups exist and are correctly applied: %v&quot;</span>, pod.UID, err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create Mirror Pod for Static Pod if it doesn&#x27;t already exist</span></span><br><span class="line">	<span class="keyword">if</span> kubetypes.IsStaticPod(pod) &#123;</span><br><span class="line">		deleted := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> mirrorPod != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> mirrorPod.DeletionTimestamp != <span class="literal">nil</span> || !kl.podManager.IsMirrorPodOf(mirrorPod, pod) &#123;</span><br><span class="line">				<span class="comment">// The mirror pod is semantically different from the static pod. Remove</span></span><br><span class="line">				<span class="comment">// it. The mirror pod will get recreated later.</span></span><br><span class="line">				klog.InfoS(<span class="string">&quot;Trying to delete pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, mirrorPod.ObjectMeta.UID)</span><br><span class="line">				podFullName := kubecontainer.GetPodFullName(pod)</span><br><span class="line">				<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">				deleted, err = kl.podManager.DeleteMirrorPod(podFullName, &amp;mirrorPod.ObjectMeta.UID)</span><br><span class="line">				<span class="keyword">if</span> deleted &#123;</span><br><span class="line">					klog.InfoS(<span class="string">&quot;Deleted mirror pod because it is outdated&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(mirrorPod))</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					klog.ErrorS(err, <span class="string">&quot;Failed deleting mirror pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(mirrorPod))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> mirrorPod == <span class="literal">nil</span> || deleted &#123;</span><br><span class="line">			node, err := kl.GetNode()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> || node.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;No need to create a mirror pod, since node has been removed from the cluster&quot;</span>, <span class="string">&quot;node&quot;</span>, klog.KRef(<span class="string">&quot;&quot;</span>, <span class="type">string</span>(kl.nodeName)))</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Creating a mirror pod for static pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">				<span class="keyword">if</span> err := kl.podManager.CreateMirrorPod(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					klog.ErrorS(err, <span class="string">&quot;Failed creating a mirror pod for&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make data directories for the pod</span></span><br><span class="line">	<span class="keyword">if</span> err := kl.makePodDataDirs(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToMakePodDataDirectories, <span class="string">&quot;error making pod data directories: %v&quot;</span>, err)</span><br><span class="line">		klog.ErrorS(err, <span class="string">&quot;Unable to make pod data directories for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Volume manager will not mount volumes for terminating pods</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> once context cancellation is added this check can be removed</span></span><br><span class="line">	<span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line">		<span class="comment">// Wait for volumes to attach/mount</span></span><br><span class="line">		<span class="keyword">if</span> err := kl.volumeManager.WaitForAttachAndMount(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedMountVolume, <span class="string">&quot;Unable to attach or mount volumes: %v&quot;</span>, err)</span><br><span class="line">			klog.ErrorS(err, <span class="string">&quot;Unable to attach or mount volumes for pod; skipping pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fetch the pull secrets for the pod</span></span><br><span class="line">	pullSecrets := kl.getPullSecretsForPod(pod)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ensure the pod is being probed</span></span><br><span class="line">	kl.probeManager.AddPod(pod)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call the container runtime&#x27;s SyncPod callback</span></span><br><span class="line">	result := kl.containerRuntime.SyncPod(pod, podStatus, pullSecrets, kl.backOff)</span><br><span class="line">	kl.reasonCache.Update(pod.UID, result)</span><br><span class="line">	<span class="keyword">if</span> err := result.Error(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Do not return error if the only failures were pods in backoff</span></span><br><span class="line">		<span class="keyword">for</span> _, r := <span class="keyword">range</span> result.SyncResults &#123;</span><br><span class="line">			<span class="keyword">if</span> r.Error != kubecontainer.ErrCrashLoopBackOff &amp;&amp; r.Error != images.ErrImagePullBackOff &#123;</span><br><span class="line">				<span class="comment">// Do not record an event here, as we keep all event logging for sync pod failures</span></span><br><span class="line">				<span class="comment">// local to container runtime, so we get better errors.</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><p>containerRuntime（pkg/kubelet/kuberuntime）子模块的 SyncPod 函数才是真正完成 pod 内容器实体的创建。</p>
<p><u><em>/pkg/kubelet/kuberuntime/kuberuntime_manager.go#668</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span></span> SyncPod(pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) &#123;</span><br><span class="line">	<span class="comment">// Step 1: Compute sandbox and container changes.</span></span><br><span class="line">	podContainerChanges := m.computePodActions(pod, podStatus)</span><br><span class="line">	klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;computePodActions got for pod&quot;</span>, <span class="string">&quot;podActions&quot;</span>, podContainerChanges, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">		ref, err := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.ErrorS(err, <span class="string">&quot;Couldn&#x27;t make a ref to pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> podContainerChanges.SandboxID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			m.recorder.Eventf(ref, v1.EventTypeNormal, events.SandboxChanged, <span class="string">&quot;Pod sandbox changed, it will be killed and re-created.&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncPod received new pod, will create a sandbox for it&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Kill the pod if the sandbox has changed.</span></span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.KillPod &#123;</span><br><span class="line">		<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Stopping PodSandbox for pod, will start new one&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Stopping PodSandbox for pod, because all other containers are dead&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		killResult := m.killPodWithSyncResult(pod, kubecontainer.ConvertPodStatusToRunningPod(m.runtimeName, podStatus), <span class="literal">nil</span>)</span><br><span class="line">		result.AddPodSyncResult(killResult)</span><br><span class="line">		<span class="keyword">if</span> killResult.Error() != <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.ErrorS(killResult.Error(), <span class="string">&quot;killPodWithSyncResult failed&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">			m.purgeInitContainers(pod, podStatus)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Step 3: kill any running containers in this pod which are not to keep.</span></span><br><span class="line">		<span class="keyword">for</span> containerID, containerInfo := <span class="keyword">range</span> podContainerChanges.ContainersToKill &#123;</span><br><span class="line">			klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;Killing unwanted container for pod&quot;</span>, <span class="string">&quot;containerName&quot;</span>, containerInfo.name, <span class="string">&quot;containerID&quot;</span>, containerID, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">			killContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, containerInfo.name)</span><br><span class="line">			result.AddSyncResult(killContainerResult)</span><br><span class="line">			<span class="keyword">if</span> err := m.killContainer(pod, containerID, containerInfo.name, containerInfo.message, containerInfo.reason, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				killContainerResult.Fail(kubecontainer.ErrKillContainer, err.Error())</span><br><span class="line">				klog.ErrorS(err, <span class="string">&quot;killContainer for pod failed&quot;</span>, <span class="string">&quot;containerName&quot;</span>, containerInfo.name, <span class="string">&quot;containerID&quot;</span>, containerID, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Keep terminated init containers fairly aggressively controlled</span></span><br><span class="line">	<span class="comment">// This is an optimization because container removals are typically handled</span></span><br><span class="line">	<span class="comment">// by container garbage collector.</span></span><br><span class="line">	m.pruneInitContainersBeforeStart(pod, podStatus)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We pass the value of the PRIMARY podIP and list of podIPs down to</span></span><br><span class="line">	<span class="comment">// generatePodSandboxConfig and generateContainerConfig, which in turn</span></span><br><span class="line">	<span class="comment">// passes it to various other functions, in order to facilitate functionality</span></span><br><span class="line">	<span class="comment">// that requires this value (hosts file and downward API) and avoid races determining</span></span><br><span class="line">	<span class="comment">// the pod IP in cases where a container requires restart but the</span></span><br><span class="line">	<span class="comment">// podIP isn&#x27;t in the status manager yet. The list of podIPs is used to</span></span><br><span class="line">	<span class="comment">// generate the hosts file.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// We default to the IPs in the passed-in pod status, and overwrite them if the</span></span><br><span class="line">	<span class="comment">// sandbox needs to be (re)started.</span></span><br><span class="line">	<span class="keyword">var</span> podIPs []<span class="type">string</span></span><br><span class="line">	<span class="keyword">if</span> podStatus != <span class="literal">nil</span> &#123;</span><br><span class="line">		podIPs = podStatus.IPs</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4: Create a sandbox for the pod if necessary.</span></span><br><span class="line">	podSandboxID := podContainerChanges.SandboxID</span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">		<span class="keyword">var</span> msg <span class="type">string</span></span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Creating PodSandbox for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">		metrics.StartedPodsTotal.Inc()</span><br><span class="line">		createSandboxResult := kubecontainer.NewSyncResult(kubecontainer.CreatePodSandbox, format.Pod(pod))</span><br><span class="line">		result.AddSyncResult(createSandboxResult)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// ConvertPodSysctlsVariableToDotsSeparator converts sysctl variable</span></span><br><span class="line">		<span class="comment">// in the Pod.Spec.SecurityContext.Sysctls slice into a dot as a separator.</span></span><br><span class="line">		<span class="comment">// runc uses the dot as the separator to verify whether the sysctl variable</span></span><br><span class="line">		<span class="comment">// is correct in a separate namespace, so when using the slash as the sysctl</span></span><br><span class="line">		<span class="comment">// variable separator, runc returns an error: &quot;sysctl is not in a separate kernel namespace&quot;</span></span><br><span class="line">		<span class="comment">// and the podSandBox cannot be successfully created. Therefore, before calling runc,</span></span><br><span class="line">		<span class="comment">// we need to convert the sysctl variable, the dot is used as a separator to separate the kernel namespace.</span></span><br><span class="line">		<span class="comment">// When runc supports slash as sysctl separator, this function can no longer be used.</span></span><br><span class="line">		sysctl.ConvertPodSysctlsVariableToDotsSeparator(pod.Spec.SecurityContext)</span><br><span class="line"></span><br><span class="line">		podSandboxID, msg, err = m.createPodSandbox(pod, podContainerChanges.Attempt)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// createPodSandbox can return an error from CNI, CSI,</span></span><br><span class="line">			<span class="comment">// or CRI if the Pod has been deleted while the POD is</span></span><br><span class="line">			<span class="comment">// being created. If the pod has been deleted then it&#x27;s</span></span><br><span class="line">			<span class="comment">// not a real error.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// SyncPod can still be running when we get here, which</span></span><br><span class="line">			<span class="comment">// means the PodWorker has not acked the deletion.</span></span><br><span class="line">			<span class="keyword">if</span> m.podStateProvider.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line">				klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Pod was deleted and sandbox failed to be created&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			metrics.StartedPodsErrorsTotal.Inc()</span><br><span class="line">			createSandboxResult.Fail(kubecontainer.ErrCreatePodSandbox, msg)</span><br><span class="line">			klog.ErrorS(err, <span class="string">&quot;CreatePodSandbox for pod failed&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">			ref, referr := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line">			<span class="keyword">if</span> referr != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.ErrorS(referr, <span class="string">&quot;Couldn&#x27;t make a ref to pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">			&#125;</span><br><span class="line">			m.recorder.Eventf(ref, v1.EventTypeWarning, events.FailedCreatePodSandBox, <span class="string">&quot;Failed to create pod sandbox: %v&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Created PodSandbox for pod&quot;</span>, <span class="string">&quot;podSandboxID&quot;</span>, podSandboxID, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"></span><br><span class="line">		resp, err := m.runtimeService.PodSandboxStatus(podSandboxID, <span class="literal">false</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			ref, referr := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line">			<span class="keyword">if</span> referr != <span class="literal">nil</span> &#123;</span><br><span class="line">				klog.ErrorS(referr, <span class="string">&quot;Couldn&#x27;t make a ref to pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">			&#125;</span><br><span class="line">			m.recorder.Eventf(ref, v1.EventTypeWarning, events.FailedStatusPodSandBox, <span class="string">&quot;Unable to get pod sandbox status: %v&quot;</span>, err)</span><br><span class="line">			klog.ErrorS(err, <span class="string">&quot;Failed to get pod sandbox status; Skipping pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">			result.Fail(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> resp.GetStatus() == <span class="literal">nil</span> &#123;</span><br><span class="line">			result.Fail(errors.New(<span class="string">&quot;pod sandbox status is nil&quot;</span>))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If we ever allow updating a pod from non-host-network to</span></span><br><span class="line">		<span class="comment">// host-network, we may use a stale IP.</span></span><br><span class="line">		<span class="keyword">if</span> !kubecontainer.IsHostNetworkPod(pod) &#123;</span><br><span class="line">			<span class="comment">// Overwrite the podIPs passed in the pod status, since we just started the pod sandbox.</span></span><br><span class="line">			podIPs = m.determinePodSandboxIPs(pod.Namespace, pod.Name, resp.GetStatus())</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Determined the ip for pod after sandbox changed&quot;</span>, <span class="string">&quot;IPs&quot;</span>, podIPs, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// the start containers routines depend on pod ip(as in primary pod ip)</span></span><br><span class="line">	<span class="comment">// instead of trying to figure out if we have 0 &lt; len(podIPs)</span></span><br><span class="line">	<span class="comment">// everytime, we short circuit it here</span></span><br><span class="line">	podIP := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(podIPs) != <span class="number">0</span> &#123;</span><br><span class="line">		podIP = podIPs[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get podSandboxConfig for containers to start.</span></span><br><span class="line">	configPodSandboxResult := kubecontainer.NewSyncResult(kubecontainer.ConfigPodSandbox, podSandboxID)</span><br><span class="line">	result.AddSyncResult(configPodSandboxResult)</span><br><span class="line">	podSandboxConfig, err := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		message := fmt.Sprintf(<span class="string">&quot;GeneratePodSandboxConfig for pod %q failed: %v&quot;</span>, format.Pod(pod), err)</span><br><span class="line">		klog.ErrorS(err, <span class="string">&quot;GeneratePodSandboxConfig for pod failed&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">		configPodSandboxResult.Fail(kubecontainer.ErrConfigPodSandbox, message)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Helper containing boilerplate common to starting all types of containers.</span></span><br><span class="line">	<span class="comment">// typeName is a description used to describe this type of container in log messages,</span></span><br><span class="line">	<span class="comment">// currently: &quot;container&quot;, &quot;init container&quot; or &quot;ephemeral container&quot;</span></span><br><span class="line">	<span class="comment">// metricLabel is the label used to describe this type of container in monitoring metrics.</span></span><br><span class="line">	<span class="comment">// currently: &quot;container&quot;, &quot;init_container&quot; or &quot;ephemeral_container&quot;</span></span><br><span class="line">	start := <span class="function"><span class="keyword">func</span><span class="params">(typeName, metricLabel <span class="type">string</span>, spec *startSpec)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		startContainerResult := kubecontainer.NewSyncResult(kubecontainer.StartContainer, spec.container.Name)</span><br><span class="line">		result.AddSyncResult(startContainerResult)</span><br><span class="line"></span><br><span class="line">		isInBackOff, msg, err := m.doBackOff(pod, spec.container, podStatus, backOff)</span><br><span class="line">		<span class="keyword">if</span> isInBackOff &#123;</span><br><span class="line">			startContainerResult.Fail(err, msg)</span><br><span class="line">			klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Backing Off restarting container in pod&quot;</span>, <span class="string">&quot;containerType&quot;</span>, typeName, <span class="string">&quot;container&quot;</span>, spec.container, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		metrics.StartedContainersTotal.WithLabelValues(metricLabel).Inc()</span><br><span class="line">		<span class="keyword">if</span> sc.HasWindowsHostProcessRequest(pod, spec.container) &#123;</span><br><span class="line">			metrics.StartedHostProcessContainersTotal.WithLabelValues(metricLabel).Inc()</span><br><span class="line">		&#125;</span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Creating container in pod&quot;</span>, <span class="string">&quot;containerType&quot;</span>, typeName, <span class="string">&quot;container&quot;</span>, spec.container, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">		<span class="comment">// NOTE (aramase) podIPs are populated for single stack and dual stack clusters. Send only podIPs.</span></span><br><span class="line">		<span class="keyword">if</span> msg, err := m.startContainer(podSandboxID, podSandboxConfig, spec, pod, podStatus, pullSecrets, podIP, podIPs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// startContainer() returns well-defined error codes that have reasonable cardinality for metrics and are</span></span><br><span class="line">			<span class="comment">// useful to cluster administrators to distinguish &quot;server errors&quot; from &quot;user errors&quot;.</span></span><br><span class="line">			metrics.StartedContainersErrorsTotal.WithLabelValues(metricLabel, err.Error()).Inc()</span><br><span class="line">			<span class="keyword">if</span> sc.HasWindowsHostProcessRequest(pod, spec.container) &#123;</span><br><span class="line">				metrics.StartedHostProcessContainersErrorsTotal.WithLabelValues(metricLabel, err.Error()).Inc()</span><br><span class="line">			&#125;</span><br><span class="line">			startContainerResult.Fail(err, msg)</span><br><span class="line">			<span class="comment">// known errors that are logged in other places are logged at higher levels here to avoid</span></span><br><span class="line">			<span class="comment">// repetitive log spam</span></span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> err == images.ErrImagePullBackOff:</span><br><span class="line">				klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;Container start failed in pod&quot;</span>, <span class="string">&quot;containerType&quot;</span>, typeName, <span class="string">&quot;container&quot;</span>, spec.container, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;containerMessage&quot;</span>, msg, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;%v %+v start failed in pod %v: %v: %s&quot;</span>, typeName, spec.container, format.Pod(pod), err, msg))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 5: start ephemeral containers</span></span><br><span class="line">	<span class="comment">// These are started &quot;prior&quot; to init containers to allow running ephemeral containers even when there</span></span><br><span class="line">	<span class="comment">// are errors starting an init container. In practice init containers will start first since ephemeral</span></span><br><span class="line">	<span class="comment">// containers cannot be specified on pod creation.</span></span><br><span class="line">	<span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.EphemeralContainersToStart &#123;</span><br><span class="line">		start(<span class="string">&quot;ephemeral container&quot;</span>, metrics.EphemeralContainer, ephemeralContainerStartSpec(&amp;pod.Spec.EphemeralContainers[idx]))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 6: start the init container.</span></span><br><span class="line">	<span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Start the next init container.</span></span><br><span class="line">		<span class="keyword">if</span> err := start(<span class="string">&quot;init container&quot;</span>, metrics.InitContainer, containerStartSpec(container)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Successfully started the container; clear the entry in the failure</span></span><br><span class="line">		klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Completed init container for pod&quot;</span>, <span class="string">&quot;containerName&quot;</span>, container.Name, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 7: start containers in podContainerChanges.ContainersToStart.</span></span><br><span class="line">	<span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123;</span><br><span class="line">		start(<span class="string">&quot;container&quot;</span>, metrics.Container, containerStartSpec(&amp;pod.Spec.Containers[idx]))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://lizhewei91.github.io/2023/03/09/08/" title="kubelet 创建 pod 源码分析" target="_blank" rel="external">http://lizhewei91.github.io/2023/03/09/08/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/lizhewei91" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/lizhewei91" target="_blank"><span class="text-dark">李哲伟</span><small class="ml-1x">Cloud Native Developer</small></a></h3>
        <div>专注于云原生领域。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2023/03/10/19/" title="kubelet 资源配置"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2023/02/27/09/" title="如何构建多CPU架构容器镜像"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/lizhewei91" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>



    <script>
(function ($) {
    $('.search-form').on('submit', function (e) {
        var keyword = $('.search-form-input[name="wd"]').val();
        window.location = 'https://www.baidu.com/s?wd=site:lizhewei91.github.io ' + keyword;
        return false;
    });
})(jQuery);
</script>




   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>