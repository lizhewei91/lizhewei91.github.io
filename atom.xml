<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lizhewei&#39;Blog</title>
  <icon>https://www.gravatar.com/avatar/239ff887da8d6962c7547552e4f6946b</icon>
  
  <link href="http://lizhewei91.github.io/atom.xml" rel="self"/>
  
  <link href="http://lizhewei91.github.io/"/>
  <updated>2023-02-27T05:05:54.357Z</updated>
  <id>http://lizhewei91.github.io/</id>
  
  <author>
    <name>lizhewei</name>
    <email>tyutlizhewei@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何构建多CPU架构容器镜像</title>
    <link href="http://lizhewei91.github.io/2023/02/27/09/"/>
    <id>http://lizhewei91.github.io/2023/02/27/09/</id>
    <published>2023-02-27T04:47:09.000Z</published>
    <updated>2023-02-27T05:05:54.357Z</updated>
    
    <content type="html"><![CDATA[<p>构建多架构镜像的方法有两种：</p><ul><li>manifest</li><li>docker buildx</li></ul><h1 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h1><h2 id="manifest是什么，干什么用？"><a href="#manifest是什么，干什么用？" class="headerlink" title="manifest是什么，干什么用？"></a>manifest是什么，干什么用？</h2><p>manifest是一个文件，这个文件包含了有关于镜像信息，如层、大小和摘要。docker manifest命令还向用户提供附加信息，比如构建镜像的操作系统和体系结构。而manifest list是一个镜像清单列表，用于存放多个不同os/arch的镜像信息。我们可以创建一个manifest list来指向两个镜像(一个linux 64位和一个指向arm64位的镜像)，然后对用户提供一个唯一的镜像名称。<strong>从Docker registry v2.3和Docker 1.10 开始，Docker hub就可以pull multi architecture Docker镜像了。</strong></p><p><strong>一个镜像的manifest文件信息如下：</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker manifest inspect java</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">&quot;schemaVersion&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;config&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.container.image.v1+json&quot;</span>,</span><br><span class="line">                <span class="string">&quot;size&quot;</span>: <span class="number">4733</span>,</span><br><span class="line">                <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:d23bdf5b1b1b1afce5f1d0fd33e7ed8afbc084b594b9ccf742a5b27080d8a4a8&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;layers&quot;</span>: [ #---镜像层的摘要信息</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;size&quot;</span>: <span class="number">51361210</span>,</span><br><span class="line">                        <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:5040bd2983909aa8896b9932438c3f1479d25ae837a5f6220242a264d0221f2d&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">...................</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个manifest list的例子如下：</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;schemaVersion&quot;</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.list.v2+json&quot;</span>,</span><br><span class="line">   <span class="string">&quot;manifests&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: <span class="number">1357</span>,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:9b47044b1e79b965a8e1653e7f9c04b5f63e00b9161bedd5baef69bb8b4c4834&quot;</span>,</span><br><span class="line">         <span class="string">&quot;platform&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;architecture&quot;</span>: <span class="string">&quot;amd64&quot;</span>,</span><br><span class="line">            <span class="string">&quot;os&quot;</span>: <span class="string">&quot;linux&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: <span class="number">1357</span>,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:8aecae775e1f81d3889929ef15647187b414c833b0798d060bfd778bee668ced&quot;</span>,</span><br><span class="line">         <span class="string">&quot;platform&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;architecture&quot;</span>: <span class="string">&quot;arm64&quot;</span>,</span><br><span class="line">            <span class="string">&quot;os&quot;</span>: <span class="string">&quot;linux&quot;</span>,</span><br><span class="line">            <span class="string">&quot;variant&quot;</span>: <span class="string">&quot;v8&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：manifest的功能目前仅仅作用于docker 官方的镜像仓库。</strong></p><p>总结：简单的说manifest list就是多个manifest的一个集合，通过列表方式来管理。</p><h2 id="manifest-list处理流程："><a href="#manifest-list处理流程：" class="headerlink" title="manifest list处理流程："></a>manifest list处理流程：</h2><img src="/2023/02/27/09/1676966412440-973b407a-131f-48d2-a414-1d2e0efec236.png" class="" title="img"><img src="/2023/02/27/09/1676966412789-274aaf7c-7f07-43c8-9479-171a5fc0a048.png" class="" title="img"><h2 id="开启docker子命令manifest功能："><a href="#开启docker子命令manifest功能：" class="headerlink" title="开启docker子命令manifest功能："></a>开启docker子命令manifest功能：</h2><p>manifest是做为docker客户端的子命令存在，不过这个子命令目前处在实验性中一般没有开启。我们需要手动开始这个子命令的功能。开启过程如下：</p><h3 id="编辑config-json"><a href="#编辑config-json" class="headerlink" title="编辑config.json"></a>编辑config.json</h3><p>docker 的默认配置文件config.json是在$HOME目录下的.docker目录下。编辑config.json文件，若目录和文件不存在手动创建。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$vim ~/.docker/config.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;experimental&quot;</span>: <span class="string">&quot;enabled&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编辑daemon-json"><a href="#编辑daemon-json" class="headerlink" title="编辑daemon.json"></a>编辑daemon.json</h3><p>编辑daemon.json，若目录和文件不存在手动创建</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;experimental&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$systemctl daemon-reload</span><br><span class="line">$systemctl restart docker</span><br><span class="line">$docker manifest --help    #----查看manifest帮助信息</span><br></pre></td></tr></table></figure><p>开启docker的实验性功能后docker pull可以拉取指定平台镜像如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$docker pull --platform arm64  镜像 --platform：该参数是用于拉取指定平台的镜像，也是实验性功能，在上面步骤中开启后就会出现。通 过该参数可以手动指定需要的CPU平台镜像，而不用自动去识别。</span><br></pre></td></tr></table></figure><h2 id="使用manifest创建多CPU架构的镜像："><a href="#使用manifest创建多CPU架构的镜像：" class="headerlink" title="使用manifest创建多CPU架构的镜像："></a>使用manifest创建多CPU架构的镜像：</h2><p>查看一个镜像的manifest文件信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$docker manifest inspect nginx</span><br></pre></td></tr></table></figure><p>查看一个镜像的manifest文件的详细信息，包括cpu平台架构等信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$docker manifest inspect --verbose nginx</span><br></pre></td></tr></table></figure><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>这里准备好了两个不同CPU架构的镜像如下：<br>这里的镜像是自己在docker hub上创建的仓库<br>xxx/public_docker:nginx-arm64<br>xxx/public_docker:nginx-x86<br>必须将上面两个镜像推到docker hub上面</p><h3 id="创建一个manifest-list列表："><a href="#创建一个manifest-list列表：" class="headerlink" title="创建一个manifest list列表："></a>创建一个manifest list列表：</h3><p>创建一个自定义命名的镜像名的manifest list，然后用该列表关联仓库里面的两个不同架构的镜像</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ docker manifest create xxx/public_docker:nginx-v1 xxx/public_docker:nginx-arm64 xxx/public_docker:nginx-x86</span><br></pre></td></tr></table></figure><h3 id="将创建好的manifest-list-推到仓库中："><a href="#将创建好的manifest-list-推到仓库中：" class="headerlink" title="将创建好的manifest list 推到仓库中："></a>将创建好的manifest list 推到仓库中：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ docker manifest push xxx/public_docker:nginx-v1</span><br></pre></td></tr></table></figure><h3 id="查看仓库中创建好的manifest-list："><a href="#查看仓库中创建好的manifest-list：" class="headerlink" title="查看仓库中创建好的manifest list："></a>查看仓库中创建好的manifest list：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ docker manifest inspect xxx/public_docker:nginx-v1</span><br></pre></td></tr></table></figure><h1 id="buildx"><a href="#buildx" class="headerlink" title="buildx"></a>buildx</h1><p>首先 docker 版本要在 19.03 以上（含），启动 docker buildx，<code>export DOCKER_CLI_EXPERIMENTAL=enabled</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@build-cloud-product-clone-4 buildx-demo]# tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── buildx-demo</span><br><span class="line">├── Dockfile.buildx</span><br><span class="line">├── go.mod</span><br><span class="line">├── main.go</span><br><span class="line">└── Makefile</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-buildx-示例"><a href="#Dockerfile-buildx-示例" class="headerlink" title="Dockerfile.buildx 示例"></a>Dockerfile.buildx 示例</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> BASE_IMAGE</span><br><span class="line"><span class="keyword">ARG</span> BASE_IMAGE_VERSION</span><br><span class="line"><span class="keyword">FROM</span> --platform=$&#123;TARGETPLATFORM&#125; $&#123;BASE_IMAGE&#125;:$&#123;BASE_IMAGE_VERSION&#125; AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/buildx-demo</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> --platform=$&#123;TARGETPLATFORM&#125; alpine:<span class="number">3.17</span>.<span class="number">2</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /go/src/buildx-demo/bin/buildx-demo /usr/bin/buildx-demo</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/bin/buildx-demo&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="Makefile示例"><a href="#Makefile示例" class="headerlink" title="Makefile示例"></a>Makefile示例</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGET_PLATFORMS ?= linux/amd64,linux/arm64</span><br><span class="line">BASE_IMAGE ?= golang</span><br><span class="line">BASE_IMAGE_VERSION ?= alpine3.17</span><br><span class="line">IMAGE_REPO ?= hub.easystack.cn/multi/buildx-demo</span><br><span class="line">IMAGE_VERSION ?= v0.0.1</span><br><span class="line">DOCKER_HUB_REPO ?= hub.easystack.cn</span><br><span class="line">DOCKER_HUB_USERNAME ?= xxx</span><br><span class="line">DOCKER_HUB_PASSWORD ?= xxx</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="section">all: docker-hub-login build images</span></span><br><span class="line"></span><br><span class="line"><span class="section">docker-hub-login:</span></span><br><span class="line">        docker logout</span><br><span class="line">        docker login $&#123;DOCKER_HUB_REPO&#125; -u $&#123;DOCKER_HUB_USERNAME&#125; -p $&#123;DOCKER_HUB_PASSWORD&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">        go build -o /go/src/buildx-demo/bin/buildx-demo main.go</span><br><span class="line"></span><br><span class="line"><span class="section">images:</span></span><br><span class="line">        docker buildx build \</span><br><span class="line">                --build-arg BASE_IMAGE=<span class="variable">$(BASE_IMAGE)</span> \</span><br><span class="line">                --build-arg BASE_IMAGE_VERSION=<span class="variable">$(BASE_IMAGE_VERSION)</span> \</span><br><span class="line">                --platform <span class="variable">$(TARGET_PLATFORMS)</span> \</span><br><span class="line">                -t <span class="variable">$(IMAGE_REPO)</span>:<span class="variable">$(IMAGE_VERSION)</span> \</span><br><span class="line">                -f ./Dockfile.buildx --push .</span><br></pre></td></tr></table></figure><h2 id="验证镜像"><a href="#验证镜像" class="headerlink" title="验证镜像"></a>验证镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 拉去镜像到本地</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull hub.easystack.cn/multi/buildx-demo:v0.0.1</span></span><br><span class="line"></span><br><span class="line">// 查看镜像信息</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker manifest inspect hub.easystack.cn/multi/buildx-demo:v0.0.1</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   &quot;schemaVersion&quot;: 2,</span><br><span class="line">   &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.list.v2+json&quot;,</span><br><span class="line">   &quot;manifests&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,</span><br><span class="line">         &quot;size&quot;: 701,</span><br><span class="line">         &quot;digest&quot;: &quot;sha256:7d95c40e65abaa83c9d1a2e462026070f43f7ceaacba57f3c6a70fb840bcd196&quot;,</span><br><span class="line">         &quot;platform&quot;: &#123;</span><br><span class="line">            &quot;architecture&quot;: &quot;amd64&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;linux&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,</span><br><span class="line">         &quot;size&quot;: 701,</span><br><span class="line">         &quot;digest&quot;: &quot;sha256:ff6b7d6df4241220f9c1f665864e7f009620a8c39edecf3b8463a62d01c6f228&quot;,</span><br><span class="line">         &quot;platform&quot;: &#123;</span><br><span class="line">            &quot;architecture&quot;: &quot;arm64&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;linux&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;构建多架构镜像的方法有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;manifest&lt;/li&gt;
&lt;li&gt;docker buildx&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;manifest&quot;&gt;&lt;a href=&quot;#manifest&quot; class=&quot;headerlink&quot; title=&quot;ma</summary>
      
    
    
    
    <category term="buildx" scheme="http://lizhewei91.github.io/categories/buildx/"/>
    
    
    <category term="buildx" scheme="http://lizhewei91.github.io/tags/buildx/"/>
    
    <category term="manifest" scheme="http://lizhewei91.github.io/tags/manifest/"/>
    
  </entry>
  
  <entry>
    <title>理解 CNI 和 CNI 插件</title>
    <link href="http://lizhewei91.github.io/2023/02/15/10/"/>
    <id>http://lizhewei91.github.io/2023/02/15/10/</id>
    <published>2023-02-15T09:51:10.000Z</published>
    <updated>2023-02-17T02:36:22.460Z</updated>
    
    
    
    
    <category term="cni" scheme="http://lizhewei91.github.io/categories/cni/"/>
    
    
    <category term="cni" scheme="http://lizhewei91.github.io/tags/cni/"/>
    
  </entry>
  
  <entry>
    <title>在k8s中，实现应用配置文件热更新</title>
    <link href="http://lizhewei91.github.io/2023/02/10/44/"/>
    <id>http://lizhewei91.github.io/2023/02/10/44/</id>
    <published>2023-02-10T08:32:44.000Z</published>
    <updated>2023-02-10T10:03:47.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前，在k8s部署的工作负载使用 <code>ConfigMap</code> 或 <code>Secret</code>时，通过两种方式：</p><ul><li>环境变量 Env 方式挂载</li><li>文件方式挂载</li></ul><p>当更新 <code>ConfigMap </code>或 <code>Secret</code> 时，挂载到Pod中的数据存在两种情况：</p><ul><li>Env 方式挂载的环境变量不会同步更新</li><li>文件方式挂载的数据会同步更新（存在秒级延时）</li></ul><p>大部分场景下，在更新了 <code>ConfigMap</code> 或 <code>Secret</code> 中的信息后，都希望Pod内业务能读取到最新的值。通常都会手动去滚动更新一下Pod，重新读取环境变量或文件内容。当前社区已经有对应的开源工具 <a href="https://github.com/stakater/Reloader">Reloader</a> 实现了 <code>ConfigMap</code>/<code>Secret</code> 更新时自动触发Pod的滚动更新。</p><h1 id="Reloader介绍"><a href="#Reloader介绍" class="headerlink" title="Reloader介绍"></a>Reloader介绍</h1><p>Reloader 通过 watch <code>ConfigMap</code> 和 <code>Secret</code> 中的变化，对 <code>Deployment</code>、 <code>DaemonSet</code> 和 <code>StatefulSet</code> 等负载的 <code>Pod</code> 进行滚动升级。</p><p>官方文档：<a href="https://github.com/stakater/Reloader">Reloader</a></p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>Reloader 兼容的 K8s 版本为 &gt;=1.9。</p><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><p>以下使用Deployment举例：</p><ul><li>Deployment 中使用的所有 ConfigMap 和 Secret 变动都会触发 Pod 滚动更新</li></ul><p>在Deployment 的 <code>metadata.annotations</code> 中添加 <code>reloader.stakater.com/auto: &quot;true&quot;</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    reloader.stakater.com/<span class="keyword">auto</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="keyword">template</span>:</span><br></pre></td></tr></table></figure><ul><li>Deployment 中的部分 ConfigMap 和 Secret 变动会触发 Pod 滚动更新</li></ul><p>在 Deployment 的 <code>metadata.annotations</code>中添加<code>reloader.stakater.com/search: &quot;true&quot;</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    reloader.stakater.com/search: <span class="string">&quot;true&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="keyword">template</span>:</span><br></pre></td></tr></table></figure><p>同时在需要触发 Pod 更新的 ConfigMap 或 Secret 中的 <code>metadata.annotations</code>中添加 <code>reloader.stakater.com/match: &quot;true&quot;</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    reloader.stakater.com/match: <span class="string">&quot;true&quot;</span></span><br><span class="line">data:</span><br><span class="line">  key: <span class="keyword">value</span></span><br></pre></td></tr></table></figure><ul><li>Deployment 中指定 ConfigMap 或 Secret 的变动触发 Pod 滚动更新</li></ul><p>在Deployment 的 <code>metadata.annotations</code>中添加 <code>configmap.reloader.stakater.com/reload: &quot;foo-configmap,bar-configmap,baz-configmap&quot;</code>，指定这些 ConfigMap 才会触发 Pod 的更新。多个 ConfigMap 使用逗号分隔</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    configmap.reloader.stakater.com/reload: <span class="string">&quot;foo-configmap,bar-configmap,baz-configmap&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="keyword">template</span>: </span><br><span class="line">    metadata:</span><br></pre></td></tr></table></figure><p>在Deployment 的 <code>metadata.annotations</code> 中添加 <code>secret.reloader.stakater.com/reload: &quot;foo-secret,bar-secret,baz-secret&quot;</code>，指定这些 Secret 才会触发 Pod 的更新。多个 Secret 使用逗号分隔</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    secret.reloader.stakater.com/reload: <span class="string">&quot;foo-secret,bar-secret,baz-secret&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="keyword">template</span>: </span><br><span class="line">    metadata:</span><br></pre></td></tr></table></figure><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><ul><li>忽略 ConfigMap 或 Secret 变动（<strong>全局</strong>）</li></ul><p>在 Reloader deployment的 <code>spec.template.spec.container.args</code> 中添加参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>–resources-to-ignore=configMaps</td><td>忽略 configMaps 变动</td></tr><tr><td>–resources-to-ignore=secrets</td><td>忽略 secrets 变动</td></tr></tbody></table><p><code>--resources-to-ignore</code>参数只支持忽略一种资源，若要同时忽略 configMaps 和 secrets 的变动，则只需要把 Reloader 副本数降为0。</p><ul><li>通过使用 <code>--namespace-selector</code> 参数，Reloader可以配置为只监视带有(一个或多个)标签的命名空间，例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--namespace-selector=reloder:enabled,test:true</span><br></pre></td></tr></table></figure><p>只有标记为如下命名空间 YAML 的命名空间才会被监视：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kind: Namespace</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  ...</span><br><span class="line">  labels:</span><br><span class="line">    reloder: enabled</span><br><span class="line">    test: true</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>如果您只想通过标签的键选择命名空间，请使用 <code>&quot;*&quot;</code> 作为值。例如，对于 <code>--namespace-selector=select-this:*</code> 所有标签键为<code>&quot;select-this&quot;</code>的命名空间将被选中，而不管标签的值是多少。</p><h1 id="实战验证"><a href="#实战验证" class="headerlink" title="实战验证"></a>实战验证</h1><h2 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h2><ol><li>创建一个测试 namespace</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create ns ns1</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 reloader</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/stakater/Reloader/master/deployments/kubernetes/reloader.yaml</span><br></pre></td></tr></table></figure><ol start="3"><li>创建configmap</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-config-file</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ns1</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line"><span class="comment">#    reloader.stakater.com/match: &quot;true&quot;</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">info.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    user=lzw</span></span><br><span class="line"><span class="string">    age=30</span></span><br><span class="line"><span class="string"></span><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-config-env</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ns1</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line"><span class="comment">#    reloader.stakater.com/match: &quot;true&quot;</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">COUNTRY:</span> <span class="string">china</span></span><br><span class="line">  <span class="attr">CITY:</span> <span class="string">beijing</span></span><br></pre></td></tr></table></figure><ol start="4"><li>创建 deployment</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ns1</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line"><span class="comment">#    configmap.reloader.stakater.com/reload: &quot;test-config-file&quot;</span></span><br><span class="line"><span class="comment">#    reloader.stakater.com/search: &quot;true&quot;</span></span><br><span class="line">     <span class="attr">reloader.stakater.com/auto:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="comment"># Define the environment variable</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">COUNTRY</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">test-config-env</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">COUNTRY</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CITY</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">test-config-env</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">CITY</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">&quot;/etc/foo&quot;</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">test-config-file</span></span><br></pre></td></tr></table></figure><h2 id="Reloader功能验证"><a href="#Reloader功能验证" class="headerlink" title="Reloader功能验证"></a>Reloader功能验证</h2><ol><li>更新 configmap（以文件方式挂载）</li></ol><p>使用命令 <code>kubectl -nns1 edit cm test-config-file</code> 编辑configmap，设置 <code>user</code> 的值为 <code>ted</code>。查看pod已经滚动更新。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ kubectl edit cm -n ns1 test-config-file</span><br><span class="line">configmap/test-config-file edited</span><br><span class="line">➜ kubectl get pods -n ns1</span><br><span class="line">NAME                     READY   STATUS              RESTARTS   AGE</span><br><span class="line">nginx-5dff48f5dd-m528h   0/1     ContainerCreating   0          6s</span><br><span class="line">nginx-6f455f8cd5-9h7pp   1/1     Running             0          34m</span><br></pre></td></tr></table></figure><p>查看新启动 pod 中 configmap 所挂载的文件内容，发现 <code>user</code> 的值已经变为 <code>lzw-test</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ kubectl <span class="built_in">exec</span> -it nginx-5dff48f5dd-m528h  -nns1 -- <span class="built_in">cat</span> /etc/foo/info.yaml</span><br><span class="line">user=lzw-test</span><br><span class="line">age=30</span><br></pre></td></tr></table></figure><ol start="2"><li>更新 configmap（以环境变量方式注入）</li></ol><p>使用命令 <code>kubectl -nns1edit cm test-config-env</code> 编辑 configmap，设置 <code>CITY</code> 的值为 <code>shenzhen</code>。查看 pod 已经滚动更新。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ kubectl edit cm -n ns1 test-config-env</span><br><span class="line">configmap/test-config-env edited</span><br><span class="line">➜ kubectl get pods -n ns1</span><br><span class="line">NAME                     READY   STATUS              RESTARTS   AGE</span><br><span class="line">nginx-5b4cb86669-9cv6k   0/1     ContainerCreating   0          6s</span><br><span class="line">nginx-5dff48f5dd-m528h   1/1     Running             0          9m35s</span><br></pre></td></tr></table></figure><p>查看新启动 pod 中 configmap 所注入的环境变量，发现 <code>CITY</code> 的值已经变为 <code>shenzhen</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ kubectl <span class="built_in">exec</span> -it nginx-5b4cb86669-9cv6k -nns1 -- <span class="built_in">env</span>|grep CITY</span><br><span class="line">CITY=shenzhen</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>Reloader 自动触发滚动更新，可能会导致业务中断。使用该功能时需要评估 pod 滚动更新对业务带来的影响。</p></li><li><p><code>reloader.stakater.com/auto</code>的优先级高于 <code>reloader.stakater.com/search</code>。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;目前，在k8s部署的工作负载使用 &lt;code&gt;ConfigMap&lt;/code&gt; 或 &lt;code&gt;Secret&lt;/code&gt;时，通过两种方式：</summary>
      
    
    
    
    <category term="reloader" scheme="http://lizhewei91.github.io/categories/reloader/"/>
    
    
    <category term="reloader" scheme="http://lizhewei91.github.io/tags/reloader/"/>
    
    <category term="configMap" scheme="http://lizhewei91.github.io/tags/configMap/"/>
    
    <category term="secret" scheme="http://lizhewei91.github.io/tags/secret/"/>
    
  </entry>
  
  <entry>
    <title>用插件扩展 kubectl</title>
    <link href="http://lizhewei91.github.io/2023/02/10/25/"/>
    <id>http://lizhewei91.github.io/2023/02/10/25/</id>
    <published>2023-02-10T06:48:25.000Z</published>
    <updated>2023-02-10T07:13:34.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="krew"><a href="#krew" class="headerlink" title="krew"></a>krew</h1><h2 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h2><ol><li>你需要安装一个可用的 <code>kubectl</code> 可执行文件。</li></ol><h2 id="安装-krew"><a href="#安装-krew" class="headerlink" title="安装 krew"></a>安装 krew</h2><p>官方文档：<a href="https://krew.sigs.k8s.io/docs/user-guide/">https://krew.sigs.k8s.io/docs/user-guide/</a></p><p>安装 krew 插件管理器。Krew 是一个由 Kubernetes SIG CLI 社区维护的插件管理器。</p><ol><li><p>Make sure that <code>git</code> is installed.</p></li><li><p>Run this command to download and install <code>krew</code>:</p></li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(</span><br><span class="line">  <span class="built_in">set</span> -x; <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(mktemp -d)</span>&quot;</span> &amp;&amp;</span><br><span class="line">  OS=<span class="string">&quot;<span class="subst">$(uname | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)</span>&quot;</span> &amp;&amp;</span><br><span class="line">  ARCH=<span class="string">&quot;<span class="subst">$(uname -m | sed -e &#x27;s/x86_64/amd64/&#x27; -e &#x27;s/\(arm\)\(64\)\?.*/\1\2/&#x27; -e &#x27;s/aarch64$/arm64/&#x27;)</span>&quot;</span> &amp;&amp;</span><br><span class="line">  KREW=<span class="string">&quot;krew-<span class="variable">$&#123;OS&#125;</span>_<span class="variable">$&#123;ARCH&#125;</span>&quot;</span> &amp;&amp;</span><br><span class="line">  curl -fsSLO <span class="string">&quot;https://github.com/kubernetes-sigs/krew/releases/latest/download/<span class="variable">$&#123;KREW&#125;</span>.tar.gz&quot;</span> &amp;&amp;</span><br><span class="line">  tar zxvf <span class="string">&quot;<span class="variable">$&#123;KREW&#125;</span>.tar.gz&quot;</span> &amp;&amp;</span><br><span class="line">  ./<span class="string">&quot;<span class="variable">$&#123;KREW&#125;</span>&quot;</span> install krew</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="3"><li>Add the <code>$HOME/.krew/bin</code> directory to your PATH environment variable. To do this, update your <code>.bashrc</code> or <code>.zshrc</code> file and append the following line:</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$&#123;KREW_ROOT:-<span class="variable">$HOME</span>/.krew&#125;</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure><p>and restart your shell.</p><ol start="4"><li>Run <code>kubectl krew</code> to check the installation.</li></ol><h2 id="编写-kubectl-插件"><a href="#编写-kubectl-插件" class="headerlink" title="编写 kubectl 插件"></a>编写 kubectl 插件</h2><p>你可以用任何编程语言或脚本编写插件，允许你编写命令行命令。</p><p>不需要安装插件或预加载，插件可执行程序从 <code>kubectl</code> 二进制文件接收继承的环境， 插件根据其名称确定它希望实现的命令路径。 例如，名为 <code>kubectl-foo</code> 的插件提供了命令 <code>kubectl foo</code>。 必须将插件的可执行文件安装在 <code>PATH</code> 中的某个位置。</p><h3 id="示例插件"><a href="#示例插件" class="headerlink" title="示例插件"></a>示例插件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的参数处理</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;version&quot;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的参数处理</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;config&quot;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$KUBECONFIG</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I am a plugin named kubectl-foo&quot;</span></span><br></pre></td></tr></table></figure><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>要使用某插件，先要使其可执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">chmod</span> +x ./kubectl-foo</span><br></pre></td></tr></table></figure><p>并将它放在你的 <code>PATH</code> 中的任何地方：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">mv</span> ./kubectl-foo /usr/local/bin</span><br></pre></td></tr></table></figure><p>你现在可以调用你的插件作为 <code>kubectl</code> 命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl foo</span><br><span class="line"></span><br><span class="line">I am a plugin named kubectl-foo</span><br></pre></td></tr></table></figure><p>所有参数和标记按原样传递给可执行文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl foo version</span><br><span class="line"></span><br><span class="line">1.0.0</span><br></pre></td></tr></table></figure><p>所有环境变量也按原样传递给可执行文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ KUBECONFIG=/etc/kube/config kubectl foo config</span><br><span class="line"></span><br><span class="line">/etc/kube/config</span><br></pre></td></tr></table></figure><p>此外，传递给插件的第一个参数总是调用它的位置的绝对路径（在上面的例子中，<code>$0</code> 将等于 <code>/usr/local/bin/kubectl-foo</code>）。</p><h3 id="查看插件列表"><a href="#查看插件列表" class="headerlink" title="查看插件列表"></a>查看插件列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl plugin list</span><br><span class="line"></span><br><span class="line">The following compatible plugins are available:</span><br><span class="line"></span><br><span class="line">/root/.krew/bin/kubectl-krew</span><br><span class="line">/usr/local/bin/kubectl-foo           // kubectl-foo 为新添加的插件</span><br></pre></td></tr></table></figure><h2 id="分发-kubectl-插件"><a href="#分发-kubectl-插件" class="headerlink" title="分发 kubectl 插件"></a>分发 kubectl 插件</h2><p>参考：<a href="https://kubernetes.io/zh-cn/docs/tasks/extend-kubectl/kubectl-plugins/#%E5%88%86%E5%8F%91-kubectl-%E6%8F%92%E4%BB%B6">分发kubectl插件</a></p><h2 id="krew-相关命令"><a href="#krew-相关命令" class="headerlink" title="krew 相关命令"></a>krew 相关命令</h2><ol><li>升级</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl krew update</span><br></pre></td></tr></table></figure><ol start="2"><li>查看可用插件列表</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl krew search</span><br><span class="line"></span><br><span class="line">NAME             DESCRIPTION                                         INSTALLED</span><br><span class="line">access-matrix    Show an RBAC access matrix <span class="keyword">for</span> server resources     no</span><br><span class="line">advise-psp       Suggests PodSecurityPolicies <span class="keyword">for</span> cluster.           no</span><br><span class="line">auth-proxy       Authentication proxy to a pod or service            no</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="3"><li>关键字搜索</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl krew search pod</span><br><span class="line"></span><br><span class="line">NAME                DESCRIPTION                                         INSTALLED</span><br><span class="line">evict-pod           Evicts the given pod                                no</span><br><span class="line">pod-dive            Shows a pod<span class="string">&#x27;s workload tree and info inside a node  no</span></span><br><span class="line"><span class="string">pod-logs            Display a list of pods to get logs from             no</span></span><br><span class="line"><span class="string">pod-shell           Display a list of pods to execute a shell in        no</span></span><br></pre></td></tr></table></figure><ol start="4"><li>查看插件详情</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl krew info tree</span><br><span class="line"></span><br><span class="line">NAME: tree</span><br><span class="line">VERSION: v0.4.0</span><br><span class="line">DESCRIPTION:</span><br><span class="line">  This plugin shows sub-resources of a specified Kubernetes API object <span class="keyword">in</span> a</span><br><span class="line">  tree view <span class="keyword">in</span> the command-line. The parent-child relationship is discovered</span><br><span class="line">  using ownerReferences on the child object.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;krew&quot;&gt;&lt;a href=&quot;#krew&quot; class=&quot;headerlink&quot; title=&quot;krew&quot;&gt;&lt;/a&gt;krew&lt;/h1&gt;&lt;h2 id=&quot;准备开始&quot;&gt;&lt;a href=&quot;#准备开始&quot; class=&quot;headerlink&quot; title=&quot;准备开始&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="krew" scheme="http://lizhewei91.github.io/categories/krew/"/>
    
    
    <category term="kubectl-plugins" scheme="http://lizhewei91.github.io/tags/kubectl-plugins/"/>
    
    <category term="krew" scheme="http://lizhewei91.github.io/tags/krew/"/>
    
  </entry>
  
  <entry>
    <title>kubelet-device-manager 源码分析</title>
    <link href="http://lizhewei91.github.io/2023/01/16/19/"/>
    <id>http://lizhewei91.github.io/2023/01/16/19/</id>
    <published>2023-01-16T06:24:19.000Z</published>
    <updated>2023-01-16T09:57:48.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建-DeviceManager"><a href="#创建-DeviceManager" class="headerlink" title="创建 DeviceManager"></a>创建 DeviceManager</h1><p>Device Manager 和 cgroup Manager、QoS Container Manager 等一样，都属于 kubelet 管理的众多 Manager 之一。Device Manager在 kubelet 启动时的 NewContainerManager 中创建。</p><p><u><em>kubernetes/pkg/kubelet/cm/container_manager_linux.go#198</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContainerManager</span><span class="params">(mountUtil mount.Interface, cadvisorInterface cadvisor.Interface, nodeConfig NodeConfig, failSwapOn <span class="type">bool</span>, devicePluginEnabled <span class="type">bool</span>, recorder record.EventRecorder)</span></span> (ContainerManager, <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">cm := &amp;containerManagerImpl&#123;</span><br><span class="line">cadvisorInterface:   cadvisorInterface,</span><br><span class="line">mountUtil:           mountUtil,</span><br><span class="line">NodeConfig:          nodeConfig,</span><br><span class="line">subsystems:          subsystems,</span><br><span class="line">cgroupManager:       cgroupManager,</span><br><span class="line">capacity:            capacity,</span><br><span class="line">internalCapacity:    internalCapacity,</span><br><span class="line">cgroupRoot:          cgroupRoot,</span><br><span class="line">recorder:            recorder,</span><br><span class="line">qosContainerManager: qosContainerManager,</span><br><span class="line">&#125;</span><br><span class="line">... </span><br><span class="line">klog.InfoS(<span class="string">&quot;Creating device plugin manager&quot;</span>, <span class="string">&quot;devicePluginEnabled&quot;</span>, devicePluginEnabled)</span><br><span class="line"><span class="keyword">if</span> devicePluginEnabled &#123;</span><br><span class="line">cm.deviceManager, err = devicemanager.NewManagerImpl(machineInfo.Topology, cm.topologyManager)</span><br><span class="line">cm.topologyManager.AddHintProvider(cm.deviceManager)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cm.deviceManager, err = devicemanager.NewManagerStub()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">return</span> cm, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ManagerImpl结构体"><a href="#ManagerImpl结构体" class="headerlink" title="ManagerImpl结构体"></a>ManagerImpl结构体</h2><p>我们有必要先了解 Device Manager 的结构体：</p><p><u><em>kubernetes/pkg/kubelet/cm/devicemanager/manager.go#57</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ManagerImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">checkpointdir <span class="type">string</span></span><br><span class="line"></span><br><span class="line">endpoints <span class="keyword">map</span>[<span class="type">string</span>]endpointInfo <span class="comment">// Key is ResourceName</span></span><br><span class="line">mutex     sync.Mutex</span><br><span class="line"></span><br><span class="line">server plugin.Server</span><br><span class="line"></span><br><span class="line"><span class="comment">// activePods is a method for listing active pods on the node</span></span><br><span class="line"><span class="comment">// so the amount of pluginResources requested by existing pods</span></span><br><span class="line"><span class="comment">// could be counted when updating allocated devices</span></span><br><span class="line">activePods ActivePodsFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// sourcesReady provides the readiness of kubelet configuration sources such as apiserver update readiness.</span></span><br><span class="line"><span class="comment">// We use it to determine when we can purge inactive pods from checkpointed state.</span></span><br><span class="line">sourcesReady config.SourcesReady</span><br><span class="line"></span><br><span class="line"><span class="comment">// allDevices holds all the devices currently registered to the device manager</span></span><br><span class="line">allDevices ResourceDeviceInstances</span><br><span class="line"></span><br><span class="line"><span class="comment">// healthyDevices contains all of the registered healthy resourceNames and their exported device IDs.</span></span><br><span class="line">healthyDevices <span class="keyword">map</span>[<span class="type">string</span>]sets.String</span><br><span class="line"></span><br><span class="line"><span class="comment">// unhealthyDevices contains all of the unhealthy devices and their exported device IDs.</span></span><br><span class="line">unhealthyDevices <span class="keyword">map</span>[<span class="type">string</span>]sets.String</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocatedDevices contains allocated deviceIds, keyed by resourceName.</span></span><br><span class="line">allocatedDevices <span class="keyword">map</span>[<span class="type">string</span>]sets.String</span><br><span class="line"></span><br><span class="line"><span class="comment">// podDevices contains pod to allocated device mapping.</span></span><br><span class="line">podDevices        *podDevices</span><br><span class="line">checkpointManager checkpointmanager.CheckpointManager</span><br><span class="line"></span><br><span class="line"><span class="comment">// List of NUMA Nodes available on the underlying machine</span></span><br><span class="line">numaNodes []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Store of Topology Affinties that the Device Manager can query.</span></span><br><span class="line">topologyAffinityStore topologymanager.Store</span><br><span class="line"></span><br><span class="line"><span class="comment">// devicesToReuse contains devices that can be reused as they have been allocated to</span></span><br><span class="line"><span class="comment">// init containers.</span></span><br><span class="line">devicesToReuse PodReusableDevices</span><br><span class="line"></span><br><span class="line"><span class="comment">// pendingAdmissionPod contain the pod during the admission phase</span></span><br><span class="line">pendingAdmissionPod *v1.Pod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是核心字段 的说明：</p><ul><li><p><strong>checkpointdir：</strong>kubelet对外暴露的socket文件，/var/lib/kubelet/device-plugins/kubelet.sock</p></li><li><p><strong>endpoints：</strong>map对象，key 为 Resource Name，value 为 endpoint 接口( 包括 getPreferredAllocation、allocate、preStartContainer、setStopTime、isStopped、stopGracePeriodExpired )，每个 endpoint 接口对应一个已注册的 device plugin，负责与 device plugin 的 gRPC 通信及缓存 device plugin 反馈的 device states。</p></li><li><p><strong>server：</strong>暴漏一个 gRPC 服务。</p></li><li><p><strong>activePods：</strong>用来获取该节点上所有 active pods，即 non-Terminated 状态的 Pods。在 kubelet 的initializeRuntimeDependentModules 时会注册 activePods Func 为如下函数</p></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> GetActivePods() []*v1.Pod &#123;</span><br><span class="line">allPods := kl.podManager.GetPods()</span><br><span class="line">activePods := kl.filterOutInactivePods(allPods)</span><br><span class="line"><span class="keyword">return</span> activePods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>allDevices：</strong>保存当前注册到设备管理器的所有设备</p></li><li><p> <strong>healthyDevices:</strong> map对象，key为 Resource Name，value为对应的健康的 device IDs。 </p></li><li><p> **unhealthyDevices: **map对象，key为 Resource Name，value为对应的不健康的 device IDs。</p></li><li><p><strong>allocatedDevices:</strong>  map对象，key为Resource Name，value为已经分配出去的device IDs。</p></li><li><p><strong>podDevices：</strong>记录每一个pod中每个容器的设备分配情况</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建-DeviceManager&quot;&gt;&lt;a href=&quot;#创建-DeviceManager&quot; class=&quot;headerlink&quot; title=&quot;创建 DeviceManager&quot;&gt;&lt;/a&gt;创建 DeviceManager&lt;/h1&gt;&lt;p&gt;Device Manager</summary>
      
    
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/categories/kubelet/"/>
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/tags/kubelet/"/>
    
    <category term="device-manager" scheme="http://lizhewei91.github.io/tags/device-manager/"/>
    
  </entry>
  
  <entry>
    <title>kubelet源码分析</title>
    <link href="http://lizhewei91.github.io/2023/01/11/14/"/>
    <id>http://lizhewei91.github.io/2023/01/11/14/</id>
    <published>2023-01-11T11:32:14.000Z</published>
    <updated>2023-02-15T07:45:28.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kubelet-主要功能"><a href="#kubelet-主要功能" class="headerlink" title="kubelet 主要功能"></a>kubelet 主要功能</h1><p>在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。</p><h2 id="pod管理"><a href="#pod管理" class="headerlink" title="pod管理"></a>pod管理</h2><p>Kubelet 以 PodSpec 的方式工作。PodSpec 是描述一个 Pod 的 YAML 或 JSON 对象。 kubelet 采用一组通过各种机制提供的 PodSpecs（主要通过 apiserver），并确保这些 PodSpecs 中描述的 Pod 正常健康运行。</p><p>官方提供了3种方式来获取容器信息：</p><ul><li>apiserver：通过 API Server 监听 etcd 目录获取数据；</li><li>File：启动参数 –config 指定的配置目录下的文件；</li><li>通过 url 从网络上某个地址来获取信息</li></ul><p>拿apiserver来说，如果Kubelet 监听到etcd中有新的绑定到本节点的 Pod，则按照 Pod 清单的要求创建该 Pod；如果发现本地的 Pod 被修改，则 Kubelet 会做出相应的修改。</p><h2 id="容器健康检查"><a href="#容器健康检查" class="headerlink" title="容器健康检查"></a>容器健康检查</h2><p>容器健康检查这个我们在前面已经聊过，主要是通过LivenessProbe 与ReadinessProbe来判断容器是否健康。</p><ul><li>LivenessProbe ：用于判断容器是否健康，告诉 Kubelet 一个容器什么时候处于不健康的状态。如果 LivenessProbe 探针探测到容器不健康，则 Kubelet 将删除该容器，并根据容器的重启策略做相应的处理。如果一个容器不包含 LivenessProbe 探针，那么 Kubelet 认为该容器的 LivenessProbe 探针返回的值永远是 “Success”；</li><li>ReadinessProbe：用于判断容器是否启动完成且准备接收请求。如果 ReadinessProbe 探针探测到失败，则 Pod 的状态将被修改。Endpoint Controller 将从 Service 的 Endpoint 中删除包含该容器所在 Pod 的 IP 地址的 Endpoint 条目。</li></ul><h2 id="容器监控"><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h2><p>Kubelet 通过 cAdvisor 获取其所在节点及容器的数据。cAdvisor 是一个开源的分析容器资源使用率和性能特性的代理工具，集成到 Kubelet中，当Kubelet启动时会同时启动cAdvisor，且一个cAdvisor只监控一个Node节点的信息。cAdvisor 自动查找所有在其所在节点上的容器，自动采集 CPU、内存、文件系统和网络使用的统计信息。cAdvisor 通过它所在节点机的 Root 容器，采集并分析该节点机的全面使用情况。</p><h1 id="kubelet-工作原理"><a href="#kubelet-工作原理" class="headerlink" title="kubelet 工作原理"></a>kubelet 工作原理</h1><p>其实，kubelet也是按照“控制器”的模式来工作的，它的实际工作原理，可以用如下的一张图表示：</p><img src="/2023/01/11/14/1620.png" class="" title="img"><p>可以看到，kubelet的工作核心，就是一个控制循环，即: SyncLoop ( 图中的大圆圈 )。而驱动这个控制循环的事件，包括四种：</p><ol><li>Pod 更新事件</li><li>Pod 生命周期变化</li><li>kubelet 本身设置的执行周期</li><li>定时的清理事件</li></ol><h1 id="kubelet源码分析"><a href="#kubelet源码分析" class="headerlink" title="kubelet源码分析"></a>kubelet源码分析</h1><p>该文章代码基于: <strong>kubernetes:v1.25.4</strong></p><p><u><em>kubernetes/cmd/kubelet/kubelet.go</em></u>#34</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">command := app.NewKubeletCommand()</span><br><span class="line">code := cli.Run(command)</span><br><span class="line">os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kubelet的函数入口在/cmd/kubelet/kubelet.go</p><p><u><em>kubernetes/cmd/kubelet/app/server/go</em></u>#123</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewKubeletCommand creates a *cobra.Command object with default parameters</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKubeletCommand</span><span class="params">()</span></span> *cobra.Command &#123;</span><br><span class="line">cleanFlagSet := pflag.NewFlagSet(componentKubelet, pflag.ContinueOnError)</span><br><span class="line">cleanFlagSet.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)</span><br><span class="line">kubeletFlags := options.NewKubeletFlags()</span><br><span class="line"></span><br><span class="line">kubeletConfig, err := options.NewKubeletConfiguration()</span><br><span class="line"><span class="comment">// programmer error</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Failed to create a new kubelet configuration&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">Use: componentKubelet,</span><br><span class="line">  ...</span><br><span class="line">RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// validate the initial KubeletFlags</span></span><br><span class="line"><span class="keyword">if</span> err := options.ValidateKubeletFlags(kubeletFlags); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to validate kubelet flags: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cleanFlagSet.Changed(<span class="string">&quot;pod-infra-container-image&quot;</span>) &#123;</span><br><span class="line">klog.InfoS(<span class="string">&quot;--pod-infra-container-image will not be pruned by the image garbage collector in kubelet and should also be set in the remote runtime&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若 configFile 不为空，则加载 configFile 文件</span></span><br><span class="line"><span class="keyword">if</span> configFile := kubeletFlags.KubeletConfigFile; <span class="built_in">len</span>(configFile) &gt; <span class="number">0</span> &#123;</span><br><span class="line">kubeletConfig, err = loadConfigFile(configFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to load kubelet config file, error: %w, path: %s&quot;</span>, err, configFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := kubeletConfigFlagPrecedence(kubeletConfig, args); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to precedence kubeletConfigFlag: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := utilfeature.DefaultMutableFeatureGate.SetFromMap(kubeletConfig.FeatureGates); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to set feature gates from initial flags-based config: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct a KubeletServer from kubeletFlags and kubeletConfig</span></span><br><span class="line">kubeletServer := &amp;options.KubeletServer&#123;</span><br><span class="line">KubeletFlags:         *kubeletFlags,</span><br><span class="line">KubeletConfiguration: *kubeletConfig,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use kubeletServer to construct the default KubeletDeps</span></span><br><span class="line">kubeletDeps, err := UnsecuredDependencies(kubeletServer, utilfeature.DefaultFeatureGate)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to construct kubelet dependencies: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// run the kubelet</span></span><br><span class="line"><span class="keyword">return</span> Run(ctx, kubeletServer, kubeletDeps, utilfeature.DefaultFeatureGate)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方式比较长，但是除了最终的Run方法，其余的步骤还是为 kubelet 的启动构建初始化的参数。</p><p>其中，最主要的是通过命令行参数kubeletFlags 和配置文件 kubeletConfig，配置 kubeletServer 结构体，</p><p>最后调用 Run 函数。</p><p><u><em>kubernetes/cmd/kubelet/app/server/go</em></u>#411</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(ctx context.Context, s *options.KubeletServer, kubeDeps *kubelet.Dependencies, featureGate featuregate.FeatureGate)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// To help debugging, immediately log version</span></span><br><span class="line">klog.InfoS(<span class="string">&quot;Kubelet version&quot;</span>, <span class="string">&quot;kubeletVersion&quot;</span>, version.Get())</span><br><span class="line"></span><br><span class="line">klog.InfoS(<span class="string">&quot;Golang settings&quot;</span>, <span class="string">&quot;GOGC&quot;</span>, os.Getenv(<span class="string">&quot;GOGC&quot;</span>), <span class="string">&quot;GOMAXPROCS&quot;</span>, os.Getenv(<span class="string">&quot;GOMAXPROCS&quot;</span>), <span class="string">&quot;GOTRACEBACK&quot;</span>, os.Getenv(<span class="string">&quot;GOTRACEBACK&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.若为 win 系统，预先执行 WindowsPriorityClass 操作</span></span><br><span class="line"><span class="keyword">if</span> err := initForOS(s.KubeletFlags.WindowsService, s.KubeletFlags.WindowsPriorityClass); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed OS init: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.执行 run 函数</span></span><br><span class="line"><span class="keyword">if</span> err := run(ctx, s, kubeDeps, featureGate); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to run Kubelet: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initForOS通过对操作系统的判断，如果是windows系统需要做一些预先的特殊处理；然后继续执行 run 方法</p><p><u><em>kubernetes/cmd/kubelet/app/server/go</em></u>#490</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(ctx context.Context, s *options.KubeletServer, kubeDeps *kubelet.Dependencies, featureGate featuregate.FeatureGate)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.根据 KubeletServer 设置全局特性门控</span></span><br><span class="line">err = utilfeature.DefaultMutableFeatureGate.SetFromMap(s.KubeletConfiguration.FeatureGates)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.对KubetletServer中，kubectlFlags,KubeletConfiguration 进行格式验证</span></span><br><span class="line"><span class="keyword">if</span> err := options.ValidateKubeletServer(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.在/configz端点注册当前配置</span></span><br><span class="line">err = initConfigz(&amp;s.KubeletConfiguration)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Failed to register kubelet configuration with configz&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s.ShowHiddenMetricsForVersion) &gt; <span class="number">0</span> &#123;</span><br><span class="line">metrics.SetShowHidden()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 初始化依赖客户端</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="comment">// 4.1 如果处于独立模式，则将所有客户端设置为nil</span></span><br><span class="line"><span class="keyword">case</span> standaloneMode:</span><br><span class="line">kubeDeps.KubeClient = <span class="literal">nil</span></span><br><span class="line">kubeDeps.EventClient = <span class="literal">nil</span></span><br><span class="line">kubeDeps.HeartbeatClient = <span class="literal">nil</span></span><br><span class="line">klog.InfoS(<span class="string">&quot;Standalone mode, no API client&quot;</span>)</span><br><span class="line"><span class="comment">// 4.2 非独立模式，初始化依赖客户端</span></span><br><span class="line"><span class="keyword">case</span> kubeDeps.KubeClient == <span class="literal">nil</span>, kubeDeps.EventClient == <span class="literal">nil</span>, kubeDeps.HeartbeatClient == <span class="literal">nil</span>:</span><br><span class="line">clientConfig, onHeartbeatFailure, err := buildKubeletClientConfig(ctx, s, kubeDeps.TracerProvider, nodeName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> onHeartbeatFailure == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;onHeartbeatFailure must be a valid function other than nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">kubeDeps.OnHeartbeatFailure = onHeartbeatFailure</span><br><span class="line"></span><br><span class="line">kubeDeps.KubeClient, err = clientset.NewForConfig(clientConfig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to initialize kubelet client: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.2.1 创建单独的 eventClient</span></span><br><span class="line">eventClientConfig := *clientConfig</span><br><span class="line">eventClientConfig.QPS = <span class="type">float32</span>(s.EventRecordQPS)</span><br><span class="line">eventClientConfig.Burst = <span class="type">int</span>(s.EventBurst)</span><br><span class="line">kubeDeps.EventClient, err = v1core.NewForConfig(&amp;eventClientConfig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to initialize kubelet event client: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.2.2 创建 heartbeatClient</span></span><br><span class="line">heartbeatClientConfig := *clientConfig</span><br><span class="line">heartbeatClientConfig.Timeout = s.KubeletConfiguration.NodeStatusUpdateFrequency.Duration</span><br><span class="line"><span class="comment">// 超时时间是租期和状态更新频率的最小值</span></span><br><span class="line">leaseTimeout := time.Duration(s.KubeletConfiguration.NodeLeaseDurationSeconds) * time.Second</span><br><span class="line"><span class="keyword">if</span> heartbeatClientConfig.Timeout &gt; leaseTimeout &#123;</span><br><span class="line">heartbeatClientConfig.Timeout = leaseTimeout</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭节流</span></span><br><span class="line">heartbeatClientConfig.QPS = <span class="type">float32</span>(<span class="number">-1</span>)</span><br><span class="line">kubeDeps.HeartbeatClient, err = clientset.NewForConfig(&amp;heartbeatClientConfig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to initialize kubelet heartbeat client: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 初始化 kubeletAuth 的 interface</span></span><br><span class="line"><span class="keyword">if</span> kubeDeps.Auth == <span class="literal">nil</span> &#123;</span><br><span class="line">auth, runAuthenticatorCAReload, err := BuildAuth(nodeName, kubeDeps.KubeClient, s.KubeletConfiguration)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">kubeDeps.Auth = auth</span><br><span class="line">runAuthenticatorCAReload(ctx.Done())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.为 kubelet 初始化 eventRecorder</span></span><br><span class="line">makeEventRecorder(kubeDeps, nodeName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7. 创建 containerManager 实例</span></span><br><span class="line"><span class="keyword">if</span> kubeDeps.ContainerManager == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.CgroupsPerQOS &amp;&amp; s.CgroupRoot == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">klog.InfoS(<span class="string">&quot;--cgroups-per-qos enabled, but --cgroup-root was not specified.  defaulting to /&quot;</span>)</span><br><span class="line">s.CgroupRoot = <span class="string">&quot;/&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.1 获取 system 预留 cpu 大小</span></span><br><span class="line">machineInfo, err := kubeDeps.CAdvisorInterface.MachineInfo()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">reservedSystemCPUs, err := getReservedCPUs(machineInfo, s.ReservedSystemCPUs)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> reservedSystemCPUs.Size() &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// at cmd option validation phase it is tested either --system-reserved-cgroup or --kube-reserved-cgroup is specified, so overwrite should be ok</span></span><br><span class="line">klog.InfoS(<span class="string">&quot;Option --reserved-cpus is specified, it will overwrite the cpu setting in KubeReserved and SystemReserved&quot;</span>, <span class="string">&quot;kubeReservedCPUs&quot;</span>, s.KubeReserved, <span class="string">&quot;systemReservedCPUs&quot;</span>, s.SystemReserved)</span><br><span class="line"><span class="keyword">if</span> s.KubeReserved != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(s.KubeReserved, <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s.SystemReserved == <span class="literal">nil</span> &#123;</span><br><span class="line">s.SystemReserved = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.SystemReserved[<span class="string">&quot;cpu&quot;</span>] = strconv.Itoa(reservedSystemCPUs.Size())</span><br><span class="line">klog.InfoS(<span class="string">&quot;After cpu setting is overwritten&quot;</span>, <span class="string">&quot;kubeReservedCPUs&quot;</span>, s.KubeReserved, <span class="string">&quot;systemReservedCPUs&quot;</span>, s.SystemReserved)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.2 更新集群预留</span></span><br><span class="line">kubeReserved, err := parseResourceList(s.KubeReserved)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 7.3 获取系统预留</span></span><br><span class="line">systemReserved, err := parseResourceList(s.SystemReserved)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7.4 设置硬驱逐阈值</span></span><br><span class="line"><span class="keyword">var</span> hardEvictionThresholds []evictionapi.Threshold</span><br><span class="line"><span class="comment">// If the user requested to ignore eviction thresholds, then do not set valid values for hardEvictionThresholds here.</span></span><br><span class="line"><span class="keyword">if</span> !s.ExperimentalNodeAllocatableIgnoreEvictionThreshold &#123;</span><br><span class="line">hardEvictionThresholds, err = eviction.ParseThresholdConfig([]<span class="type">string</span>&#123;&#125;, s.EvictionHard, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7.5 获得 Qos 预留资源，目前仅限制预留 memory</span></span><br><span class="line">experimentalQOSReserved, err := cm.ParseQOSReserved(s.QOSReserved)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.6 默认开启 devicePlugins 特性门控</span></span><br><span class="line">devicePluginEnabled := utilfeature.DefaultFeatureGate.Enabled(features.DevicePlugins)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cpuManagerPolicyOptions <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.CPUManager) &#123;</span><br><span class="line"><span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.CPUManagerPolicyOptions) &#123;</span><br><span class="line">cpuManagerPolicyOptions = s.CPUManagerPolicyOptions</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s.CPUManagerPolicyOptions != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;CPU Manager policy options %v require feature gates %q, %q enabled&quot;</span>,</span><br><span class="line">s.CPUManagerPolicyOptions, features.CPUManager, features.CPUManagerPolicyOptions)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.7 创建 containerManager 实例</span></span><br><span class="line">kubeDeps.ContainerManager, err = cm.NewContainerManager(</span><br><span class="line">kubeDeps.Mounter,</span><br><span class="line">kubeDeps.CAdvisorInterface,</span><br><span class="line">cm.NodeConfig&#123;</span><br><span class="line">RuntimeCgroupsName:    s.RuntimeCgroups,</span><br><span class="line">SystemCgroupsName:     s.SystemCgroups,</span><br><span class="line">KubeletCgroupsName:    s.KubeletCgroups,</span><br><span class="line">KubeletOOMScoreAdj:    s.OOMScoreAdj,</span><br><span class="line">CgroupsPerQOS:         s.CgroupsPerQOS,</span><br><span class="line">CgroupRoot:            s.CgroupRoot,</span><br><span class="line">CgroupDriver:          s.CgroupDriver,</span><br><span class="line">KubeletRootDir:        s.RootDirectory,</span><br><span class="line">ProtectKernelDefaults: s.ProtectKernelDefaults,</span><br><span class="line">NodeAllocatableConfig: cm.NodeAllocatableConfig&#123;</span><br><span class="line">KubeReservedCgroupName:   s.KubeReservedCgroup,</span><br><span class="line">SystemReservedCgroupName: s.SystemReservedCgroup,</span><br><span class="line">EnforceNodeAllocatable:   sets.NewString(s.EnforceNodeAllocatable...),</span><br><span class="line">KubeReserved:             kubeReserved,</span><br><span class="line">SystemReserved:           systemReserved,</span><br><span class="line">ReservedSystemCPUs:       reservedSystemCPUs,</span><br><span class="line">HardEvictionThresholds:   hardEvictionThresholds,</span><br><span class="line">&#125;,</span><br><span class="line">QOSReserved:                             *experimentalQOSReserved,</span><br><span class="line">ExperimentalCPUManagerPolicy:            s.CPUManagerPolicy,</span><br><span class="line">ExperimentalCPUManagerPolicyOptions:     cpuManagerPolicyOptions,</span><br><span class="line">ExperimentalCPUManagerReconcilePeriod:   s.CPUManagerReconcilePeriod.Duration,</span><br><span class="line">ExperimentalMemoryManagerPolicy:         s.MemoryManagerPolicy,</span><br><span class="line">ExperimentalMemoryManagerReservedMemory: s.ReservedMemory,</span><br><span class="line">ExperimentalPodPidsLimit:                s.PodPidsLimit,</span><br><span class="line">EnforceCPULimits:                        s.CPUCFSQuota,</span><br><span class="line">CPUCFSQuotaPeriod:                       s.CPUCFSQuotaPeriod.Duration,</span><br><span class="line">ExperimentalTopologyManagerPolicy:       s.TopologyManagerPolicy,</span><br><span class="line">ExperimentalTopologyManagerScope:        s.TopologyManagerScope,</span><br><span class="line">&#125;,</span><br><span class="line">s.FailSwapOn,</span><br><span class="line">devicePluginEnabled,</span><br><span class="line">kubeDeps.Recorder)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO(vmarmol): Do this through container config.</span></span><br><span class="line">oomAdjuster := kubeDeps.OOMAdjuster</span><br><span class="line"><span class="keyword">if</span> err := oomAdjuster.ApplyOOMScoreAdj(<span class="number">0</span>, <span class="type">int</span>(s.OOMScoreAdj)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.InfoS(<span class="string">&quot;Failed to ApplyOOMScoreAdj&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 8. 初始化 runtimeServer</span></span><br><span class="line">err = kubelet.PreInitRuntimeService(&amp;s.KubeletConfiguration, kubeDeps, s.RemoteRuntimeEndpoint, s.RemoteImageEndpoint)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 9. 运行 kubelet</span></span><br><span class="line"><span class="keyword">if</span> err := RunKubelet(s, kubeDeps, s.RunOnce); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.HealthzPort &gt; <span class="number">0</span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">healthz.InstallHandler(mux)</span><br><span class="line"><span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := http.ListenAndServe(net.JoinHostPort(s.HealthzBindAddress, strconv.Itoa(<span class="type">int</span>(s.HealthzPort))), mux)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Failed to start healthz server&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">5</span>*time.Second, wait.NeverStop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.RunOnce &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If systemd is used, notify it that we have started</span></span><br><span class="line"><span class="keyword">go</span> daemon.SdNotify(<span class="literal">false</span>, <span class="string">&quot;READY=1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run函数，主要做以下几件事情：</p><ol><li><p>根据 KubeletServer 设置全局特性门控</p></li><li><p>对 KubetletServer中，kubectlFlags、kubeletConfiguration 进行格式验证</p></li><li><p>在/configz端点注册当前配置</p></li><li><p>初始化 KubeClient 客户端、EventClient 客户端、heartbeatClient 客户端</p></li><li><p>创建 kubeletAuth 实例 </p></li><li><p>创建 eventRecorder 实例</p></li><li><p>创建 containerManager 实例</p></li><li><p>初始化 runtimeServer，即创建 RemoteRuntimeService、RemoteImageService 实例</p></li><li><p>执行 Runkubelet    </p></li></ol><p>接下来，继续看 Runkubelet，运行 kubelet 的流程。</p><p><u><em>kubernetnes/cmd/kubelet/server.go#1097</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunKubelet</span><span class="params">(kubeServer *options.KubeletServer, kubeDeps *kubelet.Dependencies, runOnce <span class="type">bool</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 获取hostname</span></span><br><span class="line">hostname, err := nodeutil.GetHostname(kubeServer.HostnameOverride)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 获取nodename</span></span><br><span class="line">nodeName, err := getNodeName(kubeDeps.Cloud, hostname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">hostnameOverridden := <span class="built_in">len</span>(kubeServer.HostnameOverride) &gt; <span class="number">0</span></span><br><span class="line"><span class="comment">// 3. 初始化 eventRecoeder 实例</span></span><br><span class="line">makeEventRecorder(kubeDeps, nodeName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 获取 nodeIP, 并验证其合法性</span></span><br><span class="line"><span class="keyword">var</span> nodeIPs []net.IP</span><br><span class="line"><span class="keyword">if</span> kubeServer.NodeIP != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, ip := <span class="keyword">range</span> strings.Split(kubeServer.NodeIP, <span class="string">&quot;,&quot;</span>) &#123;</span><br><span class="line">parsedNodeIP := netutils.ParseIPSloppy(strings.TrimSpace(ip))</span><br><span class="line"><span class="keyword">if</span> parsedNodeIP == <span class="literal">nil</span> &#123;</span><br><span class="line">klog.InfoS(<span class="string">&quot;Could not parse --node-ip ignoring&quot;</span>, <span class="string">&quot;IP&quot;</span>, ip)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">nodeIPs = <span class="built_in">append</span>(nodeIPs, parsedNodeIP)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nodeIPs) &gt; <span class="number">2</span> || (<span class="built_in">len</span>(nodeIPs) == <span class="number">2</span> &amp;&amp; netutils.IsIPv6(nodeIPs[<span class="number">0</span>]) == netutils.IsIPv6(nodeIPs[<span class="number">1</span>])) &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;bad --node-ip %q; must contain either a single IP or a dual-stack pair of IPs&quot;</span>, kubeServer.NodeIP)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(nodeIPs) == <span class="number">2</span> &amp;&amp; kubeServer.CloudProvider != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;dual-stack --node-ip %q not supported when using a cloud provider&quot;</span>, kubeServer.NodeIP)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(nodeIPs) == <span class="number">2</span> &amp;&amp; (nodeIPs[<span class="number">0</span>].IsUnspecified() || nodeIPs[<span class="number">1</span>].IsUnspecified()) &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;dual-stack --node-ip %q cannot include &#x27;0.0.0.0&#x27; or &#x27;::&#x27;&quot;</span>, kubeServer.NodeIP)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 创建 Capabilities 实例</span></span><br><span class="line">capabilities.Initialize(capabilities.Capabilities&#123;</span><br><span class="line">AllowPrivileged: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">credentialprovider.SetPreferredDockercfgPath(kubeServer.RootDirectory)</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;Using root directory&quot;</span>, <span class="string">&quot;path&quot;</span>, kubeServer.RootDirectory)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> kubeDeps.OSInterface == <span class="literal">nil</span> &#123;</span><br><span class="line">kubeDeps.OSInterface = kubecontainer.RealOS&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> kubeServer.KubeletConfiguration.SeccompDefault &amp;&amp; !utilfeature.DefaultFeatureGate.Enabled(features.SeccompDefault) &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;the SeccompDefault feature gate must be enabled in order to use the SeccompDefault configuration&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6. 创建 kubelet 实例</span></span><br><span class="line">k, err := createAndInitKubelet(kubeServer,</span><br><span class="line">kubeDeps,</span><br><span class="line">hostname,</span><br><span class="line">hostnameOverridden,</span><br><span class="line">nodeName,</span><br><span class="line">nodeIPs)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create kubelet: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewMainKubelet should have set up a pod source config if one didn&#x27;t exist</span></span><br><span class="line"><span class="comment">// when the builder was run. This is just a precaution.</span></span><br><span class="line"><span class="keyword">if</span> kubeDeps.PodConfig == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create kubelet, pod source config was nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">podCfg := kubeDeps.PodConfig</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := rlimit.SetNumFiles(<span class="type">uint64</span>(kubeServer.MaxOpenFiles)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Failed to set rlimit on max file handles&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.启动 kubelet 主流程</span></span><br><span class="line"><span class="keyword">if</span> runOnce &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := k.RunOnce(podCfg.Updates()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;runonce failed: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">klog.InfoS(<span class="string">&quot;Started kubelet as runonce&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">startKubelet(k, podCfg, &amp;kubeServer.KubeletConfiguration, kubeDeps, kubeServer.EnableServer)</span><br><span class="line">klog.InfoS(<span class="string">&quot;Started kubelet&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunKubelet是做两个事情，一是创建 kubelet 实例，二是运行 kubelet 主流程。这里我们先看一下 createAndInitKubelet 的流程</p><p><u><em>kubernetes/cmd/kubelet/server.go#1196</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createAndInitKubelet</span><span class="params">(kubeServer *options.KubeletServer,</span></span></span><br><span class="line"><span class="params"><span class="function">kubeDeps *kubelet.Dependencies,</span></span></span><br><span class="line"><span class="params"><span class="function">hostname <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">hostnameOverridden <span class="type">bool</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">nodeName types.NodeName,</span></span></span><br><span class="line"><span class="params"><span class="function">nodeIPs []net.IP)</span></span> (k kubelet.Bootstrap, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> block until all sources have delivered at least one update to the channel, or break the sync loop</span></span><br><span class="line"><span class="comment">// up into &quot;per source&quot; synchronizations</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 创建 kubelet 实例</span></span><br><span class="line">k, err = kubelet.NewMainKubelet(&amp;kubeServer.KubeletConfiguration,</span><br><span class="line">kubeDeps,</span><br><span class="line">&amp;kubeServer.ContainerRuntimeOptions,</span><br><span class="line">hostname,</span><br><span class="line">hostnameOverridden,</span><br><span class="line">nodeName,</span><br><span class="line">nodeIPs,</span><br><span class="line">kubeServer.ProviderID,</span><br><span class="line">kubeServer.CloudProvider,</span><br><span class="line">kubeServer.CertDirectory,</span><br><span class="line">kubeServer.RootDirectory,</span><br><span class="line">kubeServer.ImageCredentialProviderConfigFile,</span><br><span class="line">kubeServer.ImageCredentialProviderBinDir,</span><br><span class="line">kubeServer.RegisterNode,</span><br><span class="line">kubeServer.RegisterWithTaints,</span><br><span class="line">kubeServer.AllowedUnsafeSysctls,</span><br><span class="line">kubeServer.ExperimentalMounterPath,</span><br><span class="line">kubeServer.KernelMemcgNotification,</span><br><span class="line">kubeServer.ExperimentalNodeAllocatableIgnoreEvictionThreshold,</span><br><span class="line">kubeServer.MinimumGCAge,</span><br><span class="line">kubeServer.MaxPerPodContainerCount,</span><br><span class="line">kubeServer.MaxContainerCount,</span><br><span class="line">kubeServer.MasterServiceNamespace,</span><br><span class="line">kubeServer.RegisterSchedulable,</span><br><span class="line">kubeServer.KeepTerminatedPodVolumes,</span><br><span class="line">kubeServer.NodeLabels,</span><br><span class="line">kubeServer.NodeStatusMaxImages,</span><br><span class="line">kubeServer.KubeletFlags.SeccompDefault || kubeServer.KubeletConfiguration.SeccompDefault)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 记录 startint kubelet 的 event事件</span></span><br><span class="line">k.BirthCry()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 启动垃圾回收线程，对container、images进行垃圾回收</span></span><br><span class="line">k.StartGarbageCollection()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> k, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下里，我们就主要看启动kubelet的主流程逻辑：</p><p><u><em>kubernetnes/cmd/kubelet/server.go#1180</em></u></p> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startKubelet</span><span class="params">(k kubelet.Bootstrap, podCfg *config.PodConfig, kubeCfg *kubeletconfiginternal.KubeletConfiguration, kubeDeps *kubelet.Dependencies, enableServer <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 开始 kubelet 主流程</span></span><br><span class="line"><span class="keyword">go</span> k.Run(podCfg.Updates())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 启动 kubelet 安全server</span></span><br><span class="line"><span class="keyword">if</span> enableServer &#123;</span><br><span class="line"><span class="keyword">go</span> k.ListenAndServe(kubeCfg, kubeDeps.TLSOptions, kubeDeps.Auth, kubeDeps.TracerProvider)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 3. 启动 kubelet 只读端口服务</span></span><br><span class="line"><span class="keyword">if</span> kubeCfg.ReadOnlyPort &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">go</span> k.ListenAndServeReadOnly(netutils.ParseIPSloppy(kubeCfg.Address), <span class="type">uint</span>(kubeCfg.ReadOnlyPort))</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 4. 若kubeletPodResource特性门控打开，启动podResource服务</span></span><br><span class="line"><span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.KubeletPodResources) &#123;</span><br><span class="line"><span class="keyword">go</span> k.ListenAndServePodResources()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看k.run函数，kubelet 根据 podupdate 事件作出的反应。</p><p><em><u>kubernetnes/pkg/kubelet/kubelet.go#1422</u></em></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> Run(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate) &#123;</span><br><span class="line"><span class="keyword">if</span> kl.logServer == <span class="literal">nil</span> &#123;</span><br><span class="line">kl.logServer = http.StripPrefix(<span class="string">&quot;/logs/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;/var/log/&quot;</span>)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> kl.kubeClient == <span class="literal">nil</span> &#123;</span><br><span class="line">klog.InfoS(<span class="string">&quot;No API server defined - no node status update will be sent&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the cloud provider sync manager</span></span><br><span class="line"><span class="keyword">if</span> kl.cloudResourceSyncManager != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">go</span> kl.cloudResourceSyncManager.Run(wait.NeverStop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 初始化不需要容器运行时 up 的模块</span></span><br><span class="line"><span class="keyword">if</span> err := kl.initializeModules(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.recorder.Eventf(kl.nodeRef, v1.EventTypeWarning, events.KubeletSetupFailed, err.Error())</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Failed to initialize internal modules&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 初始化 volumeManager 模块</span></span><br><span class="line"><span class="keyword">go</span> kl.volumeManager.Run(kl.sourcesReady, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 非独占模式执行（k8s集群中都是非独占模式启动）</span></span><br><span class="line"><span class="keyword">if</span> kl.kubeClient != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Introduce some small jittering to ensure that over time the requests won&#x27;t start</span></span><br><span class="line"><span class="comment">// accumulating at approximately the same time from the set of nodes due to priority and</span></span><br><span class="line"><span class="comment">// fairness effect.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.1 周期性执行 syncNodeStatus 方法，默认间隔为5s，抖动因子为0.04</span></span><br><span class="line"><span class="keyword">go</span> wait.JitterUntil(kl.syncNodeStatus, kl.nodeStatusUpdateFrequency, <span class="number">0.04</span>, <span class="literal">true</span>, wait.NeverStop)</span><br><span class="line">    <span class="comment">// 3.2 首次启动时，执行一次 syncNodeStatus 方法</span></span><br><span class="line"><span class="keyword">go</span> kl.fastStatusUpdateOnce()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3 开始同步 lease 心跳</span></span><br><span class="line"><span class="keyword">go</span> kl.nodeLeaseController.Run(wait.NeverStop)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 4. 周期性监测 containerRuntime 的状态，若监测没有失败，则更新 containerRuntime 运行时间</span></span><br><span class="line"><span class="keyword">go</span> wait.Until(kl.updateRuntimeUp, <span class="number">5</span>*time.Second, wait.NeverStop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up iptables util rules</span></span><br><span class="line"><span class="keyword">if</span> kl.makeIPTablesUtilChains &#123;</span><br><span class="line">kl.initNetworkUtil()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 与 apiserver 同步 podStatuses，也可用作状态缓存</span></span><br><span class="line">kl.statusManager.Start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 开始同步 RuntimeClasses，若 enabled 的话</span></span><br><span class="line"><span class="keyword">if</span> kl.runtimeClassManager != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.runtimeClassManager.Start(wait.NeverStop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7.</span></span><br><span class="line"><span class="comment">// Start the pod lifecycle event generator.</span></span><br><span class="line">kl.pleg.Start()</span><br><span class="line">kl.syncLoop(updates, kl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kubelet-主要功能&quot;&gt;&lt;a href=&quot;#kubelet-主要功能&quot; class=&quot;headerlink&quot; title=&quot;kubelet 主要功能&quot;&gt;&lt;/a&gt;kubelet 主要功能&lt;/h1&gt;&lt;p&gt;在kubernetes集群中，每个Node节点都会启动kub</summary>
      
    
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/categories/kubelet/"/>
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/tags/kubelet/"/>
    
  </entry>
  
  <entry>
    <title>NVIDIA/kubevirt-gpu-device-plugin源码分析</title>
    <link href="http://lizhewei91.github.io/2023/01/10/32/"/>
    <id>http://lizhewei91.github.io/2023/01/10/32/</id>
    <published>2023-01-10T08:38:32.000Z</published>
    <updated>2023-01-11T09:43:32.630Z</updated>
    
    <content type="html"><![CDATA[<p>NVIDIA K8s Device Plugin为Kubevirt虚拟机分配gpu和vgpu，该篇文章基于NVIDIA/kubevirt-gpu-device-plugin:v1.2.1，<a href="https://github.com/NVIDIA/kubevirt-gpu-device-plugin/tree/v1.2.1">https://github.com/NVIDIA/kubevirt-gpu-device-plugin/tree/v1.2.1</a></p><h1 id="kubevirt-gpu-device-plugin启动"><a href="#kubevirt-gpu-device-plugin启动" class="headerlink" title="kubevirt-gpu-device-plugin启动"></a>kubevirt-gpu-device-plugin启动</h1><p>还是一样的套路，一切从main.go开始</p><p><u><em>Kubevirt-gpu-device-plugin/cmd/main.go#33</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">device_plugin.InitiateDevicePlugin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数调用 InitiateDevicePlugin 函数，直接看 InitiateDevicePlugin</p><p><u><em>Kubevirt-gpu-device-plugin/pkg/device_plugin/device_plugin.go#73</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitiateDevicePlugin</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Identifies GPUs and represents it in appropriate structures</span></span><br><span class="line">createIommuDeviceMap()</span><br><span class="line"><span class="comment">//Identifies vGPUs and represents it in appropriate structures</span></span><br><span class="line">createVgpuIDMap()</span><br><span class="line"><span class="comment">//Creates and starts device plugin</span></span><br><span class="line">createDevicePlugins()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InitiateDevicePlugin 函数主要做三件事：</p><ol><li>发现所有加载了 VFIO-PCI 驱动程序的 Nvidia gpu，并创建相应的映射</li><li>发现节点上配置的所有 Nvidia vgpu，并创建相应的映射</li><li>创建并启动 device-plugin</li></ol><h2 id="CreateIommuDeviceMap"><a href="#CreateIommuDeviceMap" class="headerlink" title="CreateIommuDeviceMap"></a>CreateIommuDeviceMap</h2><p><u><em>Kubevirt-gpu-device-plugin/pkg/device-plugin/device-plugin.go#155</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discovers all Nvidia GPUs which are loaded with VFIO-PCI driver and creates corresponding maps</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createIommuDeviceMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">iommuMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]NvidiaGpuDevice)</span><br><span class="line">deviceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line"><span class="comment">//Walk directory to discover pci devices</span></span><br><span class="line">filepath.Walk(basePath, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error accessing file path %q: %v\n&quot;</span>, path, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Not a device, continuing&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Retrieve vendor for the device</span></span><br><span class="line">vendorID, err := readIDFromFile(basePath, info.Name(), <span class="string">&quot;vendor&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get vendor ID for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Nvidia vendor id is &quot;10de&quot;. Proceed if vendor id is 10de</span></span><br><span class="line"><span class="keyword">if</span> vendorID == <span class="string">&quot;10de&quot;</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Nvidia device &quot;</span>, info.Name())</span><br><span class="line"><span class="comment">//Retrieve iommu group for the device</span></span><br><span class="line">driver, err := readLink(basePath, info.Name(), <span class="string">&quot;driver&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get driver for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> driver == <span class="string">&quot;vfio-pci&quot;</span> &#123;</span><br><span class="line">iommuGroup, err := readLink(basePath, info.Name(), <span class="string">&quot;iommu_group&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get IOMMU Group for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;Iommu Group &quot;</span> + iommuGroup)</span><br><span class="line">_, exists := iommuMap[iommuGroup]</span><br><span class="line"><span class="keyword">if</span> !exists &#123;</span><br><span class="line">deviceID, err := readIDFromFile(basePath, info.Name(), <span class="string">&quot;device&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could get deviceID for PCI address &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Device Id %s&quot;</span>, deviceID)</span><br><span class="line">deviceMap[deviceID] = <span class="built_in">append</span>(deviceMap[deviceID], iommuGroup)</span><br><span class="line">&#125;</span><br><span class="line">iommuMap[iommuGroup] = <span class="built_in">append</span>(iommuMap[iommuGroup], NvidiaGpuDevice&#123;info.Name()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createIommuDeviceMap的主要流程如下图：</p><img src="/2023/01/10/32/createIommuDeviceMap.png" class="" title="createIommuDeviceMap"><h2 id="CreateVgpuIDMap"><a href="#CreateVgpuIDMap" class="headerlink" title="CreateVgpuIDMap"></a>CreateVgpuIDMap</h2><p><u><em>Kubevirt-gpu-device-plugin/pkg/device-plugin/device-plugin.go#208</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discovers all Nvidia vGPUs configured on a node and creates corresponding maps</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createVgpuIDMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">vGpuMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]NvidiaGpuDevice)</span><br><span class="line">gpuVgpuMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line"><span class="comment">//Walk directory to discover vGPU devices</span></span><br><span class="line">filepath.Walk(vGpuBasePath, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error accessing file path %q: %v\n&quot;</span>, path, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Not a device, continuing&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Read vGPU type name</span></span><br><span class="line">vGpuID, err := readVgpuIDFromFile(vGpuBasePath, info.Name(), <span class="string">&quot;mdev_type/name&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get vGPU type identifier for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Retrieve the gpu ID for this vGPU</span></span><br><span class="line">gpuID, err := readGpuIDForVgpu(vGpuBasePath, info.Name())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get vGPU type identifier for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Gpu id is %s&quot;</span>, gpuID)</span><br><span class="line">log.Printf(<span class="string">&quot;Vgpu id is %s&quot;</span>, vGpuID)</span><br><span class="line">gpuVgpuMap[gpuID] = <span class="built_in">append</span>(gpuVgpuMap[gpuID], info.Name())</span><br><span class="line">vGpuMap[vGpuID] = <span class="built_in">append</span>(vGpuMap[vGpuID], NvidiaGpuDevice&#123;info.Name()&#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/10/32/createVgpuIDMap.png" class="" title="createVgpuIDMap"><ol><li>通过filePath.Walk遍历“/sys/bus/mdev/devices”目录下的所有文件，得到所有 vgpu 相应设备文件</li><li>读取readVgpuIDFromFile(“/sys/bus/mdev/devices”,info.Name(),”mdev_type/name”)，获得vgpu的vGpuID</li><li>读取readGpuIDFromVgpu(“/sys/bus/mdev/devices”,info.Name())，获取vgpu对应的gpuID</li><li>最后，通过 gpuVgpuMap=map[ <gpuID> ] []string{ <vgpu-id1>,<vgpu-id2>…} 和 vGpuMap=map[ <vGpuID> ] []NvidiaGpuDevice{ {addr:<addr1>},{addr:<addr2>}} 存储映射关系。</li></ol><h2 id="CreateDevicePlugins"><a href="#CreateDevicePlugins" class="headerlink" title="CreateDevicePlugins"></a>CreateDevicePlugins</h2><p><u><em>Kubevirt-gpu-device-plugin/pkg/device-plugin/device-plugin.go#82</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Starts gpu pass through and vGPU device plugin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createDevicePlugins</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> devicePlugins []*GenericDevicePlugin</span><br><span class="line"><span class="keyword">var</span> vGpuDevicePlugins []*GenericVGpuDevicePlugin</span><br><span class="line"><span class="keyword">var</span> devs []*pluginapi.Device</span><br><span class="line">log.Printf(<span class="string">&quot;Iommu Map %s&quot;</span>, iommuMap)</span><br><span class="line">log.Printf(<span class="string">&quot;Device Map %s&quot;</span>, deviceMap)</span><br><span class="line">log.Println(<span class="string">&quot;vGPU Map &quot;</span>, vGpuMap)</span><br><span class="line">log.Println(<span class="string">&quot;GPU vGPU Map &quot;</span>, gpuVgpuMap)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Iterate over deivceMap to create device plugin for each type of GPU on the host</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> deviceMap &#123;</span><br><span class="line">devs = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> v &#123;</span><br><span class="line">devs = <span class="built_in">append</span>(devs, &amp;pluginapi.Device&#123;</span><br><span class="line">ID:     dev,</span><br><span class="line">Health: pluginapi.Healthy,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">deviceName := getDeviceName(k)</span><br><span class="line"><span class="keyword">if</span> deviceName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error: Could not find device name for device id: %s&quot;</span>, k)</span><br><span class="line">deviceName = k</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;DP Name %s&quot;</span>, deviceName)</span><br><span class="line">dp := NewGenericDevicePlugin(deviceName, <span class="string">&quot;/sys/kernel/iommu_groups/&quot;</span>, devs)</span><br><span class="line">err := startDevicePlugin(dp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error starting %s device plugin: %v&quot;</span>, dp.deviceName, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">devicePlugins = <span class="built_in">append</span>(devicePlugins, dp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Iterate over vGpuMap to create device plugin for each type of vGPU on the host</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> vGpuMap &#123;</span><br><span class="line">devs = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> v &#123;</span><br><span class="line">devs = <span class="built_in">append</span>(devs, &amp;pluginapi.Device&#123;</span><br><span class="line">ID:     dev.addr,</span><br><span class="line">Health: pluginapi.Healthy,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">deviceName := getDeviceName(k)</span><br><span class="line"><span class="keyword">if</span> deviceName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">deviceName = k</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;DP Name %s&quot;</span>, deviceName)</span><br><span class="line">dp := NewGenericVGpuDevicePlugin(deviceName, vGpuBasePath, devs)</span><br><span class="line">err := startVgpuDevicePlugin(dp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error starting %s device plugin: %v&quot;</span>, dp.deviceName, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">vGpuDevicePlugins = <span class="built_in">append</span>(vGpuDevicePlugins, dp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-stop</span><br><span class="line">log.Printf(<span class="string">&quot;Shutting down device plugin controller&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> devicePlugins &#123;</span><br><span class="line">v.Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createDevicePlugin的流程图如下：</p><img src="/2023/01/10/32/kubevirt-device-plugin.png" class="" title="kubevirt-device-plugin"><p>启动kubevirt-gpu-device-plugin步骤主要有以下几点：</p><ol><li>遍历 deviveMap 将所有 device 设备类型下的所有 gpu 标记为 healthy </li><li>remove 并重建 socket 文件（”/var/lib/kubelet/device-plugins”+”kubevirt-<deviceName>.sock”）</li><li>启动 devicePlugin 的 grpc server，对外提供服务</li><li>请求kubelet socket链接，进行Regster</li><li>启动一个协程对设备进行healthCheck，并监听device-plguin自身socket文件</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>kubevirt-gpu-device-plugin使用前提，是用户使用 vfio-pci 将设备透传至 vm 内，然后，通过读取 vm 内的 pci 设备文件，获取设备的相关信息。iommu,vfio-pci等相关的内容，后续有时间会再补充。</p><h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><p><a href="https://rtoax.blog.csdn.net/article/details/110843839#t11">https://rtoax.blog.csdn.net/article/details/110843839#t11</a></p><p><a href="https://cloud.tencent.com/developer/article/1816469">https://cloud.tencent.com/developer/article/1816469</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;NVIDIA K8s Device Plugin为Kubevirt虚拟机分配gpu和vgpu，该篇文章基于NVIDIA/kubevirt-gpu-device-plugin:v1.2.1，&lt;a href=&quot;https://github.com/NVIDIA/kubevirt</summary>
      
    
    
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/categories/device-plugins/"/>
    
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/tags/device-plugins/"/>
    
    <category term="gpu" scheme="http://lizhewei91.github.io/tags/gpu/"/>
    
    <category term="kubevirt-gpu-device-plugin" scheme="http://lizhewei91.github.io/tags/kubevirt-gpu-device-plugin/"/>
    
  </entry>
  
  <entry>
    <title>NVIDIA/k8s-device-plugin源码分析</title>
    <link href="http://lizhewei91.github.io/2023/01/06/46/"/>
    <id>http://lizhewei91.github.io/2023/01/06/46/</id>
    <published>2023-01-06T07:43:46.000Z</published>
    <updated>2023-01-10T09:08:02.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="device-plugin启动"><a href="#device-plugin启动" class="headerlink" title="device-plugin启动"></a>device-plugin启动</h1><p>该篇文章基于NVIDIA/k8s-device-plugin: v0.13.0，<a href="https://github.com/NVIDIA/k8s-device-plugin/tree/v0.13.0">https://github.com/NVIDIA/k8s-device-plugin/tree/v0.13.0</a></p><p>一切从 main 函数开始作为入口：</p><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/main.go#35</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> configFile <span class="type">string</span></span><br><span class="line"></span><br><span class="line">c := cli.NewApp()</span><br><span class="line">c.Name = <span class="string">&quot;NVIDIA Device Plugin&quot;</span></span><br><span class="line">c.Usage = <span class="string">&quot;NVIDIA device plugin for Kubernetes&quot;</span></span><br><span class="line">c.Version = info.GetVersionString()</span><br><span class="line">c.Action = <span class="function"><span class="keyword">func</span><span class="params">(ctx *cli.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> start(ctx, c.Flags)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 接下来，调用 start 函数</p><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/main.go#133</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">(c *cli.Context, flags []cli.Flag)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Starting FS watcher.&quot;</span>)</span><br><span class="line">watcher, err := newFSWatcher(pluginapi.DevicePluginPath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create FS watcher: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> watcher.Close()</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Starting OS watcher.&quot;</span>)</span><br><span class="line">sigs := newOSWatcher(syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> restarting <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> restartTimeout &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line"><span class="keyword">var</span> plugins []*NvidiaDevicePlugin</span><br><span class="line">restart:</span><br><span class="line"><span class="comment">// If we are restarting, stop plugins from previous run.</span></span><br><span class="line"><span class="keyword">if</span> restarting &#123;</span><br><span class="line">err := stopPlugins(plugins)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error stopping plugins from previous run: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Starting Plugins.&quot;</span>)</span><br><span class="line">plugins, restartPlugins, err := startPlugins(c, flags, restarting)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error starting plugins: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> restartPlugins &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Failed to start one or more plugins. Retrying in 30s...&quot;</span>)</span><br><span class="line">restartTimeout = time.After(<span class="number">30</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restarting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start an infinite loop, waiting for several indicators to either log</span></span><br><span class="line"><span class="comment">// some messages, trigger a restart of the plugins, or exit the program.</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// If the restart timout has expired, then restart the plugins</span></span><br><span class="line"><span class="keyword">case</span> &lt;-restartTimeout:</span><br><span class="line"><span class="keyword">goto</span> restart</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a kubelet restart by watching for a newly created</span></span><br><span class="line"><span class="comment">// &#x27;pluginapi.KubeletSocket&#x27; file. When this occurs, restart this loop,</span></span><br><span class="line"><span class="comment">// restarting all of the plugins in the process.</span></span><br><span class="line"><span class="keyword">case</span> event := &lt;-watcher.Events:</span><br><span class="line"><span class="keyword">if</span> event.Name == pluginapi.KubeletSocket &amp;&amp; event.Op&amp;fsnotify.Create == fsnotify.Create &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;inotify: %s created, restarting.&quot;</span>, pluginapi.KubeletSocket)</span><br><span class="line"><span class="keyword">goto</span> restart</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Watch for any other fs errors and log them.</span></span><br><span class="line"><span class="keyword">case</span> err := &lt;-watcher.Errors:</span><br><span class="line">log.Printf(<span class="string">&quot;inotify: %s&quot;</span>, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Watch for any signals from the OS. On SIGHUP, restart this loop,</span></span><br><span class="line"><span class="comment">// restarting all of the plugins in the process. On all other</span></span><br><span class="line"><span class="comment">// signals, exit the loop and exit the program.</span></span><br><span class="line"><span class="keyword">case</span> s := &lt;-sigs:</span><br><span class="line"><span class="keyword">switch</span> s &#123;</span><br><span class="line"><span class="keyword">case</span> syscall.SIGHUP:</span><br><span class="line">log.Println(<span class="string">&quot;Received SIGHUP, restarting.&quot;</span>)</span><br><span class="line"><span class="keyword">goto</span> restart</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">log.Printf(<span class="string">&quot;Received signal \&quot;%v\&quot;, shutting down.&quot;</span>, s)</span><br><span class="line"><span class="keyword">goto</span> exit</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">exit:</span><br><span class="line">err = stopPlugins(plugins)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error stopping plugins: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/06/46/k8s-device-plugin%E5%90%AF%E5%8A%A8.png" class="" title="k8s-device-plugin启动"><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#92</em></u></p><p>K8s-device-plugin的启动流程中，nvidiaDevicePlugin.Start主要有三个步骤，1.启动device-plugin的grpc服务；2.向kubelet注册；3.启动协程对设备checkHealth。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Start() <span class="type">error</span> &#123;</span><br><span class="line">plugin.initialize()</span><br><span class="line"></span><br><span class="line">err := plugin.Serve()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Could not start device plugin for &#x27;%s&#x27;: %s&quot;</span>, plugin.rm.Resource(), err)</span><br><span class="line">plugin.cleanup()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Starting to serve &#x27;%s&#x27; on %s&quot;</span>, plugin.rm.Resource(), plugin.socket)</span><br><span class="line"></span><br><span class="line">err = plugin.Register()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Could not register device plugin: %s&quot;</span>, err)</span><br><span class="line">plugin.Stop()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Registered device plugin for &#x27;%s&#x27; with Kubelet&quot;</span>, plugin.rm.Resource())</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := plugin.rm.CheckHealth(plugin.stop, plugin.health)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Failed to start health check: %v; continuing with health checks disabled&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/06/46/start%E6%B5%81%E7%A8%8B.png" class="" title="startl流程"><h3 id="Serve"><a href="#Serve" class="headerlink" title="Serve"></a>Serve</h3><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#136</em></u></p><p>k8s-device-plugin 启动 gRPC 服务，对外提供服务</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Serve() <span class="type">error</span> &#123;</span><br><span class="line">os.Remove(plugin.socket)</span><br><span class="line">sock, err := net.Listen(<span class="string">&quot;unix&quot;</span>, plugin.socket)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pluginapi.RegisterDevicePluginServer(plugin.server, plugin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">lastCrashTime := time.Now()</span><br><span class="line">restartCount := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Starting GRPC server for &#x27;%s&#x27;&quot;</span>, plugin.rm.Resource())</span><br><span class="line">err := plugin.server.Serve(sock)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;GRPC server for &#x27;%s&#x27; crashed with error: %v&quot;</span>, plugin.rm.Resource(), err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// restart if it has not been too often</span></span><br><span class="line"><span class="comment">// i.e. if server has crashed more than 5 times and it didn&#x27;t last more than one hour each time</span></span><br><span class="line"><span class="keyword">if</span> restartCount &gt; <span class="number">5</span> &#123;</span><br><span class="line"><span class="comment">// quit</span></span><br><span class="line">log.Fatalf(<span class="string">&quot;GRPC server for &#x27;%s&#x27; has repeatedly crashed recently. Quitting&quot;</span>, plugin.rm.Resource())</span><br><span class="line">&#125;</span><br><span class="line">timeSinceLastCrash := time.Since(lastCrashTime).Seconds()</span><br><span class="line">lastCrashTime = time.Now()</span><br><span class="line"><span class="keyword">if</span> timeSinceLastCrash &gt; <span class="number">3600</span> &#123;</span><br><span class="line"><span class="comment">// it has been one hour since the last crash.. reset the count</span></span><br><span class="line"><span class="comment">// to reflect on the frequency</span></span><br><span class="line">restartCount = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">restartCount++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for server to start by launching a blocking connexion</span></span><br><span class="line">conn, err := plugin.dial(plugin.socket, <span class="number">5</span>*time.Second)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/06/46/serve%E5%90%AF%E5%8A%A8.png" class="" title="serve启动"><p>serve主要负责重建nvidia.sock文件，并且注册5个grpc接口到grpc.Server。</p><h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#186</em></u></p><p>Serve之后，接着进入Register流程，其代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Register() <span class="type">error</span> &#123;</span><br><span class="line">conn, err := plugin.dial(pluginapi.KubeletSocket, <span class="number">5</span>*time.Second)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">client := pluginapi.NewRegistrationClient(conn)</span><br><span class="line">reqt := &amp;pluginapi.RegisterRequest&#123;</span><br><span class="line">Version:      pluginapi.Version,</span><br><span class="line">Endpoint:     path.Base(plugin.socket),</span><br><span class="line">ResourceName: <span class="type">string</span>(plugin.rm.Resource()),</span><br><span class="line">Options: &amp;pluginapi.DevicePluginOptions&#123;</span><br><span class="line">GetPreferredAllocationAvailable: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = client.Register(context.Background(), reqt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Register的实现流程图如下：</p><img src="/2023/01/06/46/register%E6%B5%81%E7%A8%8B.png" class="" title="register流程"><ul><li>注册的Resource Name是<code>nvidia.com/gpu</code></li><li>注册的Version是<code>v1beta1</code></li></ul><h3 id="CheckHealth"><a href="#CheckHealth" class="headerlink" title="CheckHealth"></a>CheckHealth</h3><p><u><em>k8s-device-plugin/internal/rm/health.go#42</em></u></p><p>启动协程开始对管理的devices进行健康状态空空，一旦发现有device unhealthy，则发送到NvidiaDevicePlugin的health channel。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *nvmlResourceManager)</span></span> checkHealth(stop &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, devices Devices, unhealthy <span class="keyword">chan</span>&lt;- *Device) <span class="type">error</span> &#123;</span><br><span class="line">disableHealthChecks := strings.ToLower(os.Getenv(envDisableHealthChecks))</span><br><span class="line"><span class="keyword">if</span> disableHealthChecks == <span class="string">&quot;all&quot;</span> &#123;</span><br><span class="line">disableHealthChecks = allHealthChecks</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> strings.Contains(disableHealthChecks, <span class="string">&quot;xids&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := r.nvml.Init()</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line"><span class="keyword">if</span> *r.config.Flags.FailOnInitError &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to initialize NVML: %v&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret := r.nvml.Shutdown()</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error shutting down NVML: %v&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> formalize the full list and document it.</span></span><br><span class="line"><span class="comment">// http://docs.nvidia.com/deploy/xid-errors/index.html#topic_4</span></span><br><span class="line"><span class="comment">// Application errors: the GPU should still be healthy</span></span><br><span class="line">applicationErrorXids := []<span class="type">uint64</span>&#123;</span><br><span class="line"><span class="number">13</span>, <span class="comment">// Graphics Engine Exception</span></span><br><span class="line"><span class="number">31</span>, <span class="comment">// GPU memory page fault</span></span><br><span class="line"><span class="number">43</span>, <span class="comment">// GPU stopped processing</span></span><br><span class="line"><span class="number">45</span>, <span class="comment">// Preemptive cleanup, due to previous errors</span></span><br><span class="line"><span class="number">68</span>, <span class="comment">// Video processor exception</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skippedXids := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]<span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> _, id := <span class="keyword">range</span> applicationErrorXids &#123;</span><br><span class="line">skippedXids[id] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, additionalXid := <span class="keyword">range</span> getAdditionalXids(disableHealthChecks) &#123;</span><br><span class="line">skippedXids[additionalXid] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eventSet, ret := r.nvml.EventSetCreate()</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create event set: %v&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> eventSet.Free()</span><br><span class="line"></span><br><span class="line">parentToDeviceMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*Device)</span><br><span class="line">deviceIDToGiMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">deviceIDToCiMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">eventMask := <span class="type">uint64</span>(nvml.EventTypeXidCriticalError | nvml.EventTypeDoubleBitEccError | nvml.EventTypeSingleBitEccError)</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> devices &#123;</span><br><span class="line">uuid, gi, ci, err := r.getDevicePlacement(d)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Warning: could not determine device placement for %v: %v; Marking it unhealthy.&quot;</span>, d.ID, err)</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">deviceIDToGiMap[d.ID] = gi</span><br><span class="line">deviceIDToCiMap[d.ID] = ci</span><br><span class="line">parentToDeviceMap[uuid] = d</span><br><span class="line"></span><br><span class="line">gpu, ret := r.nvml.DeviceGetHandleByUUID(uuid)</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;unable to get device handle from UUID: %v; marking it as unhealthy&quot;</span>, ret)</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">supportedEvents, ret := gpu.GetSupportedEventTypes()</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;unabled to determine the supported events for %v: %v; marking it as unhealthy&quot;</span>, d.ID, ret)</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = gpu.RegisterEvents(eventMask&amp;supportedEvents, eventSet)</span><br><span class="line"><span class="keyword">if</span> ret == nvml.ERROR_NOT_SUPPORTED &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Warning: Device %v is too old to support healthchecking.&quot;</span>, d.ID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Marking device %v as unhealthy: %v&quot;</span>, d.ID, ret)</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stop:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e, ret := eventSet.Wait(<span class="number">5000</span>)</span><br><span class="line"><span class="keyword">if</span> ret == nvml.ERROR_TIMEOUT &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error waiting for event: %v; Marking all devices as unhealthy&quot;</span>, ret)</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> devices &#123;</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e.EventType != nvml.EventTypeXidCriticalError &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Skipping non-nvmlEventTypeXidCriticalError event: %+v&quot;</span>, e)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> skippedXids[e.EventData] &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Skipping event %+v&quot;</span>, e)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Processing event %+v&quot;</span>, e)</span><br><span class="line">eventUUID, ret := e.Device.GetUUID()</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line"><span class="comment">// If we cannot reliably determine the device UUID, we mark all devices as unhealthy.</span></span><br><span class="line">log.Printf(<span class="string">&quot;Failed to determine uuid for event %v: %v; Marking all devices as unhealthy.&quot;</span>, e, ret)</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> devices &#123;</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d, exists := parentToDeviceMap[eventUUID]</span><br><span class="line"><span class="keyword">if</span> !exists &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Ignoring event for unexpected device: %v&quot;</span>, eventUUID)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> d.IsMigDevice() &amp;&amp; e.GpuInstanceId != <span class="number">0xFFFFFFFF</span> &amp;&amp; e.ComputeInstanceId != <span class="number">0xFFFFFFFF</span> &#123;</span><br><span class="line">gi := deviceIDToGiMap[d.ID]</span><br><span class="line">ci := deviceIDToCiMap[d.ID]</span><br><span class="line"><span class="keyword">if</span> !(<span class="type">uint32</span>(gi) == e.GpuInstanceId &amp;&amp; <span class="type">uint32</span>(ci) == e.ComputeInstanceId) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Event for mig device %v (gi=%v, ci=%v)&quot;</span>, d.ID, gi, ci)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;XidCriticalError: Xid=%d on Device=%s; marking device as unhealthy.&quot;</span>, e.EventData, d.ID)</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checkhealth的主要原理图如下：</p><img src="/2023/01/06/46/checkhealth.png" class="" title="checkhealth"><p>需要特别说明<code>healthcheck</code>部分：</p><ul><li>healthcheck启动协程对管理的devices进行健康状态监控，一旦发现有device unhealthy，则发送到NvidiaDevicePlugin的health channel。device plugin的ListAndWatch会从health channel中获取这些unhealthy devices，并通知到kubelet进行更新。</li><li>只监控<code>EventTypeXidCriticalError</code>事件，一旦监控到某个device的这个Event，就认为该device unhealthy。关于<code>EventTypeXidCriticalError</code>的说明，请参考NVIDIA的<a href="https://docs.nvidia.com/deploy/nvml-api/group__nvmlEventType.html">nvml api文档</a>。</li><li>可以通过设置NVIDIA device plugin Pod内的环境变量<code>DP_DISABLE_HEALTHCHECKS</code>为”all”来取消healthcheck。不设置或者设置为其他值都会启动healthcheck，默认部署时不设置。</li></ul><h2 id="stopPlugins"><a href="#stopPlugins" class="headerlink" title="stopPlugins"></a>stopPlugins</h2><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/main.go#275</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Stop() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> plugin == <span class="literal">nil</span> || plugin.server == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Stopping to serve &#x27;%s&#x27; on %s&quot;</span>, plugin.rm.Resource(), plugin.socket)</span><br><span class="line">plugin.server.Stop()</span><br><span class="line"><span class="keyword">if</span> err := os.Remove(plugin.socket); err != <span class="literal">nil</span> &amp;&amp; !os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">plugin.cleanup()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/06/46/stop-plugins.png" class="" title="stop-plugins"><p>stopPlugins主要做三件事：</p><ol><li>停止 device-plugin 的 grpc server</li><li>移除 plugin socket 文件 （/var/lib/kubelet/device-plugins/nvidia-gpu.sock）</li><li>清空 nvidiaDevicePlugin 相关字段。（plugin.server=nil; plugin.health=nil; plugin.stop=nil）</li></ol><h2 id="ListAndWatch"><a href="#ListAndWatch" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h2><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#219</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> ListAndWatch(e *pluginapi.Empty, s pluginapi.DevicePlugin_ListAndWatchServer) <span class="type">error</span> &#123;</span><br><span class="line">s.Send(&amp;pluginapi.ListAndWatchResponse&#123;Devices: plugin.apiDevices()&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-plugin.stop:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> d := &lt;-plugin.health:</span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> there is no way to recover from the Unhealthy state.</span></span><br><span class="line">d.Health = pluginapi.Unhealthy</span><br><span class="line">log.Printf(<span class="string">&quot;&#x27;%s&#x27; device marked unhealthy: %s&quot;</span>, plugin.rm.Resource(), d.ID)</span><br><span class="line">s.Send(&amp;pluginapi.ListAndWatchResponse&#123;Devices: plugin.apiDevices()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>listAndWatch 的实现流程图如下：</p><img src="/2023/01/06/46/listAndWatch.png" class="" title="listAndWatch"><h2 id="Allocate"><a href="#Allocate" class="headerlink" title="Allocate"></a>Allocate</h2><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#254</em></u></p><p>allocateRequest的请求结构体如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AllocateRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">ContainerRequests    []*ContainerAllocateRequest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ContainerAllocateRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">DevicesIDs           []<span class="type">string</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>allocateResponse的结构体如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AllocateResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">ContainerResponses   []*ContainerAllocateResponse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ContainerAllocateResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Envs                <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> </span><br><span class="line">Mounts              []*Mount </span><br><span class="line">Devices             []*DeviceSpec</span><br><span class="line">Annotations         <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Allocate 在容器创建期间调用，这样设备插件可以运行一些特定于设备的操作，并告诉 kubelet 如何令 Device 可在容器中访问的所需执行的具体步骤。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Allocate(ctx context.Context, reqs *pluginapi.AllocateRequest) (*pluginapi.AllocateResponse, <span class="type">error</span>) &#123;</span><br><span class="line">responses := pluginapi.AllocateResponse&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, req := <span class="keyword">range</span> reqs.ContainerRequests &#123;</span><br><span class="line"><span class="comment">// If the devices being allocated are replicas, then (conditionally)</span></span><br><span class="line"><span class="comment">// error out if more than one resource is being allocated.</span></span><br><span class="line"><span class="keyword">if</span> plugin.config.Sharing.TimeSlicing.FailRequestsGreaterThanOne &amp;&amp; rm.AnnotatedIDs(req.DevicesIDs).AnyHasAnnotations() &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(req.DevicesIDs) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;request for &#x27;%v: %v&#x27; too large: maximum request size for shared resources is 1&quot;</span>, plugin.rm.Resource(), <span class="built_in">len</span>(req.DevicesIDs))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, id := <span class="keyword">range</span> req.DevicesIDs &#123;</span><br><span class="line"><span class="keyword">if</span> !plugin.rm.Devices().Contains(id) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;invalid allocation request for &#x27;%s&#x27;: unknown device: %s&quot;</span>, plugin.rm.Resource(), id)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response := pluginapi.ContainerAllocateResponse&#123;&#125;</span><br><span class="line"></span><br><span class="line">ids := req.DevicesIDs</span><br><span class="line">deviceIDs := plugin.deviceIDsFromAnnotatedDeviceIDs(ids)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> *plugin.config.Flags.Plugin.DeviceListStrategy == spec.DeviceListStrategyEnvvar &#123;</span><br><span class="line">response.Envs = plugin.apiEnvs(plugin.deviceListEnvvar, deviceIDs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *plugin.config.Flags.Plugin.DeviceListStrategy == spec.DeviceListStrategyVolumeMounts &#123;</span><br><span class="line">response.Envs = plugin.apiEnvs(plugin.deviceListEnvvar, []<span class="type">string</span>&#123;deviceListAsVolumeMountsContainerPathRoot&#125;)</span><br><span class="line">response.Mounts = plugin.apiMounts(deviceIDs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *plugin.config.Flags.Plugin.PassDeviceSpecs &#123;</span><br><span class="line">response.Devices = plugin.apiDeviceSpecs(*plugin.config.Flags.NvidiaDriverRoot, ids)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *plugin.config.Flags.GDSEnabled &#123;</span><br><span class="line">response.Envs[<span class="string">&quot;NVIDIA_GDS&quot;</span>] = <span class="string">&quot;enabled&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *plugin.config.Flags.MOFEDEnabled &#123;</span><br><span class="line">response.Envs[<span class="string">&quot;NVIDIA_MOFED&quot;</span>] = <span class="string">&quot;enabled&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">responses.ContainerResponses = <span class="built_in">append</span>(responses.ContainerResponses, &amp;response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;responses, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/06/46/allocate.png" class="" title="allocate"><ul><li>Allocate中会遍历ContainerRequests，将DeviceIDs封装到ContainerAllocateResponse的<code>Envs:NVIDIA_VISIBLE_DEVICES</code>中，格式为：”<code>$&#123;ID_1&#125;,$&#123;ID_2&#125;,...</code>”</li><li>除此之外，并没有封装Mounts, Devices, Annotations。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>NVIDIA/k8s-device-plugin的代码中，依赖于nvidia-docker代码库，存在很多golang调用C库的地方，还需要大家自行到 <a href="https://docs.nvidia.com/deploy/nvml-api">nvml api文档</a> 中查看相关C函数声明。这篇博客介绍NVIDIA/k8s-device-plugin的代码实现流程，下一篇博客我觉得还有必要对kubelet device plugin manger进行代码分析，如此才能完整的理解整个交互细节。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;device-plugin启动&quot;&gt;&lt;a href=&quot;#device-plugin启动&quot; class=&quot;headerlink&quot; title=&quot;device-plugin启动&quot;&gt;&lt;/a&gt;device-plugin启动&lt;/h1&gt;&lt;p&gt;该篇文章基于NVIDIA/k8s-d</summary>
      
    
    
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/categories/device-plugins/"/>
    
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/tags/device-plugins/"/>
    
    <category term="nvidia" scheme="http://lizhewei91.github.io/tags/nvidia/"/>
    
    <category term="gpu" scheme="http://lizhewei91.github.io/tags/gpu/"/>
    
  </entry>
  
  <entry>
    <title>浅谈k8s中device-plugins机制</title>
    <link href="http://lizhewei91.github.io/2022/11/29/16/"/>
    <id>http://lizhewei91.github.io/2022/11/29/16/</id>
    <published>2022-11-29T02:53:16.000Z</published>
    <updated>2023-01-06T07:31:40.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Extended-Resource"><a href="#Extended-Resource" class="headerlink" title="Extended Resource"></a>Extended Resource</h1><p>官方链接：<a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/extended-resource-node/">extended-resource-node</a></p><p><strong>特性状态</strong>： <code>Kubernetes v1.9 [stable]</code></p><p>可以用一句话来概括这个特性：通过向apiserver发送一个 patch node 的请求，为这个node增加一个自定义的资源类型，用于以该资源的配额统计和相应的QoS的配置。</p><h2 id="为节点增加扩展资源"><a href="#为节点增加扩展资源" class="headerlink" title="为节点增加扩展资源"></a>为节点增加扩展资源</h2><p>为在一个节点上发布一种新的扩展资源，需要发送一个 HTTP PATCH 请求到 Kubernetes API server。 例如：假设你的一个节点上带有四个 dongle 资源。 下面是一个 PATCH 请求的示例，该请求为你的节点发布四个 dongle 资源。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/json-patch+json</span><br><span class="line">Host: k8s-master:8080</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;op&quot;: &quot;add&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;4&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>注意：Kubernetes 不需要了解 dongle 资源的含义和用途。 前面的 PATCH 请求告诉 Kubernetes 你的节点拥有四个你称之为 dongle 的东西。</p></blockquote><p>启动一个代理（proxy），以便你可以很容易地向 Kubernetes API server 发送请求：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure><p>在另一个命令窗口中，发送 HTTP PATCH 请求。 用你的节点名称替换 <code>&lt;your-node-name&gt;</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --header &quot;Content-Type: application/json-patch+json&quot; \</span><br><span class="line">  --request PATCH \</span><br><span class="line">  --data &#x27;[&#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;, &quot;value&quot;: &quot;4&quot;&#125;]&#x27; \</span><br><span class="line">  http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong> 在前面的请求中，<code>~1</code> 为 patch 路径中 “/” 符号的编码。 JSON-Patch 中的操作路径值被解析为 JSON 指针。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl describe node &lt;your-node-name&gt;</span><br></pre></td></tr></table></figure><img src="/2022/11/29/16/image-20221129110411083.png" class="" title="image-20221129110411083"><h2 id="清理扩展资源"><a href="#清理扩展资源" class="headerlink" title="清理扩展资源"></a>清理扩展资源</h2><p>这里是一个从节点移除 dongle 资源发布的 PATCH 请求。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/json-patch+json</span><br><span class="line">Host: k8s-master:8080</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;op&quot;: &quot;remove&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>启动一个代理，以便你可以很容易地向 Kubernetes API 服务器发送请求：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure><p>在另一个命令窗口中，发送 HTTP PATCH 请求。用你的节点名称替换 <code>&lt;your-node-name&gt;</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --header &quot;Content-Type: application/json-patch+json&quot; \</span><br><span class="line">--request PATCH \</span><br><span class="line">--data &#x27;[&#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;&#125;]&#x27; \</span><br><span class="line">http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status</span><br></pre></td></tr></table></figure><p>验证 dongle 资源的发布已经被移除：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl describe node &lt;your-node-name&gt; | grep dongle</span><br></pre></td></tr></table></figure><p>(你应该看不到任何输出)</p><blockquote><p>扩展资源是 <code>kubernetes.io</code> 域名之外的标准资源名称。 它们使得集群管理员能够颁布非 Kubernetes 内置资源，而用户可以使用他们。</p><p>使用扩展资源需要两个步骤。首先，集群管理员必须颁布扩展资源。 其次，用户必须在 Pod 中请求扩展资源。</p></blockquote><h1 id="Device-Plugins"><a href="#Device-Plugins" class="headerlink" title="Device Plugins"></a>Device Plugins</h1><p>官方链接：<a href="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/">device-plugins</a></p><p><strong>特性状态：</strong> <code>Kubernetes v1.26 [stable]</code></p><p>Kubernetes 提供了一个 <a href="https://git.k8s.io/design-proposals-archive/resource-management/device-plugin.md">设备插件框架</a>， 你可以用它来将系统硬件资源发布到 <a href="https://kubernetes.io/docs/reference/generated/kubelet">Kubelet</a>。</p><p>供应商可以实现设备插件，由你手动部署或作为 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a> 来部署，而不必定制 Kubernetes 本身的代码。目标设备包括 GPU、高性能 NIC、FPGA、 InfiniBand 适配器以及其他类似的、可能需要特定于供应商的初始化和设置的计算资源。</p><h2 id="设备插件框架"><a href="#设备插件框架" class="headerlink" title="设备插件框架"></a>设备插件框架</h2><img src="/2022/11/29/16/device-plugin-overview.png" class="" title="Process"><p>设备插件的常规工作流程包括以下几个步骤：</p><ul><li>初始化。在这个阶段，设备插件将执行供应商特定的初始化和设置， 以确保设备处于就绪状态。</li><li>插件使用主机路径 <code>/var/lib/kubelet/device-plugins/</code> 下的 Unix 套接字启动一个 gRPC 服务，如：<code>/var/lib/kubelet/device-plugins/nvidia-gpu.sock</code>，该服务实现以下接口：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service DevicePlugin &#123;</span><br><span class="line">    // GetDevicePluginOptions 返回与设备管理器沟通的选项。</span><br><span class="line">    rpc GetDevicePluginOptions(Empty) returns (DevicePluginOptions) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // ListAndWatch 返回 Device 列表构成的数据流。</span><br><span class="line">    // 当 Device 状态发生变化或者 Device 消失时，ListAndWatch</span><br><span class="line">    // 会返回新的列表。</span><br><span class="line">    rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // Allocate 在容器创建期间调用，这样设备插件可以运行一些特定于设备的操作，</span><br><span class="line">    // 并告诉 kubelet 如何令 Device 可在容器中访问的所需执行的具体步骤</span><br><span class="line">    rpc Allocate(AllocateRequest) returns (AllocateResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // GetPreferredAllocation 从一组可用的设备中返回一些优选的设备用来分配，</span><br><span class="line">    // 所返回的优选分配结果不一定会是设备管理器的最终分配方案。</span><br><span class="line">    // 此接口的设计仅是为了让设备管理器能够在可能的情况下做出更有意义的决定。</span><br><span class="line">    rpc GetPreferredAllocation(PreferredAllocationRequest) returns (PreferredAllocationResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // PreStartContainer 在设备插件注册阶段根据需要被调用，调用发生在容器启动之前。</span><br><span class="line">    // 在将设备提供给容器使用之前，设备插件可以运行一些诸如重置设备之类的特定于</span><br><span class="line">    // 具体设备的操作，</span><br><span class="line">    rpc PreStartContainer(PreStartContainerRequest) returns (PreStartContainerResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>插件通过 Unix socket 在主机路径 <code>/var/lib/kubelet/device-plugins/kubelet.sock</code> 处向 kubelet 注册自身。</p></li><li><p>成功注册自身后，设备插件将以服务模式运行，在此期间，它将持续监控设备运行状况， 并在设备状态发生任何变化时向 kubelet 报告。它还负责响应 <code>Allocate</code> gRPC 请求。 在 <code>Allocate</code> 期间，设备插件可能还会做一些设备特定的准备；例如 GPU 清理或 QRNG 初始化。 如果操作成功，则设备插件将返回 <code>AllocateResponse</code>，其中包含用于访问被分配的设备容器运行时的配置。 kubelet 将此信息传递到容器运行时。</p></li></ul><h3 id="处理-kubelet-重启"><a href="#处理-kubelet-重启" class="headerlink" title="处理 kubelet 重启"></a>处理 kubelet 重启</h3><ul><li>设备插件应能监测到 kubelet 重启，并且向新的 kubelet 实例来重新注册自己。 新的 kubelet 实例启动时会删除 <code>/var/lib/kubelet/device-plugins</code> 下所有已经存在的 Unix 套接字。 </li><li>设备插件需要能够监控到它的 Unix 套接字被删除，并且当发生此类事件时重新注册自己。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Extended-Resource&quot;&gt;&lt;a href=&quot;#Extended-Resource&quot; class=&quot;headerlink&quot; title=&quot;Extended Resource&quot;&gt;&lt;/a&gt;Extended Resource&lt;/h1&gt;&lt;p&gt;官方链接：&lt;a hr</summary>
      
    
    
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/categories/device-plugins/"/>
    
    
    <category term="kubernetnes" scheme="http://lizhewei91.github.io/tags/kubernetnes/"/>
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/tags/device-plugins/"/>
    
  </entry>
  
  <entry>
    <title>hexo+typora图片插入</title>
    <link href="http://lizhewei91.github.io/2022/11/28/29/"/>
    <id>http://lizhewei91.github.io/2022/11/28/29/</id>
    <published>2022-11-28T14:46:29.000Z</published>
    <updated>2022-11-28T14:52:49.556Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>Typora设置</strong>。点击文件-&gt;偏好设置-&gt;图像，配置插入图片问复制到指定路径，底下三个勾都选，如下图所示。</li></ol><img src="/2022/11/28/29/image-20220611231725568.png" class="" title="img"><ol start="2"><li><p><strong>Hexo配置</strong>。在根目录下，进入bash命令框，输入<code>npm install hexo-image-link --save</code>安装插件。</p></li><li><p><strong>更改根目录下_config.yml配置</strong>，找到<code>post_asset_folder</code>，改为true。</p></li><li><p>写文章前，在根目录bash命令框中输入<code>hexo new 文章题目</code>，可以自动在post文件夹中生成<code>文章题目.md</code>与<code>文章题目</code>图片存储目录了。</p></li><li><p>这样就<strong>配置成功</strong>了。写文章之前，现在你可以把图片像word编辑一样<strong>拖动</strong>到typora直接预览，该过程不需要输入什么图片插入指令呀存储路径呀啥的，也不需要专门去对图片进行转存；直接网页端预览，图片可以正常显示。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Typora设置&lt;/strong&gt;。点击文件-&amp;gt;偏好设置-&amp;gt;图像，配置插入图片问复制到指定路径，底下三个勾都选，如下图所示。&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&quot;/2022/11/28/29/image-202206112317</summary>
      
    
    
    
    <category term="hexo" scheme="http://lizhewei91.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://lizhewei91.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>性能剖析大杀器 pprof</title>
    <link href="http://lizhewei91.github.io/2022/11/28/56/"/>
    <id>http://lizhewei91.github.io/2022/11/28/56/</id>
    <published>2022-11-28T12:28:56.000Z</published>
    <updated>2022-12-01T07:36:27.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h1><p>在 Go 语言中，PProf 是用于可视化和分析性能分析数据的工具，pprof 以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）。</p><p>而刚刚提到的 profile.proto 是一个 Protobuf v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式。</p><h2 id="可以做什么"><a href="#可以做什么" class="headerlink" title="可以做什么"></a>可以做什么</h2><ul><li><strong>CPU Profiling</strong>：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。</li><li><strong>Memory Profiling</strong>：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。</li><li><strong>Block Profiling</strong>：阻塞分析，记录Goroutine阻塞等待同步（包括定时器通道）的位置，默认不开启，需要调用 <code>runtime.SetBlockProfileRate</code>进行设置。</li><li><strong>Mutex Profiling</strong>：互斥锁分析，报告互斥锁的竞争情况，默认不开启，需要调用 <code>runtime.SetMutexProfileFraction </code>进行设置。</li><li><strong>Goroutine Profiling</strong>：Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。</li></ul><p>其中像是 Goroutine Profiling 这项功能会在实际排查中会经常用到。因为很多问题出现时的表象就是 Goroutine 暴增，而这时候我们要做的事情之一就是查看应用程序中的 Goroutine 正在做什么事情，因为什么阻塞了，然后再进行下一步。</p><h2 id="采样方式"><a href="#采样方式" class="headerlink" title="采样方式"></a>采样方式</h2><ul><li><strong>runtime/pprof</strong>：采集程序（非 Server）的指定区块的运行数据进行分析。</li><li><strong>net/http/pprof</strong>：基于HTTP Server运行，并且可以采集运行时数据进行分析。</li><li><strong>go test</strong>：通过运行测试用例，并指定所需标识来进行采集。</li></ul><h2 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h2><ul><li>Report generation：报告生成。</li><li>Interactive terminal use：交互式终端使用。</li><li>Web interface：Web 界面。</li></ul><h1 id="服务型应用"><a href="#服务型应用" class="headerlink" title="服务型应用"></a>服务型应用</h1><p>如果你的应用程序是一直运行的，比如 web 应用，那么可以使用<code>net/http/pprof</code>库，它能够在提供 HTTP 服务进行分析。</p><p>如果使用了默认的 <code>http.DefaultServeMux</code>（通常是代码直接使用 <code>http.ListenAndServe(“0.0.0.0:8080”, nil)</code>），只需要在你的web server端代码中按如下方式导入<code>net/http/pprof</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span> </span><br></pre></td></tr></table></figure><h2 id="为什么要初始化net-http-pprof"><a href="#为什么要初始化net-http-pprof" class="headerlink" title="为什么要初始化net/http/pprof"></a>为什么要初始化net/http/pprof</h2><p>在我们的例子中，你会发现我们在引用上对 <code>net/http/pprof</code>包进行了默认的初始化（也就是 _），如果你曾经漏了，或者没加，你会发现压根调用不了 pprof 的相关接口，这是为什么呢，我们一起看看下面该包的初始化方法，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/&quot;</span>, Index)</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/cmdline&quot;</span>, Cmdline)</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/profile&quot;</span>, Profile)</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/symbol&quot;</span>, Symbol)</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/trace&quot;</span>, Trace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 <code>net/http/pprof</code>会在初始化函数中对标准库中<code>net/http</code>所默认提供的 <code>DefaultServeMux</code> 进行路由注册，源码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line"> DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们在例子中使用的 HTTP Server，也是使用的标准库中默认提供的，因此便完美的结合在了一起，这也恰好也是最小示例的模式。</p><p>这时候你可能会注意到另外一个问题，那就是我们的实际项目中，都是有相对独立的 ServeMux 的，这时候我们只要仿照着将 pprof 对应的路由注册进去就好了，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/&quot;</span>, pprof.Index)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/cmdline&quot;</span>, pprof.Cmdline)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/profile&quot;</span>, pprof.Profile)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/symbol&quot;</span>, pprof.Symbol)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/trace&quot;</span>, pprof.Trace)</span><br></pre></td></tr></table></figure><p>如果你使用的是gin框架，那么推荐使用 <a href="https://github.com/gin-contrib/pprof">github.com/gin-contrib/pprof</a>，在代码中通过以下命令注册 pprof 相关路由。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.Register(router)</span><br></pre></td></tr></table></figure><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> datas []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;len:%d\n&quot;</span>, Add(str))</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">_ = http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">datas = <span class="built_in">append</span>(datas, str)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(datas)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们运行这个程序，访问 <code>http://127.0.0.1:8080/debug/pprof/</code> 地址，检查是否正常响应。</p><h3 id="通过浏览器访问"><a href="#通过浏览器访问" class="headerlink" title="通过浏览器访问"></a>通过浏览器访问</h3><p>第一种方式，我们可以直接通过浏览器，进行查看，那么在第一步我们可以先查看总览页面，也就是访问 <code>http://127.0.0.1:8080/debug/pprof/</code>，如下：    </p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/debug/pprof/</span><br><span class="line"></span><br><span class="line">Types of profiles available:</span><br><span class="line">CountProfile</span><br><span class="line"><span class="number">3</span>allocs</span><br><span class="line"><span class="number">0</span>block</span><br><span class="line"><span class="number">0</span>cmdline</span><br><span class="line"><span class="number">5</span>goroutine</span><br><span class="line"><span class="number">3</span>heap</span><br><span class="line"><span class="number">0</span>mutex</span><br><span class="line"><span class="number">0</span>profile</span><br><span class="line"><span class="number">8</span>threadcreate</span><br><span class="line"><span class="number">0</span>trace</span><br><span class="line">full goroutine stack dump</span><br></pre></td></tr></table></figure><ul><li><strong>allocs</strong>：查看过去所有内存分配的样本，访问路径为<code>$HOST/debug/pprof/allocs</code>。</li><li><strong>block</strong>：查看导致阻塞同步的堆栈跟踪，访问路径为<code>$HOST/debug/pprof/block</code>。</li><li><strong>cmdline</strong>：当前程序的命令行的完整调用路径，访问路径为<code>$HOST/debug/pprof/cmdline</code>。</li><li><strong>goroutine</strong>：查看当前所有运行的 goroutines 堆栈跟踪，访问路径为<code>$HOST/debug/pprof/goroutine</code>。</li><li><strong>heap</strong>：查看活动对象的内存分配情况， 访问路径为<code>$HOST/debug/pprof/heap</code>。</li><li><strong>mutex</strong>：查看导致互斥锁的竞争持有者的堆栈跟踪，访问路径为<code>$HOST/debug/pprof/mutex</code>。</li><li><strong>profile</strong>：默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件，访问路径为<code>$HOST/debug/pprof/profile</code>。</li><li><strong>threadcreate</strong>：查看创建新OS线程的堆栈跟踪，访问路径为<code>$HOST/debug/pprof/threadcreate</code>。</li></ul><p>如果在相应的路径上加“<code>?debug=1</code>”，则可以直接在浏览器中访问，如图所示：</p><img src="/2022/11/28/56/1639809085480-2c7d9448-375f-4b98-913e-81020195a0c6-20221128222049403.png" class="" title="image.png"><blockquote><p>若不新增debug参数，则会直接下载对应的profile文件。</p><p><strong>注意：</strong>debug的访问方式具有时效性，在实际场景中，我们通常将profile文件保存下来，便于二次分析。</p></blockquote><h3 id="通过交互式终端使用"><a href="#通过交互式终端使用" class="headerlink" title="通过交互式终端使用"></a>通过交互式终端使用</h3><h4 id="CPU-Profiling"><a href="#CPU-Profiling" class="headerlink" title="CPU Profiling"></a>CPU Profiling</h4><p>第二种方式，我们可以直接通过命令行，来完成对正在运行的应用程序 pprof 的抓取和分析。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/profile?seconds=60</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:6060/debug/pprof/profile?seconds=60</span></span><br><span class="line">Saved profile in /Users/eddycjy/pprof/pprof.samples.cpu<span class="number">.002</span>.pb.gz</span><br><span class="line">Type: cpu</span><br><span class="line">Duration: <span class="number">1</span>mins, Total samples = <span class="number">37.25</span>s (<span class="number">61.97</span>%)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure><p>执行该命令后，需等待 60 秒（可调整 seconds 的值），pprof 会进行 CPU Profiling，结束后将默认进入 pprof 的命令行交互式模式，可以对分析的结果进行查看或导出。另外如果你所启动的 HTTP Server 是 TLS 的方式，那么在调用<code>go tool pprof</code> 时，需要将调用路径改为：<code>go tool pprof https+insecure://localhost:8080/debug/pprof/profile\?seconds\=60</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) top10</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">1.38</span>s, <span class="number">100</span>% of <span class="number">1.38</span>s total</span><br><span class="line">Showing top <span class="number">10</span> nodes out of <span class="number">50</span></span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     <span class="number">0.60</span>s <span class="number">43.48</span>% <span class="number">43.48</span>%      <span class="number">0.80</span>s <span class="number">57.97</span>%  runtime.kevent</span><br><span class="line">     <span class="number">0.31</span>s <span class="number">22.46</span>% <span class="number">65.94</span>%      <span class="number">0.31</span>s <span class="number">22.46</span>%  runtime.libcCall</span><br><span class="line">     <span class="number">0.21</span>s <span class="number">15.22</span>% <span class="number">81.16</span>%      <span class="number">0.22</span>s <span class="number">15.94</span>%  syscall.syscall</span><br><span class="line">     <span class="number">0.15</span>s <span class="number">10.87</span>% <span class="number">92.03</span>%      <span class="number">0.26</span>s <span class="number">18.84</span>%  runtime.pthread_cond_wait</span><br><span class="line">     <span class="number">0.04</span>s  <span class="number">2.90</span>% <span class="number">94.93</span>%      <span class="number">0.04</span>s  <span class="number">2.90</span>%  runtime.pthread_cond_signal</span><br><span class="line">     <span class="number">0.02</span>s  <span class="number">1.45</span>% <span class="number">96.38</span>%      <span class="number">0.02</span>s  <span class="number">1.45</span>%  runtime.walltime</span><br><span class="line">     <span class="number">0.02</span>s  <span class="number">1.45</span>% <span class="number">97.83</span>%      <span class="number">0.02</span>s  <span class="number">1.45</span>%  runtime.write1</span><br><span class="line">     <span class="number">0.01</span>s  <span class="number">0.72</span>% <span class="number">98.55</span>%      <span class="number">0.01</span>s  <span class="number">0.72</span>%  log.itoa</span><br><span class="line">     <span class="number">0.01</span>s  <span class="number">0.72</span>% <span class="number">99.28</span>%      <span class="number">0.01</span>s  <span class="number">0.72</span>%  runtime.(*mcache).prepareForSweep</span><br><span class="line">     <span class="number">0.01</span>s  <span class="number">0.72</span>%   <span class="number">100</span>%      <span class="number">0.01</span>s  <span class="number">0.72</span>%  runtime.memmove</span><br></pre></td></tr></table></figure><ul><li>flat：函数自身的运行耗时。</li><li>flat%：函数自身在 CPU 运行耗时总比例。</li><li>sum%：函数自身累积使用 CPU 总比例。</li><li>cum：函数自身及其调用函数的运行总耗时。</li><li>cum%：函数自身及其调用函数的运行耗时总比例。</li><li>Name：函数名。</li></ul><p>在大多数的情况下，我们可以通过这五列得出一个应用程序的运行情况，知道当前是什么函数，正在做什么事情，占用了多少资源，谁又是占用资源的大头，以此来得到一个初步的分析方向。</p><blockquote><p>另外在交互命令行中，pprof 还支持了大量的其它命令，具体可执行 pprof help 查看帮助说明。</p></blockquote><h4 id="Heap-Profiling"><a href="#Heap-Profiling" class="headerlink" title="Heap Profiling"></a>Heap Profiling</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.001</span>.pb.gz</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">4</span>:<span class="number">56</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) </span><br></pre></td></tr></table></figure><p>执行该命令后，能够很快的拉取到其结果，因为它不需要像 CPU Profiling 做采样等待，这里需要注意的一点是 <code>Type</code> 这一个选项，你可以看到它默认显示的是 <code>inuse_space</code>，实际上可以针对多种内存概况进行分析，常用的类别如下：</p><p>一共有四种类型：</p><ol><li><strong>inuse_space</strong>：分析应用程序的常驻内存占用情况。</li><li><strong>alloc_objects</strong>：分析应用程序的内存临时分配情况。</li><li><strong>inuse_objects</strong>：查看每个函数所分别的对象数量。</li><li><strong>alloc_space</strong>：查看分配的内存空间大小。</li></ol><ul><li>inuse_space：分析应用程序的常驻内存占用情况。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$  <span class="keyword">go</span> tool pprof -inuse_space http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.002</span>.pb.gz</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">4</span>:<span class="number">59</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">4130.49</span>kB, <span class="number">100</span>% of <span class="number">4130.49</span>kB total</span><br><span class="line">Showing top <span class="number">10</span> nodes out of <span class="number">20</span></span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line"> <span class="number">1567.04</span>kB <span class="number">37.94</span>% <span class="number">37.94</span>%  <span class="number">1567.04</span>kB <span class="number">37.94</span>%  main.Add (inline)</span><br><span class="line"> <span class="number">1537.69</span>kB <span class="number">37.23</span>% <span class="number">75.17</span>%  <span class="number">1537.69</span>kB <span class="number">37.23</span>%  runtime.allocm</span><br><span class="line">  <span class="number">513.56</span>kB <span class="number">12.43</span>% <span class="number">87.60</span>%   <span class="number">513.56</span>kB <span class="number">12.43</span>%  regexp/syntax.init</span><br><span class="line">  <span class="number">512.20</span>kB <span class="number">12.40</span>%   <span class="number">100</span>%   <span class="number">512.20</span>kB <span class="number">12.40</span>%  runtime.malg</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%  <span class="number">1567.04</span>kB <span class="number">37.94</span>%  main.main.func1</span><br></pre></td></tr></table></figure><ul><li>alloc_objects：分析应用程序的内存临时分配情况。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof -alloc_objects http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.003</span>.pb.gz</span><br><span class="line">Type: alloc_objects</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">5</span>:<span class="number">01</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">311313</span>, <span class="number">99.07</span>% of <span class="number">314251</span> total</span><br><span class="line">Dropped <span class="number">39</span> nodes (cum &lt;= <span class="number">1571</span>)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    <span class="number">163842</span> <span class="number">52.14</span>% <span class="number">52.14</span>%     <span class="number">311313</span> <span class="number">99.07</span>%  main.main.func1</span><br><span class="line">    <span class="number">131074</span> <span class="number">41.71</span>% <span class="number">93.85</span>%     <span class="number">131074</span> <span class="number">41.71</span>%  fmt.Sprintf</span><br><span class="line">     <span class="number">16397</span>  <span class="number">5.22</span>% <span class="number">99.07</span>%      <span class="number">16397</span>  <span class="number">5.22</span>%  main.Add (inline)</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>% <span class="number">99.07</span>%     <span class="number">131074</span> <span class="number">41.71</span>%  log.Printf</span><br></pre></td></tr></table></figure><p>另外还有 inuse_objects 和 alloc_space 类别，分别对应查看每个函数所分别的对象数量和查看分配的内存空间大小，具体可根据情况选用。</p><h4 id="Goroutine-Profiling"><a href="#Goroutine-Profiling" class="headerlink" title="Goroutine Profiling"></a>Goroutine Profiling</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/goroutine</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8080/debug/pprof/goroutine</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.goroutine<span class="number">.001</span>.pb.gz</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">5</span>:<span class="number">04</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) </span><br></pre></td></tr></table></figure><p>在查看 goroutine 时，我们可以使用 traces 命令，这个命令会打印出对应的所有调用栈，以及指标信息，可以让我们很便捷的查看到整个调用链路有什么，分别在哪里使用了多少个 goroutine，并且能够通过分析查看到谁才是真正的调用方，输出结果如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) traces</span><br><span class="line">Type: goroutine</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">         <span class="number">2</span>   runtime.gopark</span><br><span class="line">             runtime.netpollblock</span><br><span class="line">             internal/poll.runtime_pollWait</span><br><span class="line">             ...</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">         <span class="number">1</span>   runtime.gopark</span><br><span class="line">             runtime.netpollblock</span><br><span class="line">             ...</span><br><span class="line">             net/http.ListenAndServe</span><br><span class="line">             main.main</span><br><span class="line">             runtime.main</span><br></pre></td></tr></table></figure><p>在调用栈上来讲，其展示顺序是<strong>自下而上</strong>的，也就是 <code>runtime.main</code> 方法调用了 <code>main.main</code> 方法，<code>main.main</code> 方法又调用了 <code>net/http.ListenAndServe</code> 方法，这里对应的也就是我们所使用的示例代码了，排查起来会非常方便。</p><p>每个调用堆栈信息用 <code>-----------</code> 分割，函数方法前的就是指标数据，像 Goroutine Profiling 展示是就是该方法占用的 goroutine 的数量。而 Heap Profiling 展示的就是占用的内存大小，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">...</span><br><span class="line">Type: inuse_space</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) traces</span><br><span class="line">Type: inuse_space</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  <span class="number">13.55</span>MB</span><br><span class="line">   <span class="number">13.55</span>MB   main.Add</span><br><span class="line">             main.main.func1</span><br><span class="line">-----------+-------------------------------------------------------</span><br></pre></td></tr></table></figure><h4 id="Mutex-Profiling"><a href="#Mutex-Profiling" class="headerlink" title="Mutex Profiling"></a>Mutex Profiling</h4><p>怎么样的情况下会造成阻塞呢，一般有如下方式：调用 chan（通道）、调用 <code>sync.Mutex</code> （同步锁）、调用 <code>time.Sleep()</code> 等等。那么为了验证互斥锁的竞争持有者的堆栈跟踪，我们可以根据以上的 <code>sync.Mutex</code> 方式，来调整先前的示例代码，代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"> runtime.SetMutexProfileFraction(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> m sync.Mutex</span><br><span class="line"> <span class="keyword">var</span> datas = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">999</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   m.Lock()</span><br><span class="line">   <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">   datas[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">  &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> _ = http.ListenAndServe(<span class="string">&quot;:6061&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别注意的是 <code>runtime.SetMutexProfileFraction</code> 语句，如果未来希望进行互斥锁的采集，那么需要通过调用该方法来设置采集频率，若不设置或没有设置大于 0 的数值，默认是不进行采集的。</p><p>接下来我们进行调用 <code>go tool pprof</code> 进行分析，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8081/debug/pprof/mutex</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8081/debug/pprof/mutex</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.contentions.delay<span class="number">.002</span>.pb.gz</span><br><span class="line">Type: delay</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">5</span>:<span class="number">18</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) </span><br></pre></td></tr></table></figure><p>我们查看调用 top 命令，查看互斥量的排名：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">1.77</span>ms, <span class="number">100</span>% of <span class="number">1.77</span>ms total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    <span class="number">1.77</span>ms   <span class="number">100</span>%   <span class="number">100</span>%     <span class="number">1.77</span>ms   <span class="number">100</span>%  sync.(*Mutex).Unlock</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%     <span class="number">1.77</span>ms   <span class="number">100</span>%  main.main.func1</span><br></pre></td></tr></table></figure><p>接下来我们可以调用 list 命令，看到指定函数的代码情况（包含特定的指标信息，例如：耗时），若函数名不明确，默认会对函数名进行模糊匹配，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) list main</span><br><span class="line">Total: <span class="number">1.77</span>ms</span><br><span class="line">ROUTINE ======================== main.main.func1 in /Volumes/D/<span class="keyword">go</span>/src/github.com/lizw91/pprof/main.<span class="keyword">go</span></span><br><span class="line">         <span class="number">0</span>     <span class="number">1.77</span>ms (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">17</span>:   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">         .          .     <span class="number">18</span>:           <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">         .          .     <span class="number">19</span>:                   m.Lock()</span><br><span class="line">         .          .     <span class="number">20</span>:                   <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">         .          .     <span class="number">21</span>:                   datas[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">         .     <span class="number">1.77</span>ms     <span class="number">22</span>:           &#125;(i)</span><br><span class="line">         .          .     <span class="number">23</span>:   &#125;</span><br><span class="line">         .          .     <span class="number">24</span>:</span><br><span class="line">         .          .     <span class="number">25</span>:   _ = http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">         .          .     <span class="number">26</span>:&#125;</span><br></pre></td></tr></table></figure><p>我们可以在输出的分析中比较准确的看到引起互斥锁的函数在哪里，锁开销在哪里，在本例中是第 22 行。</p><h4 id="Block-Profiling"><a href="#Block-Profiling" class="headerlink" title="Block Profiling"></a>Block Profiling</h4><p>与 Mutex 的 <code>runtime.SetMutexProfileFraction</code> 相似，Block 也需要调用 <code>runtime.SetBlockProfileRate()</code> 进行采集量的设置，否则默认关闭，若设置的值小于等于 0 也会认为是关闭。</p><p>与上小节 Mutex 相比，主体代码不变，仅是新增 <code>runtime.SetBlockProfileRate()</code>的调用，如下：</p><p><strong>示例代码</strong> </p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.SetBlockProfileRate(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m sync.Mutex</span><br><span class="line"><span class="keyword">var</span> datas = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">m.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.Unlock()</span><br><span class="line">datas[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_ = http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们查看调用 top 命令，查看阻塞情况的排名：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8081/debug/pprof/block</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8081/debug/pprof/block</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.contentions.delay<span class="number">.003</span>.pb.gz</span><br><span class="line">Type: delay</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">5</span>:<span class="number">21</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">48.97</span>ms, <span class="number">100</span>% of <span class="number">48.97</span>ms total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">   <span class="number">48.97</span>ms   <span class="number">100</span>%   <span class="number">100</span>%    <span class="number">48.97</span>ms   <span class="number">100</span>%  sync.(*Mutex).Lock (inline)</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%    <span class="number">48.97</span>ms   <span class="number">100</span>%  main.main.func1</span><br></pre></td></tr></table></figure><p>同样的，我们也可以调用 list 命令查看具体的阻塞情况，执行方式和排查模式与先前概述的一致。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) list main</span><br><span class="line">Total: <span class="number">48.97</span>ms</span><br><span class="line">ROUTINE ======================== main.main.func1 in /Volumes/D/<span class="keyword">go</span>/src/github.com/lizw91/pprof/main.<span class="keyword">go</span></span><br><span class="line">         <span class="number">0</span>    <span class="number">48.97</span>ms (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">14</span>:<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">         .          .     <span class="number">15</span>:   <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">         .          .     <span class="number">16</span>:   <span class="keyword">var</span> datas = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">         .          .     <span class="number">17</span>:   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">         .          .     <span class="number">18</span>:           <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">         .    <span class="number">48.97</span>ms     <span class="number">19</span>:                   m.Lock()</span><br><span class="line">         .          .     <span class="number">20</span>:                   <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">         .          .     <span class="number">21</span>:                   datas[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">         .          .     <span class="number">22</span>:           &#125;(i)</span><br><span class="line">         .          .     <span class="number">23</span>:   &#125;</span><br><span class="line">         .          .     <span class="number">24</span>:</span><br></pre></td></tr></table></figure><h3 id="查看可视化界面"><a href="#查看可视化界面" class="headerlink" title="查看可视化界面"></a>查看可视化界面</h3><p>接下来我们继续使用前面的示例程序，将其重新运行起来，然后在其它窗口执行下述命令：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 cpu 指标</span></span><br><span class="line">$ wget -O cpu.profile http:<span class="comment">//127.0.0.1:8080/debug/pprof/profile?seconds=30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 heap 指标 </span></span><br><span class="line">$ wget -O mem.profile http:<span class="comment">//127.0.0.1:8080/debug/pprof/profile?seconds=30</span></span><br></pre></td></tr></table></figure><p>默认需要等待 30 秒，执行完毕后可在当前目录下发现采集的文件 cpu.profile，针对可视化界面我们有两种方式可进行下一步分析：</p><ol><li>方法一<strong>（推荐）</strong>：该命令将在所指定的端口号运行一个 pprof 的分析用的站点</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof -http=:<span class="number">8081</span> cpu.profile  </span><br></pre></td></tr></table></figure><ol><li>方法二：通过 web 命令将以 svg 的文件格式写入图形，然后在 Web 浏览器中将其打开。</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof cpu.profile</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Feb <span class="number">1</span>, <span class="number">2020</span> at <span class="number">12</span>:<span class="number">09</span>pm (CST)</span><br><span class="line">Duration: <span class="number">30</span>s, Total samples = <span class="number">60</span>ms (  <span class="number">0.2</span>%)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) web</span><br></pre></td></tr></table></figure><blockquote><p>如果出现错误提示 Could not execute dot; may need to install graphviz.，那么意味着你需要安装 graphviz组件。</p><p>另外方法一所运行的站点，实际上包含了方法二的内容（svg图片），并且更灵活，因此非特殊情况，我们会直接使用方法一的方式运行站点来做观察和分析。</p></blockquote><p>通过 pprof 所提供的可视化界面，我们能够更方便、更直观的看到 Go 应用程序的调用链、使用情况等。</p><p>另外在 View 菜单栏中，PProf 还支持多种分析方式的切换，如下：</p><img src="/2022/11/28/56/1639561832030-18ced959-237a-4a72-9121-a05850d0e4b9.png" class="" title="img"><p>view 菜单栏</p><p>接下来我们将基于 CPU Profiling 所抓取的 Profile 进行一一介绍，而其它 Profile 类型的分析模式也是互通的，只要我们了解了一种，其余的也就会了。</p><h4 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h4><img src="/2022/11/28/56/1639561878713-40879f4c-8c9b-429d-bff5-bcfdffc32fc1.png" class="" title="img"><ul><li>flat：函数自身的运行耗时。</li><li>flat%：函数自身在 CPU 运行耗时总比例。</li><li>sum%：函数自身累积使用 CPU 总比例。</li><li>cum：函数自身及其调用函数的运行总耗时。</li><li>cum%：函数自身及其调用函数的运行耗时总比例。</li><li>Name：函数名。</li></ul><h4 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h4><img src="/2022/11/28/56/1639561986430-2a11499e-5106-4273-8ce7-85caacd60ac0.png" class="" title="img"><p>该视图展示的为整体的函数调用流程，框越大、线越粗、框颜色越鲜艳（红色）就代表它占用的时间越久，开销越大。相反若框颜色越淡，越小则代表在整体的函数调用流程中，它的开销是相对较小的。因此我们可以用此视图去分析谁才是开销大头，它又是因为什么调用流程而被调用的。</p><h4 id="Peek"><a href="#Peek" class="headerlink" title="Peek"></a>Peek</h4><img src="/2022/11/28/56/1639562053535-d85c624d-78ca-4460-93a2-d46fdb060ca1.png" class="" title="img"><p>peek 栏目，此视图相较于 Top 视图，增加了所属的上下文信息的展示，也就是函数的输出调用者/被调用者。</p><h4 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h4><img src="/2022/11/28/56/1639562087329-46ed34bf-0b80-4510-bc2c-9dbf5b34a0da.png" class="" title="img"><p>source 栏目，该视图主要是增加了面向源代码的追踪和分析，可以看到其开销主要消耗在哪里。</p><h4 id="flame-graph"><a href="#flame-graph" class="headerlink" title="flame graph"></a>flame graph</h4><img src="/2022/11/28/56/1639568828478-ad6f5933-8572-4dbd-b73d-f637ba70a610-20221128223022437.png" class="" title="image.png"><p>Flame Graph（火焰图）它是可动态的，调用顺序由上到下（A -&gt; B -&gt; C -&gt; D），每一块代表一个函数、颜色越鲜艳（红）、区块越大代表占用 CPU 的时间更长。同时它也支持点击块深入进行分析。</p><p>我们选择页面上的 main.main.func1 区块，将会进入到其属下的下一层级，如下：</p><img src="/2022/11/28/56/1639568868468-031d2b33-b044-4827-a283-5bd689ab07d3-20221128223104007.png" class="" title="image.png"><p>进一步查看 flame graph，这样子我们就可以根据不同函数的多维度层级进行分析，能够更好的观察其流转并发现问题。</p><h1 id="工具型应用"><a href="#工具型应用" class="headerlink" title="工具型应用"></a>工具型应用</h1><p>如果你的应用程序是运行一段时间就结束退出类型。那么最好的办法是在应用退出的时候把 profiling 的报告保存到文件中，进行分析。对于这种情况，可以使用<code>runtime/pprof</code>库。 首先在代码中导入<code>runtime/pprof</code>工具：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;runtime/pprof&quot;</span></span><br></pre></td></tr></table></figure><h2 id="CPU性能分析"><a href="#CPU性能分析" class="headerlink" title="CPU性能分析"></a>CPU性能分析</h2><p>开启CPU性能分析：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.StartCPUProfile(w io.Writer) </span><br></pre></td></tr></table></figure><p>停止CPU性能分析：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.StopCPUProfile() </span><br></pre></td></tr></table></figure><p>应用执行结束后，就会生成一个文件，保存了我们的 CPU profiling 数据。得到采样数据之后，使用 <code>go tool pprof</code>工具进行 CPU 性能分析。</p><h2 id="内存性能优化"><a href="#内存性能优化" class="headerlink" title="内存性能优化"></a>内存性能优化</h2><p>记录程序的堆栈信息</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.WriteHeapProfile(w io.Writer)</span><br></pre></td></tr></table></figure><p><code>go tool pprof</code>默认是使用<code>-inuse_space</code> 进行统计，还可以使用 <code>-inuse-objects</code> 查看分配对象的数量。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime_pprof/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;runtime/pprof&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段有问题的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logicCode</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-c:</span><br><span class="line">fmt.Printf(<span class="string">&quot;recv from chan, value:%v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> isCPUPprof <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> isMemPprof <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">flag.BoolVar(&amp;isCPUPprof, <span class="string">&quot;cpu&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;turn cpu pprof on&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;isMemPprof, <span class="string">&quot;mem&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;turn mem pprof on&quot;</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isCPUPprof &#123;</span><br><span class="line">file, err := os.Create(<span class="string">&quot;./cpu.pprof&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;create cpu pprof failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">pprof.StartCPUProfile(file)</span><br><span class="line"><span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> logicCode()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">20</span> * time.Second)</span><br><span class="line"><span class="keyword">if</span> isMemPprof &#123;</span><br><span class="line">file, err := os.Create(<span class="string">&quot;./mem.pprof&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;create mem pprof failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">pprof.WriteHeapProfile(file)</span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过flag我们可以在命令行控制是否开启 CPU和  Mem 的性能分析。 将上面的代码保存并编译成runtime_pprof 可执行文件，执行时加上 -cpu 命令行参数如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span> -cpu</span><br></pre></td></tr></table></figure><p>等待30秒后会在当前目录下生成一个 cpu.pprof 文件。然后，执行<code>go tool pprof</code>命令就可以查看</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof cpu.pprof</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">8</span>:<span class="number">25</span>pm (CST)</span><br><span class="line">Duration: <span class="number">20.19</span>s, Total samples = <span class="number">119.64</span>s (<span class="number">592.65</span>%)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">119.62</span>s, <span class="number">100</span>% of <span class="number">119.64</span>s total</span><br><span class="line">Dropped <span class="number">2</span> nodes (cum &lt;= <span class="number">0.60</span>s)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    <span class="number">52.65</span>s <span class="number">44.01</span>% <span class="number">44.01</span>%     <span class="number">52.65</span>s <span class="number">44.01</span>%  runtime.chanrecv</span><br><span class="line">    <span class="number">51.04</span>s <span class="number">42.66</span>% <span class="number">86.67</span>%    <span class="number">103.69</span>s <span class="number">86.67</span>%  runtime.selectnbrecv</span><br><span class="line">    <span class="number">15.93</span>s <span class="number">13.31</span>%   <span class="number">100</span>%    <span class="number">119.63</span>s   <span class="number">100</span>%  main.logicCode</span><br></pre></td></tr></table></figure><h1 id="压测工具wrk"><a href="#压测工具wrk" class="headerlink" title="压测工具wrk"></a>压测工具wrk</h1><p>推荐使用：</p><p><a href="https://github.com/wg/wrk">https://github.com/wg/wrk</a> </p><p><a href="https://github.com/adjust/go-wrk">https://github.com/adjust/go-wrk</a></p><p>使用wrk进行压测:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>-wrk -n <span class="number">50000</span> http:<span class="comment">//127.0.0.1:8080/book/list</span></span><br></pre></td></tr></table></figure><p>在上面压测进行的同时，打开另一个终端执行:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/profile?seconds=60</span></span><br></pre></td></tr></table></figure><h1 id="pprof与性能测试结合"><a href="#pprof与性能测试结合" class="headerlink" title="pprof与性能测试结合"></a>pprof与性能测试结合</h1><p><code>go test</code> 命令有两个参数和 pprof 相关，它们分别指定生成的 CPU 和 Memory profiling 保存的文件：</p><ul><li>-cpuprofile：cpu profiling 数据要保存的文件地址</li><li>-memprofile：memory profiling 数据要报文的文件地址</li></ul><p>我们还可以选择将pprof与性能测试相结合，比如：</p><p>比如下面执行测试的同时，也会执行 CPU profiling，并把结果保存在 cpu.prof 文件中：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test -bench . -cpuprofile=cpu.profile</span><br></pre></td></tr></table></figure><p>比如下面执行测试的同时，也会执行 Mem profiling，并把结果保存在 cpu.prof 文件中：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test -bench . -memprofile=./mem.profile</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 获取的 Profiling 数据是动态的，要想获得有效的数据，请保证应用处于较大的负载（比如正在生成中运行的服务，或者通过其他工具模拟访问压力）。否则如果应用处于空闲状态，得到的结果可能没有任何意义。所以，<strong>Profiling 一般和性能测试一起使用</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pprof&quot;&gt;&lt;a href=&quot;#pprof&quot; class=&quot;headerlink&quot; title=&quot;pprof&quot;&gt;&lt;/a&gt;pprof&lt;/h1&gt;&lt;p&gt;在 Go 语言中，PProf 是用于可视化和分析性能分析数据的工具，pprof 以 profile.proto 读取</summary>
      
    
    
    
    <category term="pprof" scheme="http://lizhewei91.github.io/categories/pprof/"/>
    
    
    <category term="pprof" scheme="http://lizhewei91.github.io/tags/pprof/"/>
    
    <category term="性能分析" scheme="http://lizhewei91.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
    <category term="golang" scheme="http://lizhewei91.github.io/tags/golang/"/>
    
  </entry>
  
</feed>
