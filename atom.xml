<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lizhewei&#39;Blog</title>
  <icon>https://www.gravatar.com/avatar/239ff887da8d6962c7547552e4f6946b</icon>
  
  <link href="http://lizhewei91.github.io/atom.xml" rel="self"/>
  
  <link href="http://lizhewei91.github.io/"/>
  <updated>2023-07-25T11:24:08.082Z</updated>
  <id>http://lizhewei91.github.io/</id>
  
  <author>
    <name>lizhewei</name>
    <email>tyutlizhewei@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Gin实战-使用JWT认证</title>
    <link href="http://lizhewei91.github.io/2023/07/25/13/"/>
    <id>http://lizhewei91.github.io/2023/07/25/13/</id>
    <published>2023-07-25T11:18:13.000Z</published>
    <updated>2023-07-25T11:24:08.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-JWT"><a href="#什么是-JWT" class="headerlink" title="什么是 JWT?"></a>什么是 JWT?</h1><p>JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种Token 实现方式，目前多用于前后端分离项目和 OAuth2.0 业务场景下。</p><h1 id="为什么需要JWT？"><a href="#为什么需要JWT？" class="headerlink" title="为什么需要JWT？"></a>为什么需要JWT？</h1><p>在之前的一些web项目中，我们通常使用的是<code>Cookie-Session</code>模式实现用户认证。相关流程大致如下：</p><ol><li>用户在浏览器端填写用户名和密码，并发送给服务端</li><li>服务端对用户名和密码校验通过后会生成一份保存当前用户相关信息的session数据和一个与之对应的标识（通常称为session_id）</li><li>服务端返回响应时将上一步的session_id写入用户浏览器的Cookie</li><li>后续用户来自该浏览器的每次请求都会自动携带包含session_id的Cookie</li><li>服务端通过请求中的session_id就能找到之前保存的该用户那份session数据，从而获取该用户的相关信息。</li></ol><p>这种方案依赖于客户端（浏览器）保存 Cookie，并且需要在服务端存储用户的session数据。</p><p>在移动互联网时代，我们的用户可能使用浏览器也可能使用APP来访问我们的服务，我们的web应用可能是前后端分开部署在不同的端口，有时候我们还需要支持第三方登录，这下<code>Cookie-Session</code>的模式就有些力不从心了。</p><p>JWT就是一种基于Token的轻量级认证模式，服务端认证通过后，会生成一个JSON对象，经过签名后得到一个Token（令牌）再发回给用户，用户后续请求只需要带上这个Token，服务端解密之后就能获取该用户的相关信息了。</p><p>想要了解JWT的原理，推荐大家阅读：<a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">阮一峰的JWT入门教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是-JWT&quot;&gt;&lt;a href=&quot;#什么是-JWT&quot; class=&quot;headerlink&quot; title=&quot;什么是 JWT?&quot;&gt;&lt;/a&gt;什么是 JWT?&lt;/h1&gt;&lt;p&gt;JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种T</summary>
      
    
    
    
    <category term="gin" scheme="http://lizhewei91.github.io/categories/gin/"/>
    
    
    <category term="gin" scheme="http://lizhewei91.github.io/tags/gin/"/>
    
    <category term="jwt" scheme="http://lizhewei91.github.io/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>Gin实战-中间件开发</title>
    <link href="http://lizhewei91.github.io/2023/07/25/55/"/>
    <id>http://lizhewei91.github.io/2023/07/25/55/</id>
    <published>2023-07-25T03:08:55.000Z</published>
    <updated>2023-07-25T10:53:06.475Z</updated>
    
    <content type="html"><![CDATA[<p>在 Gin 的整个实现中，中间件可谓是 Gin 的精髓。一个个中间件组成一条中间件链，对 HTTP Request 请求进行拦截处理，实现了代码的解耦和分离，并且中间件之间相互不用感知到，每个中间件只需要处理自己需要处理的事情即可。今天我们就通过这篇文章，详细的介绍Gin 中间的使用和原理。</p><h1 id="Gin-默认中间件"><a href="#Gin-默认中间件" class="headerlink" title="Gin 默认中间件"></a>Gin 默认中间件</h1><p>在 Gin 中，我们可以通过 Gin 提供的默认函数，来构建一个自带默认中间件的 <code>*Engine</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := gin.Default()</span><br></pre></td></tr></table></figure><p>Default 函数会默认绑定两个已经准备好的中间件，它们就是 <code>Logger</code> 和 <code>Recovery</code>，帮助我们打印日志输出和painc处理。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Default</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line">    debugPrintWARNINGDefault()</span><br><span class="line">    engine := New()</span><br><span class="line">    engine.Use(Logger(), Recovery())</span><br><span class="line">    <span class="keyword">return</span> engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中我们可以看到，Gin 的中间件是通过 <code>Use</code> 方法设置的，它接收一个可变参数，所以我们同时可以设置多个中间件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Use(middleware ...HandlerFunc) IRoutes</span><br></pre></td></tr></table></figure><p>到了这里其实我们应该更加明白了，一个 Gin 的中间件，其实就是 Gin 定义的一个 <code>HandlerFunc</code> ,而它在我们 Gin 中经常使用，比如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;首页&quot;</span>)</span><br><span class="line">        c.JSON(<span class="number">200</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>后面的 <code>func(c *gin.Context)</code> 这部分其实就是一个 <code>HandlerFunc</code>。</p><blockquote><p>如果我们想创建一个没有任何中件的 router 可以通过 New 方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router := gin.New()</span><br></pre></td></tr></table></figure></blockquote><h1 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h1><p>我们已经知道，Gin 的中间件其实就是一个 <code>HandlerFunc</code>,那么只要我们自己实现一个 <code>HandlerFunc</code>，就可以自定义一个自己的中间件。现在我们以统计每次请求的执行时间为例，来演示如何自定义一个中间件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">costTime</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">//请求前获取当前时间</span></span><br><span class="line">        nowTime := time.Now()</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//请求处理</span></span><br><span class="line">        c.Next()</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//处理后获取消耗时间</span></span><br><span class="line">        costTime := time.Since(nowTime)</span><br><span class="line">        url := c.Request.URL.String()</span><br><span class="line">        fmt.Printf(<span class="string">&quot;the request URL %s cost %v\n&quot;</span>, url, costTime)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上我们就实现了一个 Gin 中间件，比较简单，而且有注释加以说明，这里要注意的是 <code>c.Next</code>方法，这个是执行后续中间件请求处理的意思（含没有执行的中间件和我们定义的 GET 方法处理），这样我们才能获取执行的耗时。也就是在 <code>c.Next</code> 方法前后分别记录时间，就可以得出耗时。</p><p>有了自定义的中间件，我们就可以这么使用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.New()</span><br><span class="line"> </span><br><span class="line">    r.Use(costTime())</span><br><span class="line"> </span><br><span class="line">    r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在启动程序，在浏览器里打开就可以看到如下日志信息了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the request URL / cost 27.272µs</span><br></pre></td></tr></table></figure><p>通过自定义中间件,我们可以很方便的拦截请求，来做一些我们需要做的事情，比如日志记录、授权校验、各种过滤等等。</p><h1 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h1><p>在gin框架中，我们可以为每个路由添加任意数量的中间件。</p><h2 id="全局路由注册"><a href="#全局路由注册" class="headerlink" title="全局路由注册"></a>全局路由注册</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个全局中间件</span></span><br><span class="line">r.Use(costTime())</span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单个路由注册"><a href="#单个路由注册" class="headerlink" title="单个路由注册"></a>单个路由注册</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为单个路由注册中间件</span></span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, costTime(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为路由组注册"><a href="#为路由组注册" class="headerlink" title="为路由组注册"></a>为路由组注册</h2><p>路由组注册中间件，有两种写法：</p><p>第1种：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个路由组</span></span><br><span class="line">adminGroup := r.Group(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line"><span class="comment">// 为单个路由注册</span></span><br><span class="line">adminGroup.Use(costTime())</span><br><span class="line"></span><br><span class="line">adminGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第2种：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个路由组, 并注册中间件</span></span><br><span class="line">adminGroup := r.Group(<span class="string">&quot;admin&quot;</span>,costTime())</span><br><span class="line"></span><br><span class="line">adminGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="中间件嵌套"><a href="#中间件嵌套" class="headerlink" title="中间件嵌套"></a>中间件嵌套</h1><h2 id="Next"><a href="#Next" class="headerlink" title="Next()"></a>Next()</h2><p>表示跳过当前中间件剩余内容， 去执行下一个中间件。 当所有操作执行完之后，以出栈的执行顺序返回，执行剩余代码。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 in&quot;</span>)</span><br><span class="line">c.Next()</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m2</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 in&quot;</span>)</span><br><span class="line">c.Next()</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个路由注册</span></span><br><span class="line">r.Use(m1(), m2())</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在启动程序，可以看到如下日志信息了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m1 in</span><br><span class="line">m2 in</span><br><span class="line">index</span><br><span class="line">m2 out</span><br><span class="line">m1 out</span><br></pre></td></tr></table></figure><img src="/2023/07/25/55/1739642-20211130215426762-1421068920.png" class="" title="img"><img src="/2023/07/25/55/1739642-20211130215427700-1850689813.png" class="" title="img"><h2 id="Abort"><a href="#Abort" class="headerlink" title="Abort()"></a>Abort()</h2><p>只执行当前中间件， 操作完成后，以出栈的顺序，依次返回上一级中间件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 in&quot;</span>)</span><br><span class="line">    </span><br><span class="line">c.Next()</span><br><span class="line">    </span><br><span class="line">fmt.Println(<span class="string">&quot;m1 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m2</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 in&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 阻止调用后续处理的函数</span></span><br><span class="line">c.Abort()</span><br><span class="line">    </span><br><span class="line">fmt.Println(<span class="string">&quot;m2 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个路由注册</span></span><br><span class="line">r.Use(m1(), m2())</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/07/25/55/image-20230725150624326.png" class="" title="image-20230725150624326"><img src="/2023/07/25/55/image-20230725150813400.png" class="" title="image-20230725150813400"><img src="/2023/07/25/55/1739642-20211130215430060-1290778100.png" class="" title="img"><h2 id="Return"><a href="#Return" class="headerlink" title="Return"></a>Return</h2><p>终止执行当前中间件剩余内容，执行下一个中间件。 当所有的函数执行结束后，以出栈的顺序执行返回，但，不执行return后的代码。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 in&quot;</span>)</span><br><span class="line">c.Next()</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m2</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 in&quot;</span>)</span><br><span class="line">    c.Abort()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">fmt.Println(<span class="string">&quot;m2 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个路由注册</span></span><br><span class="line">r.Use(m1(), m2())</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/07/25/55/image-20230725152525473.png" class="" title="image-20230725152525473"><img src="/2023/07/25/55/image-20230725152621062.png" class="" title="image-20230725152621062"><img src="/2023/07/25/55/1739642-20211130215431079-414872280.png" class="" title="img"><h1 id="中间件取值"><a href="#中间件取值" class="headerlink" title="中间件取值"></a>中间件取值</h1><p>使用 <code>c.Set() </code>在中间件设定自定义值，<code>c.Get() </code>从中间件获取值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 in&quot;</span>)</span><br><span class="line"><span class="comment">// 在上下文中设置自定义值</span></span><br><span class="line">c.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lzw&quot;</span>)</span><br><span class="line">c.Next()</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m2</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 in&quot;</span>)</span><br><span class="line"><span class="comment">// 在上下文中设置自定义值</span></span><br><span class="line">c.Set(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">c.Next()</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个路由注册</span></span><br><span class="line">r.Use(m1(), m2())</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 从中间件获取name值</span></span><br><span class="line">name, _ := c.Get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;从m1中获取name值，name: %v\n&quot;</span>, name)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 从中间件获取age值</span></span><br><span class="line">age, _ := c.Get(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;从m2中获取age值，age: %v\n&quot;</span>, age)</span><br><span class="line">    </span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/07/25/55/image-20230725153335739.png" class="" title="image-20230725153335739"><img src="/2023/07/25/55/image-20230725153347337.png" class="" title="image-20230725153347337"><h1 id="中间件注意事项"><a href="#中间件注意事项" class="headerlink" title="中间件注意事项"></a>中间件注意事项</h1><h2 id="gin默认中间件"><a href="#gin默认中间件" class="headerlink" title="gin默认中间件"></a>gin默认中间件</h2><p><code>gin.Default()</code>默认使用了<code>Logger</code>和<code>Recovery</code>中间件，其中：</p><ul><li><code>Logger</code>中间件将日志写入<code>gin.DefaultWriter</code>，即使配置了<code>GIN_MODE=release</code>。</li><li><code>Recovery</code>中间件会recover任何<code>panic</code>。如果有panic的话，会写入500响应码。</li></ul><p>如果不想使用上面两个默认的中间件，可以使用<code>gin.New()</code>新建一个没有任何默认中间件的路由。</p><h2 id="gin中间件中使用goroutine"><a href="#gin中间件中使用goroutine" class="headerlink" title="gin中间件中使用goroutine"></a>gin中间件中使用goroutine</h2><p>当在中间件或<code>handler</code>中启动新的<code>goroutine</code>时，<strong>不能使用</strong>原始的上下文（c *gin.Context），必须使用其只读副本（<code>c.Copy()</code>）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Gin 的整个实现中，中间件可谓是 Gin 的精髓。一个个中间件组成一条中间件链，对 HTTP Request 请求进行拦截处理，实现了代码的解耦和分离，并且中间件之间相互不用感知到，每个中间件只需要处理自己需要处理的事情即可。今天我们就通过这篇文章，详细的介绍Gin </summary>
      
    
    
    
    <category term="gin" scheme="http://lizhewei91.github.io/categories/gin/"/>
    
    
    <category term="gin" scheme="http://lizhewei91.github.io/tags/gin/"/>
    
    <category term="中间件" scheme="http://lizhewei91.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>从零到1开发一个operator</title>
    <link href="http://lizhewei91.github.io/2023/07/21/00/"/>
    <id>http://lizhewei91.github.io/2023/07/21/00/</id>
    <published>2023-07-21T07:28:00.000Z</published>
    <updated>2023-08-25T01:41:09.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-operator-？"><a href="#什么是-operator-？" class="headerlink" title="什么是 operator ？"></a>什么是 operator ？</h1><p>operator 是一种 kubernetes 的扩展形式，利用自定义资源对象（Custom Resource）来管理应用和组件，允许用户以 Kubernetes 的声明式 API 风格来管理应用及服务。</p><blockquote><p>Operator = CRD + Controller + Webhook</p></blockquote><p>目前，构架 Operator 框架主要有两个工具 Kubebuilder 和 operator SDK，<strong>本文主要讲述如何不使用脚手架，从零到1开发一个自己的 Operator 应用</strong>。</p><p>先放一张 controller与informer交互的经典图</p><img src="/2023/07/21/00/client-go-controller-interaction.jpeg" class="" title="client-go-controller-interaction"><h1 id="code-generator"><a href="#code-generator" class="headerlink" title="code-generator"></a>code-generator</h1><p><code>k8s.io/client-go</code> 提供了对 k8s 原生资源的 informer 和 clientset 等等，但对于自定义资源的操作则相对低效，需要使用 rest api 和 dynamic client 来操作，并自己实现反序列化等功能。</p><p>code-generator 提供了以下工具用于为 k8s 中的资源生成相关代码，可以更加方便的操作自定义资源：</p><ul><li><p><code>deepcopy-gen</code>: 生成深度拷贝对象方法</p><p>使用方法：</p><ul><li>在文件中<code>pkg/apis/&lt;apigroup&gt;/&lt;version&gt;/doc.go</code>添加注释 <code>// +k8s:deepcopy-gen=package</code>，默认为该包中的每个类型创建deepcopy方法。</li><li>为单个类型添加自动生成<code>// +k8s:deepcopy-gen=true</code></li><li>为单个类型关闭自动生成<code>// +k8s:deepcopy-gen=false</code></li></ul></li><li><p><code>client-gen</code>: 为资源生成标准的操作方法(get;list;watch;create;update;patch;delete)</p><p>使用方法（在<code>pkg/apis/&lt;apigroup&gt;/&lt;version&gt;/types.go</code>中使用）：</p><ul><li><code>// +genclient</code> - 生成默认的客户端动作函数（create, update, delete, get, list, update, patch, watch以及 是否生成updateStatus取决于.Status字段是否存在）</li><li><code>// +genclient:nonNamespaced</code> - 所有动作函数都是在没有名称空间的情况下生成</li><li><code>// +genclient:onlyVerbs=create,get</code> - 指定的动作函数被生成.</li><li><code>// +genclient:skipVerbs=watch</code> - 生成 watch 以外所有的动作函数.</li><li><code>// +genclient:noStatus</code> - 即使<code>.Status</code>字段存在也不生成 updateStatus 动作函数</li></ul></li><li><p><code>informer-gen</code>: 生成 informer，提供事件机制 (AddFunc,UpdateFunc,DeleteFunc) 来响应 kubernetes 的 event</p></li><li><p><code>lister-gen</code>: 为get和list方法提供只读缓存层</p></li><li><p><code>conversion-gen</code>: 是用于自动生成在内部和外部类型之间转换的函数的工具</p><p>一般的转换代码生成任务涉及三套程序包：</p><ul><li>一套包含内部类型的程序包，</li><li>一套包含外部类型的程序包</li><li>单个目标程序包（即，生成的转换函数所在的位置，以及开发人员授权的转换功能所在的位置）。包含内部类型的包在Kubernetes的常规代码生成框架中扮演着称为<code>peer package</code>的角色。</li></ul><p>使用方法：</p><ul><li>标记转换内部软件包 <code>// +k8s:conversion-gen=&lt;import-path-of-internal-package&gt;</code></li><li>标记转换外部软件包<code>// +k8s:conversion-gen-external-types=&lt;import-path-of-external-package&gt;</code></li><li>标记不转换对应注释或结构 <code>// +k8s:conversion-gen=false</code></li></ul></li></ul><ul><li><p><code>defaulter-gen</code> 用于生产 Defaulter 函数</p><ul><li>为包含字段的所有类型创建 defaulters，<code>// +k8s:defaulter-gen=&lt;field-name-to-flag&gt;</code></li><li>所有都生成<code>// +k8s:defaulter-gen=true|false</code></li></ul></li><li><p><code>go-to-protobuf</code> 通过go struct生成pb idl</p></li><li><p><code>import-boss</code> 在给定存储库中强制执行导入限制</p></li><li><p><code>openapi-gen</code> 生成openAPI定义</p><p>使用方法：</p><ul><li><code>+k8s:openapi-gen=true</code> 为指定包或方法开启</li><li><code>+k8s:openapi-gen=false</code> 指定包关闭</li></ul></li><li><p><code>register-gen</code> 生成register</p></li><li><p><code>set-gen</code></p></li></ul><p>code-generator 整合了这些 gen，使用脚本 <code>generate-groups.sh</code> 和 <code>generate-internal-groups.sh</code> 可以为自定义资源生产相关代码。</p><h1 id="项目设计"><a href="#项目设计" class="headerlink" title="项目设计"></a>项目设计</h1><p>有了使用 code-generator 的基础，接下来，我们开始一起开发一个简单的 operator 应用，用来控制 deployment 的 replicas 的数量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: extension.k8s.io/v1</span><br><span class="line">kind: UnitedDeployment</span><br><span class="line">metadata:</span><br><span class="line">  name: example-united-deployment</span><br><span class="line">spec:</span><br><span class="line">  deploymentName: example-deployment</span><br><span class="line">  replicas: 2</span><br></pre></td></tr></table></figure><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><h2 id="创建一个项目（crd-controller）"><a href="#创建一个项目（crd-controller）" class="headerlink" title="创建一个项目（crd-controller）"></a>创建一个项目（crd-controller）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost crd-controller]# tree</span><br><span class="line">.</span><br><span class="line">|-- Dockerfile</span><br><span class="line">|-- README.md</span><br><span class="line">|-- go.mod</span><br><span class="line">|-- go.sum</span><br><span class="line">|-- main.go</span><br><span class="line">`-- pkg</span><br><span class="line">    |-- apis</span><br><span class="line">    |   `-- extension</span><br><span class="line">    |       |-- register.go</span><br><span class="line">    |       `-- v1</span><br><span class="line">    |           |-- doc.go</span><br><span class="line">    |           |-- register.go</span><br><span class="line">    |           `-- types.go</span><br><span class="line">    `-- generated</span><br></pre></td></tr></table></figure><p>在 pkg/apis/extension/v1目录创建 doc.go、register.go、types.go。首先，先在 types.go 文件定义我们要创建的 crd 字段。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">metav1 <span class="string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnitedDeployment is a specification for a UnitedDeployment resource</span></span><br><span class="line"><span class="keyword">type</span> UnitedDeployment <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta   <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line">metav1.ObjectMeta <span class="string">`json:&quot;objectMeta,omitempty&quot;`</span></span><br><span class="line">Spec              UnitedDeploymentSpec   <span class="string">`json:&quot;spec&quot;`</span></span><br><span class="line">Status            UnitedDeploymentStatus <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnitedDeploymentSpec is the spec for a UnitedDeployment resource</span></span><br><span class="line"><span class="keyword">type</span> UnitedDeploymentSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">DeploymentName <span class="type">string</span> <span class="string">`json:&quot;deploymentName&quot;`</span></span><br><span class="line">Replicas       *<span class="type">int32</span> <span class="string">`json:&quot;replicas&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnitedDeploymentStatus is the status for a UnitedDeployment resource</span></span><br><span class="line"><span class="keyword">type</span> UnitedDeploymentStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">AvailableReplicas *<span class="type">int32</span> <span class="string">`json:&quot;availableReplicas&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnitedDeploymentList is a list of UnitedDeployment resources</span></span><br><span class="line"><span class="keyword">type</span> UnitedDeploymentList <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line">metav1.ListMeta <span class="string">`json:&quot;metadata,omitempty&quot;`</span></span><br><span class="line">Items           []UnitedDeployment <span class="string">`json:&quot;items&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在 register.go 文件中，增加以下代码，向全局 Scheme 注册自定义类型<code>UnitedDeployment</code>和<code>UnitedDeploymentList</code></p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">metav1 <span class="string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span></span><br><span class="line"><span class="string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span></span><br><span class="line"><span class="string">&quot;k8s.io/apimachinery/pkg/runtime/schema&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;crd-controller/pkg/apis/extension&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SchemeGroupVersion is group version used to register these objects</span></span><br><span class="line"><span class="keyword">var</span> SchemeGroupVersion = schema.GroupVersion&#123;Group: extension.GroupName, Version: <span class="string">&quot;v1&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kind takes an unqualified kind and returns back a Group qualified GroupKind</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Kind</span><span class="params">(kind <span class="type">string</span>)</span></span> schema.GroupKind &#123;</span><br><span class="line"><span class="keyword">return</span> SchemeGroupVersion.WithKind(kind).GroupKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resource takes an unqualified resource and returns a Group qualified GroupResource</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Resource</span><span class="params">(resource <span class="type">string</span>)</span></span> schema.GroupResource &#123;</span><br><span class="line"><span class="keyword">return</span> SchemeGroupVersion.WithResource(resource).GroupResource()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// SchemeBuilder initializes a scheme builder</span></span><br><span class="line">SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)</span><br><span class="line"><span class="comment">// AddToScheme is a global function that registers this API group &amp; version to a scheme</span></span><br><span class="line">AddToScheme = SchemeBuilder.AddToScheme</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adds the list of known types to Scheme.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addKnownTypes</span><span class="params">(scheme *runtime.Scheme)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">scheme.AddKnownTypes(SchemeGroupVersion,</span><br><span class="line">&amp;UnitedDeployment&#123;&#125;,</span><br><span class="line">&amp;UnitedDeploymentList&#123;&#125;,</span><br><span class="line">)</span><br><span class="line">metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doc.go 文件，后续code-generator标识全局标记使用，目前为空。</p><p>pkg/apis/extension/register.go 中，GroupName表示group组的名称</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extension</span><br><span class="line"></span><br><span class="line"><span class="comment">// GroupName is the group name used in this package</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">GroupName = <span class="string">&quot;extension.k8s.io&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="使用-code-generator"><a href="#使用-code-generator" class="headerlink" title="使用 code-generator"></a>使用 code-generator</h2><p>创建好项目后，接下来就需要使用 code-generator 为自定义的 crd 资源，生成 deepcopy、clientSet、informer、lister 代码。</p><h3 id="更新依赖版本"><a href="#更新依赖版本" class="headerlink" title="更新依赖版本"></a>更新依赖版本</h3><p>k8s.io/apimachinery库、k8s.io/client-go库、code-generator版本需要保持一致。</p><p>需要将初始化的k8s库更新到要使用的版本，如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost crd-controller# K8S_VERSION=v0.28.0</span><br><span class="line">[root@localhost crd-controller]# go get k8s.io/client-go@$K8S_VERSION</span><br><span class="line">[root@localhost crd-controller]# go get k8s.io/apimachinery@$K8S_VERSION</span><br></pre></td></tr></table></figure><p>更新后的 go.mod</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost crd-controller]# cat go.mod</span><br><span class="line">module crd-controller</span><br><span class="line"></span><br><span class="line">go 1.19</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">k8s.io/apimachinery v0.28.0</span><br><span class="line">k8s.io/client-go v0.28.0</span><br><span class="line">k8s.io/klog/v2 v2.100.1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="安装-code-generator"><a href="#安装-code-generator" class="headerlink" title="安装 code-generator"></a>安装 code-generator</h3><p>拷贝 <a href="https://github.com/kubernetes/sample-controller">sample-controller</a> 项目 ./hack 目录下的文件到项目目录下</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@localhost crd-controller]# tree</span><br><span class="line">.</span><br><span class="line">|-- Dockerfile</span><br><span class="line">|-- README.md</span><br><span class="line">|-- go.mod</span><br><span class="line">|-- go.sum</span><br><span class="line">|-- hack</span><br><span class="line">|   |-- boilerplate.go.txt</span><br><span class="line">|   |-- custom-boilerplate.go.txt</span><br><span class="line">|   |-- tools.go</span><br><span class="line">|   |-- update-codegen.sh</span><br><span class="line">|   `-- verify-codegen.sh</span><br><span class="line">|-- main.go</span><br><span class="line">`-- pkg</span><br><span class="line">    |-- apis</span><br><span class="line">    |   `-- extension</span><br><span class="line">    |       |-- register.go</span><br><span class="line">    |       `-- v1</span><br><span class="line">    |           |-- doc.go</span><br><span class="line">    |           |-- register.go</span><br><span class="line">    |           `-- types.go</span><br><span class="line">    `-- generated</span><br></pre></td></tr></table></figure><p>k8s的版本号与 <code>go.mod</code> 中的 <code>k8s.io/client-go</code> 的版本保持一致即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost crd-controller]# go get k8s.io/code-generator@$K8S_VERSION</span><br><span class="line">[root@localhost crd-controller]# go mod vendor</span><br></pre></td></tr></table></figure><h3 id="增加-code-generator-tag"><a href="#增加-code-generator-tag" class="headerlink" title="增加 code-generator tag"></a>增加 code-generator tag</h3><p>在 pkg/apis/extension/v1/doc.go文件增加 global tag，<code>+k8s:deepcopy-gen=package</code>：这个注释告诉 Kubernetes 的代码生成工具 <code>deepcopy-gen</code>为这个package下的所有types类型生成deepcopy代码，<code>+groupName=extension.k8s.io</code>：这个注释定义了 Kubernetes 扩展 API 的组名（group name)。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +k8s:deepcopy-gen=package</span></span><br><span class="line"><span class="comment">// +groupName=extension.k8s.io</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package v1 is the v1 version of the API.</span></span><br><span class="line"><span class="keyword">package</span> v1</span><br></pre></td></tr></table></figure><p>在 pkg/apis/extension/v1/types.go 文件分别为<code>UnitedDeployment</code>和<code>UnitedDeploymentList</code>增加 tag，<code>+genclient</code>：这个注释告诉 Kubernetes 代码生成工具生成客户端代码，<code>+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</code>：这个注释告诉 Kubernetes 的代码生成工具生成深拷贝（deep copy）相关的代码，以便确保在操作自定义资源对象时不会影响原始对象。<code>k8s.io/apimachinery/pkg/runtime.Object</code> 是 Kubernetes 中用于对象深拷贝的接口。通过这个注释，你告诉生成工具为你的自定义资源对象生成与深拷贝相关的代码。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +genclient</span></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UnitedDeployment is a specification for a UnitedDeployment resource</span></span><br><span class="line"><span class="keyword">type</span> UnitedDeployment <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta   <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line">metav1.ObjectMeta <span class="string">`json:&quot;objectMeta,omitempty&quot;`</span></span><br><span class="line">Spec              UnitedDeploymentSpec   <span class="string">`json:&quot;spec&quot;`</span></span><br><span class="line">Status            UnitedDeploymentStatus <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UnitedDeploymentList is a list of UnitedDeployment resources</span></span><br><span class="line"><span class="keyword">type</span> UnitedDeploymentList <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line">metav1.ListMeta <span class="string">`json:&quot;metadata,omitempty&quot;`</span></span><br><span class="line">Items           []UnitedDeployment <span class="string">`json:&quot;items&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行-update-codegen-sh"><a href="#执行-update-codegen-sh" class="headerlink" title="执行 update-codegen.sh"></a>执行 update-codegen.sh</h3><p>完成以上步骤，就可以执行 <code>./hack/update-codegen.sh</code>生成相关代码</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@localhost crd-controller]# tree</span><br><span class="line">.</span><br><span class="line">|-- Dockerfile</span><br><span class="line">|-- README.md</span><br><span class="line">|-- go.mod</span><br><span class="line">|-- go.sum</span><br><span class="line">|-- hack</span><br><span class="line">|   |-- boilerplate.go.txt</span><br><span class="line">|   |-- custom-boilerplate.go.txt</span><br><span class="line">|   |-- tools.go</span><br><span class="line">|   |-- update-codegen.sh</span><br><span class="line">|   `-- verify-codegen.sh</span><br><span class="line">|-- main.go</span><br><span class="line">`-- pkg</span><br><span class="line">    |-- apis</span><br><span class="line">    |   `-- extension</span><br><span class="line">    |       |-- register.go</span><br><span class="line">    |       `-- v1</span><br><span class="line">    |           |-- doc.go</span><br><span class="line">    |           |-- register.go</span><br><span class="line">    |           |-- types.go</span><br><span class="line">    |           `-- zz_generated.deepcopy.go</span><br><span class="line">    `-- generated</span><br><span class="line">        |-- clientset</span><br><span class="line">        |   `-- versioned</span><br><span class="line">        |       |-- clientset.go</span><br><span class="line">        |       |-- fake</span><br><span class="line">        |       |   |-- clientset_generated.go</span><br><span class="line">        |       |   |-- doc.go</span><br><span class="line">        |       |   `-- register.go</span><br><span class="line">        |       |-- scheme</span><br><span class="line">        |       |   |-- doc.go</span><br><span class="line">        |       |   `-- register.go</span><br><span class="line">        |       `-- typed</span><br><span class="line">        |           `-- extension</span><br><span class="line">        |               `-- v1</span><br><span class="line">        |                   |-- doc.go</span><br><span class="line">        |                   |-- extension_client.go</span><br><span class="line">        |                   |-- fake</span><br><span class="line">        |                   |   |-- doc.go</span><br><span class="line">        |                   |   |-- fake_extension_client.go</span><br><span class="line">        |                   |   `-- fake_uniteddeployment.go</span><br><span class="line">        |                   |-- generated_expansion.go</span><br><span class="line">        |                   `-- uniteddeployment.go</span><br><span class="line">        |-- informers</span><br><span class="line">        |   `-- externalversions</span><br><span class="line">        |       |-- extension</span><br><span class="line">        |       |   |-- interface.go</span><br><span class="line">        |       |   `-- v1</span><br><span class="line">        |       |       |-- interface.go</span><br><span class="line">        |       |       `-- uniteddeployment.go</span><br><span class="line">        |       |-- factory.go</span><br><span class="line">        |       |-- generic.go</span><br><span class="line">        |       `-- internalinterfaces</span><br><span class="line">        |           `-- factory_interfaces.go</span><br><span class="line">        `-- listers</span><br><span class="line">            `-- extension</span><br><span class="line">                `-- v1</span><br><span class="line">                    |-- expansion_generated.go</span><br><span class="line">                    `-- uniteddeployment.go</span><br></pre></td></tr></table></figure><h2 id="开发-controller"><a href="#开发-controller" class="headerlink" title="开发 controller"></a>开发 controller</h2><p>新建controller.go，增加custom_controller相关代码</p><p>定义 Controller 结构体</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 获取原生kind资源kubeclient</span></span><br><span class="line">kubeclientset          kubernetes.Interface</span><br><span class="line">  <span class="comment">// 生成的crd客户端</span></span><br><span class="line">crdclientset           clientset.Interface</span><br><span class="line">  <span class="comment">// deployment的lister</span></span><br><span class="line">deploymentlister       appslisters.DeploymentLister</span><br><span class="line"><span class="comment">// 判断deploymentInformer是否同步</span></span><br><span class="line">  deploymentsynced       cache.InformerSynced</span><br><span class="line">  <span class="comment">// unitedDeployment的lister</span></span><br><span class="line">uniteddeploymentlister listers.UnitedDeploymentLister</span><br><span class="line">  <span class="comment">// 判断deploymentInformer是否同步</span></span><br><span class="line">uniteddeploymentsynced cache.InformerSynced</span><br><span class="line">  <span class="comment">// 限速队列</span></span><br><span class="line">workqueue              workqueue.RateLimitingInterface</span><br><span class="line"><span class="comment">// recoder记录event事件</span></span><br><span class="line">  recorder               record.EventRecorder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 controller 实例</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">ctx context.Context,</span></span></span><br><span class="line"><span class="params"><span class="function">kubeClientset kubernetes.Interface,</span></span></span><br><span class="line"><span class="params"><span class="function">crdClientset clientset.Interface,</span></span></span><br><span class="line"><span class="params"><span class="function">deploymentInformer appsinformers.DeploymentInformer,</span></span></span><br><span class="line"><span class="params"><span class="function">unitedDeploymentInformer informers.UnitedDeploymentInformer,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> *Controller &#123;</span><br><span class="line">logger := klog.FromContext(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 向全局scheme注册crd资源</span></span><br><span class="line">utilruntime.Must(crdscheme.AddToScheme(scheme.Scheme))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建recorder，记录event事件</span></span><br><span class="line">logger.V(<span class="number">4</span>).Info(<span class="string">&quot;Creating event broadcaster&quot;</span>)</span><br><span class="line">eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">eventBroadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">eventBroadcaster.StartRecordingToSink(&amp;typedcorev1.EventSinkImpl&#123;Interface: kubeClientset.CoreV1().Events(<span class="string">&quot;&quot;</span>)&#125;)</span><br><span class="line">recorder := eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource&#123;Component: controllerAgentName&#125;)</span><br><span class="line"></span><br><span class="line">controller := &amp;Controller&#123;</span><br><span class="line">kubeclientset:          kubeClientset,</span><br><span class="line">crdclientset:           crdClientset,</span><br><span class="line">deploymentlister:       deploymentInformer.Lister(),</span><br><span class="line">deploymentsynced:       deploymentInformer.Informer().HasSynced,</span><br><span class="line">uniteddeploymentlister: unitedDeploymentInformer.Lister(),</span><br><span class="line">uniteddeploymentsynced: unitedDeploymentInformer.Informer().HasSynced,</span><br><span class="line"><span class="comment">// 3.初始化workqueue</span></span><br><span class="line">workqueue: workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">&quot;unitedDeployment&quot;</span>),</span><br><span class="line">recorder:  recorder,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger.Info(<span class="string">&quot;Setting up event handlers&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 给unitedDeployment的 informer增加回调函数</span></span><br><span class="line">unitedDeploymentInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc: controller.enqueueUnitedDeployment,</span><br><span class="line">UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">controller.enqueueUnitedDeployment(<span class="built_in">new</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 给deployment的 informer增加回调函数</span></span><br><span class="line">deploymentInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc: controller.handleObject,</span><br><span class="line">UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">newDepl := <span class="built_in">new</span>.(*appsv1.Deployment)</span><br><span class="line">oldDepl := old.(*appsv1.Deployment)</span><br><span class="line"><span class="keyword">if</span> newDepl.ResourceVersion == oldDepl.ResourceVersion &#123;</span><br><span class="line"><span class="comment">// Periodic resync will send update events for all known Deployments.</span></span><br><span class="line"><span class="comment">// Two different versions of the same Deployment will always have different RVs.</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">controller.handleObject(<span class="built_in">new</span>)</span><br><span class="line">&#125;,</span><br><span class="line">DeleteFunc: controller.handleObject,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> controller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作队列 workqueue 入队方法</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> enqueueUnitedDeployment(obj <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line"><span class="keyword">var</span> key <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">if</span> key, err = cache.MetaNamespaceKeyFunc(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.workqueue.Add(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于deployment 触发的call back函数，进行逻辑判断，对于被unitedDeployment管理的deployment，进行入队操作，其他deployment忽略。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> handleObject(obj <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line"><span class="keyword">var</span> object metav1.Object</span><br><span class="line"><span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">logger := klog.FromContext(context.Background())</span><br><span class="line"><span class="keyword">if</span> object, ok = obj.(metav1.Object); !ok &#123;</span><br><span class="line">tombstone, ok := obj.(cache.DeletedFinalStateUnknown)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;error decoding object, invalid type&quot;</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">object, ok = tombstone.Obj.(metav1.Object)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;error decoding object tombstone, invalid type&quot;</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">logger.V(<span class="number">4</span>).Info(<span class="string">&quot;Recovered deleted object&quot;</span>, <span class="string">&quot;resourceName&quot;</span>, object.GetName())</span><br><span class="line">&#125;</span><br><span class="line">logger.V(<span class="number">4</span>).Info(<span class="string">&quot;Processing object&quot;</span>, <span class="string">&quot;object&quot;</span>, klog.KObj(object))</span><br><span class="line"><span class="keyword">if</span> ownerRef := metav1.GetControllerOf(object); ownerRef != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// If this object is not owned by a Foo, we should not do anything more</span></span><br><span class="line"><span class="comment">// with it.</span></span><br><span class="line"><span class="keyword">if</span> ownerRef.Kind != <span class="string">&quot;UnitedDeployment&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ud, err := c.uniteddeploymentlister.UnitedDeployments(object.GetNamespace()).Get(ownerRef.Name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.V(<span class="number">4</span>).Info(<span class="string">&quot;Ignore orphaned object&quot;</span>, <span class="string">&quot;object&quot;</span>, klog.KObj(object), <span class="string">&quot;foo&quot;</span>, ownerRef.Name)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.enqueueUnitedDeployment(ud)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 controller</p><p>开始运行 controller，controller 作为 workqueue 的消费者，从 workqueue 取出object.key，然后进行协调操作，直到达到 spec状态 与集群中 status状态 一致。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> Run(ctx context.Context, workers <span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"><span class="keyword">defer</span> c.workqueue.ShutDown()</span><br><span class="line">logger := klog.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">logger.Info(<span class="string">&quot;Starting unitedDeployment controller&quot;</span>)</span><br><span class="line"></span><br><span class="line">logger.Info(<span class="string">&quot;Waiting for informer caches to sync&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok := cache.WaitForCacheSync(ctx.Done(), c.deploymentsynced, c.uniteddeploymentsynced); !ok &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to wait for caches to sync&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger.Info(<span class="string">&quot;Starting workers&quot;</span>, <span class="string">&quot;count&quot;</span>, workers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> wait.UntilWithContext(ctx, c.runWorker, time.Second)</span><br><span class="line">&#125;</span><br><span class="line">logger.Info(<span class="string">&quot;Started workers&quot;</span>)</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">logger.Info(<span class="string">&quot;Shutting down workers&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> runWorker(ctx context.Context) &#123;</span><br><span class="line"><span class="keyword">for</span> c.processNextWorkItem(ctx) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> processNextWorkItem(ctx context.Context) <span class="type">bool</span> &#123;</span><br><span class="line">obj, shutdown := c.workqueue.Get()</span><br><span class="line"><span class="keyword">if</span> shutdown &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO controller logic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>man函数作为项目入口，主要做以下几个内容：</p><p>1、初始化 kubeclient 和 crdclient 客户端</p><p>2、初始化 kubeInformerFactory、crdInformerFactory，并运行informer</p><p>3、创建controller实例</p><p>4、运行controller</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">klog.InitFlags(<span class="literal">nil</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">ctx := signals.SetupSignalHandler()</span><br><span class="line">logger := klog.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">cfg, err := clientcmd.BuildConfigFromFlags(masterURL, kubeconfig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err, <span class="string">&quot;Error building kubeconfig&quot;</span>)</span><br><span class="line">klog.FlushAndExit(klog.ExitFlushTimeout, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.创建 kubeclient</span></span><br><span class="line">kubeClient, err := kubernetes.NewForConfig(cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err, <span class="string">&quot;Error building kubernetes clientset&quot;</span>)</span><br><span class="line">klog.FlushAndExit(klog.ExitFlushTimeout, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.创建 crdclient</span></span><br><span class="line">crdClient, err := clientset.NewForConfig(cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err, <span class="string">&quot;Error building kubernetes clientset&quot;</span>)</span><br><span class="line">klog.FlushAndExit(klog.ExitFlushTimeout, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3.创建 kubeInformerFactory 实例</span></span><br><span class="line">kubeInformerFactory := kubeinformers.NewSharedInformerFactory(kubeClient, time.Second*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.创建 crdInformerFactory 实例</span></span><br><span class="line">  crdInformerFactory := informers.NewSharedInformerFactory(crdClient, time.Second*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.创建 controller 实例</span></span><br><span class="line">controller := NewController(ctx, kubeClient, crdClient,</span><br><span class="line">kubeInformerFactory.Apps().V1().Deployments(),</span><br><span class="line">crdInformerFactory.Extension().V1().UnitedDeployments())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.运行 informer</span></span><br><span class="line">kubeInformerFactory.Start(ctx.Done())</span><br><span class="line">crdInformerFactory.Start(ctx.Done())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7.运行 controller</span></span><br><span class="line"><span class="keyword">if</span> err = controller.Run(ctx, <span class="number">2</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err, <span class="string">&quot;Error running controller&quot;</span>)</span><br><span class="line">klog.FlushAndExit(klog.ExitFlushTimeout, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码示例：<a href="https://github.com/lizhewei91/crd-controller">https://github.com/lizhewei91/crd-controller</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>sample-controller：<a href="https://github.com/kubernetes/sample-controller/tree/v0.28.0">https://github.com/kubernetes/sample-controller/tree/v0.28.0</a></p><p>code-generator：<a href="https://github.com/kubernetes/code-generator/tree/v0.28.0">https://github.com/kubernetes/code-generator/tree/v0.28.0</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是-operator-？&quot;&gt;&lt;a href=&quot;#什么是-operator-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 operator ？&quot;&gt;&lt;/a&gt;什么是 operator ？&lt;/h1&gt;&lt;p&gt;operator 是一种 kubernete</summary>
      
    
    
    
    <category term="operator" scheme="http://lizhewei91.github.io/categories/operator/"/>
    
    
    <category term="operator" scheme="http://lizhewei91.github.io/tags/operator/"/>
    
    <category term="code-generator" scheme="http://lizhewei91.github.io/tags/code-generator/"/>
    
  </entry>
  
  <entry>
    <title>kube-scheduler</title>
    <link href="http://lizhewei91.github.io/2023/07/17/39/"/>
    <id>http://lizhewei91.github.io/2023/07/17/39/</id>
    <published>2023-07-17T08:45:39.000Z</published>
    <updated>2023-07-17T08:45:39.423Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>kubelet 资源配置</title>
    <link href="http://lizhewei91.github.io/2023/03/10/19/"/>
    <id>http://lizhewei91.github.io/2023/03/10/19/</id>
    <published>2023-03-10T07:03:19.000Z</published>
    <updated>2023-06-01T09:04:07.404Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/03/10/19/640.png" class="" title="图片"><p>Kubernetes 的节点可以按照 <code>Capacity</code> 调度。默认情况下 pod 能够使用节点全部可用容量。 这是个问题，因为节点自己通常运行了不少驱动 OS 和 Kubernetes 的系统守护进程。 除非为这些系统守护进程留出资源，否则它们将与 Pod 争夺资源并导致节点资源短缺问题。</p><p><code>kubelet</code> 公开了一个名为 ‘Node Allocatable’ 的特性，有助于为系统守护进程预留计算资源。 Kubernetes 推荐集群管理员按照每个节点上的工作负载密度配置 ‘Node Allocatable’。</p><h2 id="节点可分配资源"><a href="#节点可分配资源" class="headerlink" title="节点可分配资源"></a>节点可分配资源</h2><p>Kubernetes 节点上的 ‘Allocatable’ 被定义为 Pod 可用计算资源量。 调度器不会超额申请 ‘Allocatable’。 目前支持 **‘CPU’、’memory’ 和 ‘ephemeral-storage’ ** 这几个参数。</p><p>我们可以通过 <code>kubectl describe node</code> 命令查看节点可分配资源的数据：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl describe node node-2</span><br><span class="line">...</span><br><span class="line">Capacity:</span><br><span class="line">  cpu:                40</span><br><span class="line">  ephemeral-storage:  276590640Ki</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             131273628Ki</span><br><span class="line">  pods:               255</span><br><span class="line">Allocatable:</span><br><span class="line">  cpu:                38976m</span><br><span class="line">  ephemeral-storage:  254905933402</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             131171228Ki</span><br><span class="line">  pods:               255</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到其中有 <code>Capacity</code> 与 <code>Allocatable</code> 两项内容，其中的 <code>Allocatable</code> 就是节点可被分配的资源，我们这里没有配置资源预留，所以默认情况下 <code>Capacity</code> 与 <code>Allocatable</code> 的值基本上是一致的。下图显示了可分配资源和资源预留之间的关系：</p><img src="/2023/03/10/19/640-20230310155640575.png" class="" title="图片"><ul><li>目前支持 cpu, memory, <code>ephemeral-storage</code> 三种资源预留。</li><li>Node Capacity 是节点的所有硬件资源，<code>kube-reserved</code> 是给 kube 组件预留的资源，<code>system-reserved</code> 是给系统进程预留的资源，<code>eviction-threshold</code> 是 kubelet 驱逐的阈值设定，<code>allocatable</code> 才是真正调度器调度 Pod 时的参考值（保证节点上所有 Pods 的 request 资源不超过 Allocatable）。</li></ul><p>节点可分配资源的计算方式为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Node Allocatable Resource = Node Capacity - Kube-reserved - system-reserved - eviction-threshold</span><br></pre></td></tr></table></figure><h2 id="配置资源预留"><a href="#配置资源预留" class="headerlink" title="配置资源预留"></a><strong>配置资源预留</strong></h2><h3 id="配置-cgroup-驱动"><a href="#配置-cgroup-驱动" class="headerlink" title="配置 cgroup 驱动"></a>配置 cgroup 驱动</h3><p><code>kubelet</code> 支持在主机上使用 cgroup 驱动操作 cgroup 层次结构。 该驱动通过 <code>--cgroup-driver</code> 标志进行配置。</p><p>支持的参数值如下：</p><ul><li><code>cgroupfs</code> 是默认的驱动，在主机上直接操作 cgroup 文件系统以对 cgroup 沙箱进行管理。</li><li><code>systemd</code> 是可选的驱动，使用 init 系统支持的资源的瞬时切片管理 cgroup 沙箱。</li></ul><p>取决于相关容器运行时的配置，操作员可能需要选择一个特定的 cgroup 驱动来保证系统正常运行。</p><p>如果操作员使用 <code>containerd</code> 运行时提供的 <code>systemd</code> cgroup 驱动时， 必须配置 <code>kubelet</code> 使用 <code>systemd</code> cgroup 驱动</p><h3 id="Kube-预留值"><a href="#Kube-预留值" class="headerlink" title="Kube 预留值"></a><strong>Kube 预留值</strong></h3><ul><li><strong>Kubelet 标志</strong>：<code>--kube-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]</code></li><li><strong>Kubelet 标志</strong>：<code>--kube-reserved-cgroup=</code></li></ul><p><code>kube-reserved</code> 用来给诸如 <code>kubelet</code>、容器运行时、节点问题监测器等 Kubernetes 系统守护进程记述其资源预留值。 该配置并非用来给以 Pod 形式运行的系统守护进程预留资源。<code>kube-reserved</code> 通常是节点上 <code>Pod 密度</code> 的函数。</p><p>除了 <code>cpu</code>、<code>内存</code> 和 <code>ephemeral-storage</code> 之外，<code>pid</code> 可用来指定为 Kubernetes 系统守护进程预留指定数量的进程 ID。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2023/03/10/19/640.png&quot; class=&quot;&quot; title=&quot;图片&quot;&gt;

&lt;p&gt;Kubernetes 的节点可以按照 &lt;code&gt;Capacity&lt;/code&gt; 调度。默认情况下 pod 能够使用节点全部可用容量。 这是个问题，因为节点自己通</summary>
      
    
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/categories/kubelet/"/>
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/tags/kubelet/"/>
    
    <category term="node 节点资源分配" scheme="http://lizhewei91.github.io/tags/node-%E8%8A%82%E7%82%B9%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>kubelet 创建 pod 源码分析</title>
    <link href="http://lizhewei91.github.io/2023/03/09/08/"/>
    <id>http://lizhewei91.github.io/2023/03/09/08/</id>
    <published>2023-03-09T02:33:08.000Z</published>
    <updated>2023-06-01T13:31:53.206Z</updated>
    
    <content type="html"><![CDATA[<p>本来基于 kubernetnes : v1.25.4</p><p>之前那篇文章对 kubelet 的工作原理做了简单的介绍，接下来，我们对 pod 创建的流程中，kubelet 创建 pod 进行一个详细的分析。</p><img src="kubelet-create-pod/kubelet-arch.jpg" alt="kubelet-arch"  /><h1 id="SyncLoop"><a href="#SyncLoop" class="headerlink" title="SyncLoop"></a>SyncLoop</h1><p>我们来看下这个主循环 SyncLoop：</p><p><em><u>/pkg/kubelet/kubelet.go#2009</u></em></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> syncLoop(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler) &#123;</span><br><span class="line">klog.InfoS(<span class="string">&quot;Starting kubelet main sync loop&quot;</span>)</span><br><span class="line"><span class="comment">// The syncTicker wakes up kubelet to checks if there are any pod workers</span></span><br><span class="line"><span class="comment">// that need to be sync&#x27;d. A one-second period is sufficient because the</span></span><br><span class="line"><span class="comment">// sync interval is defaulted to 10s.</span></span><br><span class="line">syncTicker := time.NewTicker(time.Second)</span><br><span class="line"><span class="keyword">defer</span> syncTicker.Stop()</span><br><span class="line">housekeepingTicker := time.NewTicker(housekeepingPeriod)</span><br><span class="line"><span class="keyword">defer</span> housekeepingTicker.Stop()</span><br><span class="line">plegCh := kl.pleg.Watch()</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">base   = <span class="number">100</span> * time.Millisecond</span><br><span class="line">max    = <span class="number">5</span> * time.Second</span><br><span class="line">factor = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line">duration := base</span><br><span class="line"><span class="comment">// Responsible for checking limits in resolv.conf</span></span><br><span class="line"><span class="comment">// The limits do not have anything to do with individual pods</span></span><br><span class="line"><span class="comment">// Since this is called in syncLoop, we don&#x27;t need to call it anywhere else</span></span><br><span class="line"><span class="keyword">if</span> kl.dnsConfigurer != <span class="literal">nil</span> &amp;&amp; kl.dnsConfigurer.ResolverConfig != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">kl.dnsConfigurer.CheckLimitsForResolvConf()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := kl.runtimeState.runtimeErrors(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Skipping pod synchronization&quot;</span>)</span><br><span class="line"><span class="comment">// exponential backoff</span></span><br><span class="line">time.Sleep(duration)</span><br><span class="line">duration = time.Duration(math.Min(<span class="type">float64</span>(max), factor*<span class="type">float64</span>(duration)))</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// reset backoff if we have a success</span></span><br><span class="line">duration = base</span><br><span class="line"></span><br><span class="line">kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line"><span class="keyword">if</span> !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SyncLoop 起了一个死循环，循环里只调用了 syncLoopIteration 方法。而 syncLoopIteration 会对传入的所有 channel 遍历，发现任何一个管道有消息就交给 handler 去处理。</p><p>这些 channel 包括：</p><ul><li><strong>configCh：</strong>该 channel 的生产者为 kubeDeps 对象中的 PodConfig 子模块提供，该模块将同时监听来自 file，http，apiserver 的 pod 信息的变化，一旦某个来源的 pod 信息发生了更新，就会向这个 channel 生产相关事件。</li><li><strong>plegCh：</strong>该 channel 的生产者为 pleg 子模块，该模块会周期性地向容器运行时查询当前所有容器的状态，如果状态发生变化，则向这个 channel 生产事件。</li><li><strong>syncCh：</strong>定时同步最新保存的 pod 状态。</li><li><strong>health manager :</strong> livenessManager、readinessManager、startupManager 健康检查发现某个 pod 不可用，Kubelet 将根据 Pod 的 restartPolicy 自动执行正确的操作。</li><li><strong>houseKeepingCh：</strong>housekeeping 事件的管道，做 pod 清理工作。</li></ul><h2 id="syncLoopIteration"><a href="#syncLoopIteration" class="headerlink" title="syncLoopIteration"></a>syncLoopIteration</h2><p><em><u>/pkg/kubelet/kubelet.go#2083</u></em></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> syncLoopIteration(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span><br><span class="line">syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">case</span> u, open := &lt;-configCh:</span><br><span class="line"><span class="comment">// Update from a config source; dispatch it to the right handler</span></span><br><span class="line"><span class="comment">// callback.</span></span><br><span class="line"><span class="keyword">if</span> !open &#123;</span><br><span class="line">klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Update channel is closed, exiting the sync loop&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> u.Op &#123;</span><br><span class="line"><span class="keyword">case</span> kubetypes.ADD:</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop ADD&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line"><span class="comment">// After restarting, kubelet will get all existing pods through</span></span><br><span class="line"><span class="comment">// ADD as if they are new pods. These pods will then go through the</span></span><br><span class="line"><span class="comment">// admission process and *may* be rejected. This can be resolved</span></span><br><span class="line"><span class="comment">// once we have checkpointing.</span></span><br><span class="line">handler.HandlePodAdditions(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.UPDATE:</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop UPDATE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">handler.HandlePodUpdates(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.REMOVE:</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop REMOVE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">handler.HandlePodRemoves(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.RECONCILE:</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop RECONCILE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">handler.HandlePodReconcile(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.DELETE:</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop DELETE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line"><span class="comment">// DELETE is treated as a UPDATE because of graceful deletion.</span></span><br><span class="line">handler.HandlePodUpdates(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.SET:</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Do we want to support this?</span></span><br><span class="line">klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Kubelet does not support snapshot update&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Invalid operation type received&quot;</span>, <span class="string">&quot;operation&quot;</span>, u.Op)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kl.sourcesReady.AddSource(u.Source)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> e := &lt;-plegCh:</span><br><span class="line"><span class="keyword">if</span> e.Type == pleg.ContainerStarted &#123;</span><br><span class="line"><span class="comment">// record the most recent time we observed a container start for this pod.</span></span><br><span class="line"><span class="comment">// this lets us selectively invalidate the runtimeCache when processing a delete for this pod</span></span><br><span class="line"><span class="comment">// to make sure we don&#x27;t miss handling graceful termination for containers we reported as having started.</span></span><br><span class="line">kl.lastContainerStartedTime.Add(e.ID, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> isSyncPodWorthy(e) &#123;</span><br><span class="line"><span class="comment">// PLEG event for a pod; sync it.</span></span><br><span class="line"><span class="keyword">if</span> pod, ok := kl.podManager.GetPodByUID(e.ID); ok &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop (PLEG): event for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;event&quot;</span>, e)</span><br><span class="line">handler.HandlePodSyncs([]*v1.Pod&#123;pod&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// If the pod no longer exists, ignore the event.</span></span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (PLEG): pod does not exist, ignore irrelevant event&quot;</span>, <span class="string">&quot;event&quot;</span>, e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e.Type == pleg.ContainerDied &#123;</span><br><span class="line"><span class="keyword">if</span> containerID, ok := e.Data.(<span class="type">string</span>); ok &#123;</span><br><span class="line">kl.cleanUpContainersInPod(e.ID, containerID)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-syncCh:</span><br><span class="line"><span class="comment">// Sync pods waiting for sync</span></span><br><span class="line">podsToSync := kl.getPodsToSync()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(podsToSync) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (SYNC) pods&quot;</span>, <span class="string">&quot;total&quot;</span>, <span class="built_in">len</span>(podsToSync), <span class="string">&quot;pods&quot;</span>, klog.KObjs(podsToSync))</span><br><span class="line">handler.HandlePodSyncs(podsToSync)</span><br><span class="line"><span class="keyword">case</span> update := &lt;-kl.livenessManager.Updates():</span><br><span class="line"><span class="keyword">if</span> update.Result == proberesults.Failure &#123;</span><br><span class="line">handleProbeSync(kl, update, handler, <span class="string">&quot;liveness&quot;</span>, <span class="string">&quot;unhealthy&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> update := &lt;-kl.readinessManager.Updates():</span><br><span class="line">ready := update.Result == proberesults.Success</span><br><span class="line">kl.statusManager.SetContainerReadiness(update.PodUID, update.ContainerID, ready)</span><br><span class="line"></span><br><span class="line">status := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> ready &#123;</span><br><span class="line">status = <span class="string">&quot;ready&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">handleProbeSync(kl, update, handler, <span class="string">&quot;readiness&quot;</span>, status)</span><br><span class="line"><span class="keyword">case</span> update := &lt;-kl.startupManager.Updates():</span><br><span class="line">started := update.Result == proberesults.Success</span><br><span class="line">kl.statusManager.SetContainerStartup(update.PodUID, update.ContainerID, started)</span><br><span class="line"></span><br><span class="line">status := <span class="string">&quot;unhealthy&quot;</span></span><br><span class="line"><span class="keyword">if</span> started &#123;</span><br><span class="line">status = <span class="string">&quot;started&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">handleProbeSync(kl, update, handler, <span class="string">&quot;startup&quot;</span>, status)</span><br><span class="line"><span class="keyword">case</span> &lt;-housekeepingCh:</span><br><span class="line"><span class="keyword">if</span> !kl.sourcesReady.AllReady() &#123;</span><br><span class="line"><span class="comment">// If the sources aren&#x27;t ready or volume manager has not yet synced the states,</span></span><br><span class="line"><span class="comment">// skip housekeeping, as we may accidentally delete pods from unready sources.</span></span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (housekeeping, skipped): sources aren&#x27;t ready yet&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (housekeeping)&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err := handler.HandlePodCleanups(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Failed cleaning pods&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">duration := time.Since(start)</span><br><span class="line"><span class="keyword">if</span> duration &gt; housekeepingWarningDuration &#123;</span><br><span class="line">klog.ErrorS(fmt.Errorf(<span class="string">&quot;housekeeping took too long&quot;</span>), <span class="string">&quot;Housekeeping took longer than 15s&quot;</span>, <span class="string">&quot;seconds&quot;</span>, duration.Seconds())</span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (housekeeping) end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建pod过程"><a href="#创建pod过程" class="headerlink" title="创建pod过程"></a>创建pod过程</h3><p>Kubelet 创建 pod 的过程是由 configCh 中的 ADD 事件触发的，那么下面主要看下 Kubelet 接收到 ADD 事件后的主要流程。</p><h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>当 configCh 中出现了 ADD 事件，loop 会触发 SyncHandler 的 HandlePodAdditions 方法。这个方法的流程可以用下面这张流程图描述：</p><img src="/2023/03/09/08/handlePodAdditions.png" class="" title="handlePodAdditions"><ul><li><p>首先 handler 会将所有的 pod 安装创建时间进行排序，然后逐个进行处理。</p></li><li><p>然后将 pod 添加到 podManager 中，以方便后续操作；然后判断其是否为 mirror pod，如果是将作为 mirror pod 处理，否则按照正常 pod 处理。</p><p>这里解释一下 mirror pod： mirror pod 是 static pod 在 kueblet 在 apiserver 创建的一份副本。由于 static pod 是由 Kubelet 直接管理的，apiserver 并不会感知到 static pod 的存在，其生命周期都由 Kubelet 直接托管。为了可以通过 kubectl 命令查看对应的 pod，并且可以通过 kubectl logs 命令直接查看到static pod 的日志信息，Kubelet 通过 apiserver 为每一个 static pod 创建一个对应的 mirror pod。</p></li><li><p>接着判断 pod 是否能再该节点上运行，也就是所谓的 Kubelet 中的 pod 准入控制，准入控制主要包括这几方面：</p></li></ul><ol><li>节点是否满足 pod 的亲和性规则</li><li>节点是否有足够的资源分配给 pod</li><li>节点是否使用 HostNetwork 或者 HostIPC，若使用了，是否在节点的白名单里</li><li>/proc 挂载目录满足要求</li><li>pod 是否配置且是否配置正确的 AppArmor</li></ol><ul><li>当所有的条件都满足后，最后触发 podWorker 同步 pod。</li></ul><p>HandlePodAdditions 对应的代码如下：</p><p><u><em>/pkg/kubelet/kubelet.go#2238</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> HandlePodAdditions(pods []*v1.Pod) &#123;</span><br><span class="line">start := kl.clock.Now()</span><br><span class="line">sort.Sort(sliceutils.PodsByCreationTime(pods))</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">existingPods := kl.podManager.GetPods()</span><br><span class="line"><span class="comment">// Always add the pod to the pod manager. Kubelet relies on the pod</span></span><br><span class="line"><span class="comment">// manager as the source of truth for the desired state. If a pod does</span></span><br><span class="line"><span class="comment">// not exist in the pod manager, it means that it has been deleted in</span></span><br><span class="line"><span class="comment">// the apiserver and no action (other than cleanup) is required.</span></span><br><span class="line">kl.podManager.AddPod(pod)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> kubetypes.IsMirrorPod(pod) &#123;</span><br><span class="line">kl.handleMirrorPod(pod, start)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only go through the admission process if the pod is not requested</span></span><br><span class="line"><span class="comment">// for termination by another part of the kubelet. If the pod is already</span></span><br><span class="line"><span class="comment">// using resources (previously admitted), the pod worker is going to be</span></span><br><span class="line"><span class="comment">// shutting it down. If the pod hasn&#x27;t started yet, we know that when</span></span><br><span class="line"><span class="comment">// the pod worker is invoked it will also avoid setting up the pod, so</span></span><br><span class="line"><span class="comment">// we simply avoid doing any work.</span></span><br><span class="line"><span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line"><span class="comment">// We failed pods that we rejected, so activePods include all admitted</span></span><br><span class="line"><span class="comment">// pods that are alive.</span></span><br><span class="line">activePods := kl.filterOutInactivePods(existingPods)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if we can admit the pod; if not, reject it.</span></span><br><span class="line"><span class="keyword">if</span> ok, reason, message := kl.canAdmitPod(activePods, pod); !ok &#123;</span><br><span class="line">kl.rejectPod(pod, reason, message)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)</span><br><span class="line">kl.dispatchWork(pod, kubetypes.SyncPodCreate, mirrorPod, start)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="podWorkers-的工作"><a href="#podWorkers-的工作" class="headerlink" title="podWorkers 的工作"></a>podWorkers 的工作</h4><p>接下来看看 podWorker 的工作。podWorker 维护了一个 map 叫 podUpdates (map[types.UID]chan podWork)，以 pod uid 为 key，为每个 pod 维护一个 channel；当 pod 有事件过来的时候，首先从这个 map 里获取对应的 channel，然后启动一个 goroutine 监听这个 channel，并执行 managePodLoop；另一方面 podWorker 向这个 channel 中传入需要同步的 pod。</p><p>managePodLoop 接收到事件后，会先从 pod cache 中获取该 pod 最新的 status，以确保当前处理的 pod 是最新状态；然后调用 syncPod 方法，将其同步后的结果记录在 workQueue 中，等待下一次定时同步任务处理。</p><p>整个过程如下图所示：</p><img src="/2023/03/09/08/2020-08-02-161428.jpg" class="" title="img"><p>podWorker 中处理 pod 事件的代码：</p><p><u><em>/pkg/kubelet/pod_workers.go#557</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span></span> UpdatePod(options UpdatePodOptions) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// allow testing of delays in the pod update channel</span></span><br><span class="line"><span class="keyword">var</span> outCh &lt;-<span class="keyword">chan</span> podWork</span><br><span class="line"><span class="keyword">if</span> p.workerChannelFn != <span class="literal">nil</span> &#123;</span><br><span class="line">outCh = p.workerChannelFn(uid, podUpdates)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">outCh = podUpdates</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating a new pod worker either means this is a new pod, or that the</span></span><br><span class="line"><span class="comment">// kubelet just restarted. In either case the kubelet is willing to believe</span></span><br><span class="line"><span class="comment">// the status of the pod for the first pod worker sync. See corresponding</span></span><br><span class="line"><span class="comment">// comment in syncPod.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> runtime.HandleCrash()</span><br><span class="line">p.managePodLoop(outCh)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dispatch a request to the pod worker if none are running</span></span><br><span class="line"><span class="keyword">if</span> !status.IsWorking() &#123;</span><br><span class="line">status.working = <span class="literal">true</span></span><br><span class="line">podUpdates &lt;- work</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>managePodLoop 函数，会根据 update.WorkType 类型，去分别执行 syncTerminatedPodFn、syncTerminatingPodFn、syncPodFn方法去调用</p><p><u><em>/pkg/kubelet/pod_worker.go#877</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span></span> managePodLoop(podUpdates &lt;-<span class="keyword">chan</span> podWork) &#123;</span><br><span class="line"><span class="keyword">var</span> lastSyncTime time.Time</span><br><span class="line"><span class="keyword">var</span> podStarted <span class="type">bool</span></span><br><span class="line"><span class="keyword">for</span> update := <span class="keyword">range</span> podUpdates &#123;</span><br><span class="line">pod := update.Options.Pod</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Take the appropriate action (illegal phases are prevented by UpdatePod)</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> update.WorkType == TerminatedPodWork:</span><br><span class="line">err = p.syncTerminatedPodFn(ctx, pod, status)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> update.WorkType == TerminatingPodWork:</span><br><span class="line"><span class="keyword">var</span> gracePeriod *<span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> opt := update.Options.KillPodOptions; opt != <span class="literal">nil</span> &#123;</span><br><span class="line">gracePeriod = opt.PodTerminationGracePeriodSecondsOverride</span><br><span class="line">&#125;</span><br><span class="line">podStatusFn := p.acknowledgeTerminating(pod)</span><br><span class="line"></span><br><span class="line">err = p.syncTerminatingPodFn(ctx, pod, status, update.Options.RunningPod, gracePeriod, podStatusFn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">isTerminal, err = p.syncPodFn(ctx, update.Options.UpdateType, pod, update.Options.MirrorPod, status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lastSyncTime = time.Now()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;()</span><br><span class="line">...</span><br><span class="line"><span class="comment">// queue a retry if necessary, then put the next event in the channel if any</span></span><br><span class="line">p.completeWork(pod, phaseTransition, err)</span><br><span class="line"><span class="keyword">if</span> start := update.Options.StartTime; !start.IsZero() &#123;</span><br><span class="line">metrics.PodWorkerDuration.WithLabelValues(update.Options.UpdateType.String()).Observe(metrics.SinceInSeconds(start))</span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Processing pod event done&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID, <span class="string">&quot;updateType&quot;</span>, update.WorkType)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="syncPod"><a href="#syncPod" class="headerlink" title="syncPod"></a>syncPod</h4><p>上述 podWorker 在 managePodLoop 中调用的 syncPodFn 方法，其实是 Kubelet 对象的 SyncPod 方法，在文件 pkg/kubelet/kubelet.go 中。</p><p>这个方法是真正与 container runtime 层交互的。首先，如果正在创建，记录pod worker启动延迟；设置podIP为hostIP；然后判断是否可以在节点上运行，这里就是上面讲到的 Kubelet 的准入控制；再判断 CNI 插件是否 ready，如果不 ready，则只在 pod 使用 host network 的时候创建并更新 pod 的 cgroups；接着再判断是否是静态 pod，如果是就创建相应的 mirror pod；然后创建 pod 需要挂载的目录；最后调用 runtime 的 syncPod。整个流程如下所示：</p><img src="/2023/03/09/08/syncPod-8419730.png" class="" title="syncPod"><p><u><em>/pkg/kubelet/kubelet.go#1522</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> syncPod(ctx context.Context, updateType kubetypes.SyncPodType, pod, mirrorPod *v1.Pod, podStatus *kubecontainer.PodStatus) (isTerminal <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;syncPod enter&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;syncPod exit&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID, <span class="string">&quot;isTerminal&quot;</span>, isTerminal)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Latency measurements for the main workflow are relative to the</span></span><br><span class="line"><span class="comment">// first time the pod was seen by kubelet.</span></span><br><span class="line"><span class="keyword">var</span> firstSeenTime time.Time</span><br><span class="line"><span class="keyword">if</span> firstSeenTimeStr, ok := pod.Annotations[kubetypes.ConfigFirstSeenAnnotationKey]; ok &#123;</span><br><span class="line">firstSeenTime = kubetypes.ConvertToTimestamp(firstSeenTimeStr).Get()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record pod worker start latency if being created</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> make pod workers record their own latencies</span></span><br><span class="line"><span class="keyword">if</span> updateType == kubetypes.SyncPodCreate &#123;</span><br><span class="line"><span class="keyword">if</span> !firstSeenTime.IsZero() &#123;</span><br><span class="line"><span class="comment">// This is the first time we are syncing the pod. Record the latency</span></span><br><span class="line"><span class="comment">// since kubelet first saw the pod if firstSeenTime is set.</span></span><br><span class="line">metrics.PodWorkerStartDuration.Observe(metrics.SinceInSeconds(firstSeenTime))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;First seen time not recorded for pod&quot;</span>,</span><br><span class="line"><span class="string">&quot;podUID&quot;</span>, pod.UID,</span><br><span class="line"><span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate final API pod status with pod and status manager status</span></span><br><span class="line">apiPodStatus := kl.generateAPIPodStatus(pod, podStatus)</span><br><span class="line"><span class="comment">// The pod IP may be changed in generateAPIPodStatus if the pod is using host network. (See #24576)</span></span><br><span class="line"><span class="comment">// TODO(random-liu): After writing pod spec into container labels, check whether pod is using host network, and</span></span><br><span class="line"><span class="comment">// set pod IP to hostIP directly in runtime.GetPodStatus</span></span><br><span class="line">podStatus.IPs = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(apiPodStatus.PodIPs))</span><br><span class="line"><span class="keyword">for</span> _, ipInfo := <span class="keyword">range</span> apiPodStatus.PodIPs &#123;</span><br><span class="line">podStatus.IPs = <span class="built_in">append</span>(podStatus.IPs, ipInfo.IP)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(podStatus.IPs) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(apiPodStatus.PodIP) &gt; <span class="number">0</span> &#123;</span><br><span class="line">podStatus.IPs = []<span class="type">string</span>&#123;apiPodStatus.PodIP&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the pod is terminal, we don&#x27;t need to continue to setup the pod</span></span><br><span class="line"><span class="keyword">if</span> apiPodStatus.Phase == v1.PodSucceeded || apiPodStatus.Phase == v1.PodFailed &#123;</span><br><span class="line">kl.statusManager.SetPodStatus(pod, apiPodStatus)</span><br><span class="line">isTerminal = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> isTerminal, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the pod should not be running, we request the pod&#x27;s containers be stopped. This is not the same</span></span><br><span class="line"><span class="comment">// as termination (we want to stop the pod, but potentially restart it later if soft admission allows</span></span><br><span class="line"><span class="comment">// it later). Set the status and phase appropriately</span></span><br><span class="line">runnable := kl.canRunPod(pod)</span><br><span class="line"><span class="keyword">if</span> !runnable.Admit &#123;</span><br><span class="line"><span class="comment">// Pod is not runnable; and update the Pod and Container statuses to why.</span></span><br><span class="line"><span class="keyword">if</span> apiPodStatus.Phase != v1.PodFailed &amp;&amp; apiPodStatus.Phase != v1.PodSucceeded &#123;</span><br><span class="line">apiPodStatus.Phase = v1.PodPending</span><br><span class="line">&#125;</span><br><span class="line">apiPodStatus.Reason = runnable.Reason</span><br><span class="line">apiPodStatus.Message = runnable.Message</span><br><span class="line"><span class="comment">// Waiting containers are not creating.</span></span><br><span class="line"><span class="keyword">const</span> waitingReason = <span class="string">&quot;Blocked&quot;</span></span><br><span class="line"><span class="keyword">for</span> _, cs := <span class="keyword">range</span> apiPodStatus.InitContainerStatuses &#123;</span><br><span class="line"><span class="keyword">if</span> cs.State.Waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">cs.State.Waiting.Reason = waitingReason</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, cs := <span class="keyword">range</span> apiPodStatus.ContainerStatuses &#123;</span><br><span class="line"><span class="keyword">if</span> cs.State.Waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">cs.State.Waiting.Reason = waitingReason</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record the time it takes for the pod to become running</span></span><br><span class="line"><span class="comment">// since kubelet first saw the pod if firstSeenTime is set.</span></span><br><span class="line">existingStatus, ok := kl.statusManager.GetPodStatus(pod.UID)</span><br><span class="line"><span class="keyword">if</span> !ok || existingStatus.Phase == v1.PodPending &amp;&amp; apiPodStatus.Phase == v1.PodRunning &amp;&amp;</span><br><span class="line">!firstSeenTime.IsZero() &#123;</span><br><span class="line">metrics.PodStartDuration.Observe(metrics.SinceInSeconds(firstSeenTime))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kl.statusManager.SetPodStatus(pod, apiPodStatus)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pods that are not runnable must be stopped - return a typed error to the pod worker</span></span><br><span class="line"><span class="keyword">if</span> !runnable.Admit &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;Pod is not runnable and must have running containers stopped&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID, <span class="string">&quot;message&quot;</span>, runnable.Message)</span><br><span class="line"><span class="keyword">var</span> syncErr <span class="type">error</span></span><br><span class="line">p := kubecontainer.ConvertPodStatusToRunningPod(kl.getRuntime().Type(), podStatus)</span><br><span class="line"><span class="keyword">if</span> err := kl.killPod(pod, p, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToKillPod, <span class="string">&quot;error killing pod: %v&quot;</span>, err)</span><br><span class="line">syncErr = fmt.Errorf(<span class="string">&quot;error killing pod: %v&quot;</span>, err)</span><br><span class="line">utilruntime.HandleError(syncErr)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// There was no error killing the pod, but the pod cannot be run.</span></span><br><span class="line"><span class="comment">// Return an error to signal that the sync loop should back off.</span></span><br><span class="line">syncErr = fmt.Errorf(<span class="string">&quot;pod cannot be run: %s&quot;</span>, runnable.Message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, syncErr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the network plugin is not ready, only start the pod if it uses the host network</span></span><br><span class="line"><span class="keyword">if</span> err := kl.runtimeState.networkErrors(); err != <span class="literal">nil</span> &amp;&amp; !kubecontainer.IsHostNetworkPod(pod) &#123;</span><br><span class="line">kl.recorder.Eventf(pod, v1.EventTypeWarning, events.NetworkNotReady, <span class="string">&quot;%s: %v&quot;</span>, NetworkNotReadyErrorMsg, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;%s: %v&quot;</span>, NetworkNotReadyErrorMsg, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ensure the kubelet knows about referenced secrets or configmaps used by the pod</span></span><br><span class="line"><span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line"><span class="keyword">if</span> kl.secretManager != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.secretManager.RegisterPod(pod)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> kl.configMapManager != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.configMapManager.RegisterPod(pod)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Cgroups for the pod and apply resource parameters</span></span><br><span class="line"><span class="comment">// to them if cgroups-per-qos flag is enabled.</span></span><br><span class="line">pcm := kl.containerManager.NewPodContainerManager()</span><br><span class="line"><span class="comment">// If pod has already been terminated then we need not create</span></span><br><span class="line"><span class="comment">// or update the pod&#x27;s cgroup</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> once context cancellation is added this check can be removed</span></span><br><span class="line"><span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line"><span class="comment">// When the kubelet is restarted with the cgroups-per-qos</span></span><br><span class="line"><span class="comment">// flag enabled, all the pod&#x27;s running containers</span></span><br><span class="line"><span class="comment">// should be killed intermittently and brought back up</span></span><br><span class="line"><span class="comment">// under the qos cgroup hierarchy.</span></span><br><span class="line"><span class="comment">// Check if this is the pod&#x27;s first sync</span></span><br><span class="line">firstSync := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> _, containerStatus := <span class="keyword">range</span> apiPodStatus.ContainerStatuses &#123;</span><br><span class="line"><span class="keyword">if</span> containerStatus.State.Running != <span class="literal">nil</span> &#123;</span><br><span class="line">firstSync = <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Don&#x27;t kill containers in pod if pod&#x27;s cgroups already</span></span><br><span class="line"><span class="comment">// exists or the pod is running for the first time</span></span><br><span class="line">podKilled := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> !pcm.Exists(pod) &amp;&amp; !firstSync &#123;</span><br><span class="line">p := kubecontainer.ConvertPodStatusToRunningPod(kl.getRuntime().Type(), podStatus)</span><br><span class="line"><span class="keyword">if</span> err := kl.killPod(pod, p, <span class="literal">nil</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">podKilled = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;KillPod failed&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podStatus&quot;</span>, podStatus)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Create and Update pod&#x27;s Cgroups</span></span><br><span class="line"><span class="comment">// Don&#x27;t create cgroups for run once pod if it was killed above</span></span><br><span class="line"><span class="comment">// The current policy is not to restart the run once pods when</span></span><br><span class="line"><span class="comment">// the kubelet is restarted with the new flag as run once pods are</span></span><br><span class="line"><span class="comment">// expected to run only once and if the kubelet is restarted then</span></span><br><span class="line"><span class="comment">// they are not expected to run again.</span></span><br><span class="line"><span class="comment">// We don&#x27;t create and apply updates to cgroup if its a run once pod and was killed above</span></span><br><span class="line"><span class="keyword">if</span> !(podKilled &amp;&amp; pod.Spec.RestartPolicy == v1.RestartPolicyNever) &#123;</span><br><span class="line"><span class="keyword">if</span> !pcm.Exists(pod) &#123;</span><br><span class="line"><span class="keyword">if</span> err := kl.containerManager.UpdateQOSCgroups(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;Failed to update QoS cgroups while syncing pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := pcm.EnsureExists(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToCreatePodContainer, <span class="string">&quot;unable to ensure pod container exists: %v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;failed to ensure that the pod: %v cgroups exist and are correctly applied: %v&quot;</span>, pod.UID, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Mirror Pod for Static Pod if it doesn&#x27;t already exist</span></span><br><span class="line"><span class="keyword">if</span> kubetypes.IsStaticPod(pod) &#123;</span><br><span class="line">deleted := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> mirrorPod != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> mirrorPod.DeletionTimestamp != <span class="literal">nil</span> || !kl.podManager.IsMirrorPodOf(mirrorPod, pod) &#123;</span><br><span class="line"><span class="comment">// The mirror pod is semantically different from the static pod. Remove</span></span><br><span class="line"><span class="comment">// it. The mirror pod will get recreated later.</span></span><br><span class="line">klog.InfoS(<span class="string">&quot;Trying to delete pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, mirrorPod.ObjectMeta.UID)</span><br><span class="line">podFullName := kubecontainer.GetPodFullName(pod)</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">deleted, err = kl.podManager.DeleteMirrorPod(podFullName, &amp;mirrorPod.ObjectMeta.UID)</span><br><span class="line"><span class="keyword">if</span> deleted &#123;</span><br><span class="line">klog.InfoS(<span class="string">&quot;Deleted mirror pod because it is outdated&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(mirrorPod))</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Failed deleting mirror pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(mirrorPod))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mirrorPod == <span class="literal">nil</span> || deleted &#123;</span><br><span class="line">node, err := kl.GetNode()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || node.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;No need to create a mirror pod, since node has been removed from the cluster&quot;</span>, <span class="string">&quot;node&quot;</span>, klog.KRef(<span class="string">&quot;&quot;</span>, <span class="type">string</span>(kl.nodeName)))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Creating a mirror pod for static pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="keyword">if</span> err := kl.podManager.CreateMirrorPod(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Failed creating a mirror pod for&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make data directories for the pod</span></span><br><span class="line"><span class="keyword">if</span> err := kl.makePodDataDirs(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToMakePodDataDirectories, <span class="string">&quot;error making pod data directories: %v&quot;</span>, err)</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Unable to make pod data directories for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Volume manager will not mount volumes for terminating pods</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> once context cancellation is added this check can be removed</span></span><br><span class="line"><span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line"><span class="comment">// Wait for volumes to attach/mount</span></span><br><span class="line"><span class="keyword">if</span> err := kl.volumeManager.WaitForAttachAndMount(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedMountVolume, <span class="string">&quot;Unable to attach or mount volumes: %v&quot;</span>, err)</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Unable to attach or mount volumes for pod; skipping pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the pull secrets for the pod</span></span><br><span class="line">pullSecrets := kl.getPullSecretsForPod(pod)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure the pod is being probed</span></span><br><span class="line">kl.probeManager.AddPod(pod)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the container runtime&#x27;s SyncPod callback</span></span><br><span class="line">result := kl.containerRuntime.SyncPod(pod, podStatus, pullSecrets, kl.backOff)</span><br><span class="line">kl.reasonCache.Update(pod.UID, result)</span><br><span class="line"><span class="keyword">if</span> err := result.Error(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Do not return error if the only failures were pods in backoff</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> result.SyncResults &#123;</span><br><span class="line"><span class="keyword">if</span> r.Error != kubecontainer.ErrCrashLoopBackOff &amp;&amp; r.Error != images.ErrImagePullBackOff &#123;</span><br><span class="line"><span class="comment">// Do not record an event here, as we keep all event logging for sync pod failures</span></span><br><span class="line"><span class="comment">// local to container runtime, so we get better errors.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><p>containerRuntime（pkg/kubelet/kuberuntime）子模块的 SyncPod 函数才是真正完成 pod 内容器实体的创建。</p><p><u><em>/pkg/kubelet/kuberuntime/kuberuntime_manager.go#668</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span></span> SyncPod(pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) &#123;</span><br><span class="line"><span class="comment">// Step 1: Compute sandbox and container changes.</span></span><br><span class="line">podContainerChanges := m.computePodActions(pod, podStatus)</span><br><span class="line">klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;computePodActions got for pod&quot;</span>, <span class="string">&quot;podActions&quot;</span>, podContainerChanges, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">ref, err := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Couldn&#x27;t make a ref to pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.SandboxID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">m.recorder.Eventf(ref, v1.EventTypeNormal, events.SandboxChanged, <span class="string">&quot;Pod sandbox changed, it will be killed and re-created.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncPod received new pod, will create a sandbox for it&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: Kill the pod if the sandbox has changed.</span></span><br><span class="line"><span class="keyword">if</span> podContainerChanges.KillPod &#123;</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Stopping PodSandbox for pod, will start new one&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Stopping PodSandbox for pod, because all other containers are dead&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">killResult := m.killPodWithSyncResult(pod, kubecontainer.ConvertPodStatusToRunningPod(m.runtimeName, podStatus), <span class="literal">nil</span>)</span><br><span class="line">result.AddPodSyncResult(killResult)</span><br><span class="line"><span class="keyword">if</span> killResult.Error() != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(killResult.Error(), <span class="string">&quot;killPodWithSyncResult failed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">m.purgeInitContainers(pod, podStatus)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Step 3: kill any running containers in this pod which are not to keep.</span></span><br><span class="line"><span class="keyword">for</span> containerID, containerInfo := <span class="keyword">range</span> podContainerChanges.ContainersToKill &#123;</span><br><span class="line">klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;Killing unwanted container for pod&quot;</span>, <span class="string">&quot;containerName&quot;</span>, containerInfo.name, <span class="string">&quot;containerID&quot;</span>, containerID, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">killContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, containerInfo.name)</span><br><span class="line">result.AddSyncResult(killContainerResult)</span><br><span class="line"><span class="keyword">if</span> err := m.killContainer(pod, containerID, containerInfo.name, containerInfo.message, containerInfo.reason, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">killContainerResult.Fail(kubecontainer.ErrKillContainer, err.Error())</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;killContainer for pod failed&quot;</span>, <span class="string">&quot;containerName&quot;</span>, containerInfo.name, <span class="string">&quot;containerID&quot;</span>, containerID, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep terminated init containers fairly aggressively controlled</span></span><br><span class="line"><span class="comment">// This is an optimization because container removals are typically handled</span></span><br><span class="line"><span class="comment">// by container garbage collector.</span></span><br><span class="line">m.pruneInitContainersBeforeStart(pod, podStatus)</span><br><span class="line"></span><br><span class="line"><span class="comment">// We pass the value of the PRIMARY podIP and list of podIPs down to</span></span><br><span class="line"><span class="comment">// generatePodSandboxConfig and generateContainerConfig, which in turn</span></span><br><span class="line"><span class="comment">// passes it to various other functions, in order to facilitate functionality</span></span><br><span class="line"><span class="comment">// that requires this value (hosts file and downward API) and avoid races determining</span></span><br><span class="line"><span class="comment">// the pod IP in cases where a container requires restart but the</span></span><br><span class="line"><span class="comment">// podIP isn&#x27;t in the status manager yet. The list of podIPs is used to</span></span><br><span class="line"><span class="comment">// generate the hosts file.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We default to the IPs in the passed-in pod status, and overwrite them if the</span></span><br><span class="line"><span class="comment">// sandbox needs to be (re)started.</span></span><br><span class="line"><span class="keyword">var</span> podIPs []<span class="type">string</span></span><br><span class="line"><span class="keyword">if</span> podStatus != <span class="literal">nil</span> &#123;</span><br><span class="line">podIPs = podStatus.IPs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: Create a sandbox for the pod if necessary.</span></span><br><span class="line">podSandboxID := podContainerChanges.SandboxID</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line"><span class="keyword">var</span> msg <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Creating PodSandbox for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">metrics.StartedPodsTotal.Inc()</span><br><span class="line">createSandboxResult := kubecontainer.NewSyncResult(kubecontainer.CreatePodSandbox, format.Pod(pod))</span><br><span class="line">result.AddSyncResult(createSandboxResult)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConvertPodSysctlsVariableToDotsSeparator converts sysctl variable</span></span><br><span class="line"><span class="comment">// in the Pod.Spec.SecurityContext.Sysctls slice into a dot as a separator.</span></span><br><span class="line"><span class="comment">// runc uses the dot as the separator to verify whether the sysctl variable</span></span><br><span class="line"><span class="comment">// is correct in a separate namespace, so when using the slash as the sysctl</span></span><br><span class="line"><span class="comment">// variable separator, runc returns an error: &quot;sysctl is not in a separate kernel namespace&quot;</span></span><br><span class="line"><span class="comment">// and the podSandBox cannot be successfully created. Therefore, before calling runc,</span></span><br><span class="line"><span class="comment">// we need to convert the sysctl variable, the dot is used as a separator to separate the kernel namespace.</span></span><br><span class="line"><span class="comment">// When runc supports slash as sysctl separator, this function can no longer be used.</span></span><br><span class="line">sysctl.ConvertPodSysctlsVariableToDotsSeparator(pod.Spec.SecurityContext)</span><br><span class="line"></span><br><span class="line">podSandboxID, msg, err = m.createPodSandbox(pod, podContainerChanges.Attempt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// createPodSandbox can return an error from CNI, CSI,</span></span><br><span class="line"><span class="comment">// or CRI if the Pod has been deleted while the POD is</span></span><br><span class="line"><span class="comment">// being created. If the pod has been deleted then it&#x27;s</span></span><br><span class="line"><span class="comment">// not a real error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SyncPod can still be running when we get here, which</span></span><br><span class="line"><span class="comment">// means the PodWorker has not acked the deletion.</span></span><br><span class="line"><span class="keyword">if</span> m.podStateProvider.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Pod was deleted and sandbox failed to be created&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">metrics.StartedPodsErrorsTotal.Inc()</span><br><span class="line">createSandboxResult.Fail(kubecontainer.ErrCreatePodSandbox, msg)</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;CreatePodSandbox for pod failed&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">ref, referr := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line"><span class="keyword">if</span> referr != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(referr, <span class="string">&quot;Couldn&#x27;t make a ref to pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line">m.recorder.Eventf(ref, v1.EventTypeWarning, events.FailedCreatePodSandBox, <span class="string">&quot;Failed to create pod sandbox: %v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Created PodSandbox for pod&quot;</span>, <span class="string">&quot;podSandboxID&quot;</span>, podSandboxID, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"></span><br><span class="line">resp, err := m.runtimeService.PodSandboxStatus(podSandboxID, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ref, referr := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line"><span class="keyword">if</span> referr != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(referr, <span class="string">&quot;Couldn&#x27;t make a ref to pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line">m.recorder.Eventf(ref, v1.EventTypeWarning, events.FailedStatusPodSandBox, <span class="string">&quot;Unable to get pod sandbox status: %v&quot;</span>, err)</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Failed to get pod sandbox status; Skipping pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">result.Fail(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> resp.GetStatus() == <span class="literal">nil</span> &#123;</span><br><span class="line">result.Fail(errors.New(<span class="string">&quot;pod sandbox status is nil&quot;</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we ever allow updating a pod from non-host-network to</span></span><br><span class="line"><span class="comment">// host-network, we may use a stale IP.</span></span><br><span class="line"><span class="keyword">if</span> !kubecontainer.IsHostNetworkPod(pod) &#123;</span><br><span class="line"><span class="comment">// Overwrite the podIPs passed in the pod status, since we just started the pod sandbox.</span></span><br><span class="line">podIPs = m.determinePodSandboxIPs(pod.Namespace, pod.Name, resp.GetStatus())</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Determined the ip for pod after sandbox changed&quot;</span>, <span class="string">&quot;IPs&quot;</span>, podIPs, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the start containers routines depend on pod ip(as in primary pod ip)</span></span><br><span class="line"><span class="comment">// instead of trying to figure out if we have 0 &lt; len(podIPs)</span></span><br><span class="line"><span class="comment">// everytime, we short circuit it here</span></span><br><span class="line">podIP := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(podIPs) != <span class="number">0</span> &#123;</span><br><span class="line">podIP = podIPs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get podSandboxConfig for containers to start.</span></span><br><span class="line">configPodSandboxResult := kubecontainer.NewSyncResult(kubecontainer.ConfigPodSandbox, podSandboxID)</span><br><span class="line">result.AddSyncResult(configPodSandboxResult)</span><br><span class="line">podSandboxConfig, err := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">message := fmt.Sprintf(<span class="string">&quot;GeneratePodSandboxConfig for pod %q failed: %v&quot;</span>, format.Pod(pod), err)</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;GeneratePodSandboxConfig for pod failed&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">configPodSandboxResult.Fail(kubecontainer.ErrConfigPodSandbox, message)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper containing boilerplate common to starting all types of containers.</span></span><br><span class="line"><span class="comment">// typeName is a description used to describe this type of container in log messages,</span></span><br><span class="line"><span class="comment">// currently: &quot;container&quot;, &quot;init container&quot; or &quot;ephemeral container&quot;</span></span><br><span class="line"><span class="comment">// metricLabel is the label used to describe this type of container in monitoring metrics.</span></span><br><span class="line"><span class="comment">// currently: &quot;container&quot;, &quot;init_container&quot; or &quot;ephemeral_container&quot;</span></span><br><span class="line">start := <span class="function"><span class="keyword">func</span><span class="params">(typeName, metricLabel <span class="type">string</span>, spec *startSpec)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">startContainerResult := kubecontainer.NewSyncResult(kubecontainer.StartContainer, spec.container.Name)</span><br><span class="line">result.AddSyncResult(startContainerResult)</span><br><span class="line"></span><br><span class="line">isInBackOff, msg, err := m.doBackOff(pod, spec.container, podStatus, backOff)</span><br><span class="line"><span class="keyword">if</span> isInBackOff &#123;</span><br><span class="line">startContainerResult.Fail(err, msg)</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Backing Off restarting container in pod&quot;</span>, <span class="string">&quot;containerType&quot;</span>, typeName, <span class="string">&quot;container&quot;</span>, spec.container, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">metrics.StartedContainersTotal.WithLabelValues(metricLabel).Inc()</span><br><span class="line"><span class="keyword">if</span> sc.HasWindowsHostProcessRequest(pod, spec.container) &#123;</span><br><span class="line">metrics.StartedHostProcessContainersTotal.WithLabelValues(metricLabel).Inc()</span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Creating container in pod&quot;</span>, <span class="string">&quot;containerType&quot;</span>, typeName, <span class="string">&quot;container&quot;</span>, spec.container, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="comment">// NOTE (aramase) podIPs are populated for single stack and dual stack clusters. Send only podIPs.</span></span><br><span class="line"><span class="keyword">if</span> msg, err := m.startContainer(podSandboxID, podSandboxConfig, spec, pod, podStatus, pullSecrets, podIP, podIPs); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// startContainer() returns well-defined error codes that have reasonable cardinality for metrics and are</span></span><br><span class="line"><span class="comment">// useful to cluster administrators to distinguish &quot;server errors&quot; from &quot;user errors&quot;.</span></span><br><span class="line">metrics.StartedContainersErrorsTotal.WithLabelValues(metricLabel, err.Error()).Inc()</span><br><span class="line"><span class="keyword">if</span> sc.HasWindowsHostProcessRequest(pod, spec.container) &#123;</span><br><span class="line">metrics.StartedHostProcessContainersErrorsTotal.WithLabelValues(metricLabel, err.Error()).Inc()</span><br><span class="line">&#125;</span><br><span class="line">startContainerResult.Fail(err, msg)</span><br><span class="line"><span class="comment">// known errors that are logged in other places are logged at higher levels here to avoid</span></span><br><span class="line"><span class="comment">// repetitive log spam</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> err == images.ErrImagePullBackOff:</span><br><span class="line">klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;Container start failed in pod&quot;</span>, <span class="string">&quot;containerType&quot;</span>, typeName, <span class="string">&quot;container&quot;</span>, spec.container, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;containerMessage&quot;</span>, msg, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;%v %+v start failed in pod %v: %v: %s&quot;</span>, typeName, spec.container, format.Pod(pod), err, msg))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 5: start ephemeral containers</span></span><br><span class="line"><span class="comment">// These are started &quot;prior&quot; to init containers to allow running ephemeral containers even when there</span></span><br><span class="line"><span class="comment">// are errors starting an init container. In practice init containers will start first since ephemeral</span></span><br><span class="line"><span class="comment">// containers cannot be specified on pod creation.</span></span><br><span class="line"><span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.EphemeralContainersToStart &#123;</span><br><span class="line">start(<span class="string">&quot;ephemeral container&quot;</span>, metrics.EphemeralContainer, ephemeralContainerStartSpec(&amp;pod.Spec.EphemeralContainers[idx]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 6: start the init container.</span></span><br><span class="line"><span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Start the next init container.</span></span><br><span class="line"><span class="keyword">if</span> err := start(<span class="string">&quot;init container&quot;</span>, metrics.InitContainer, containerStartSpec(container)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Successfully started the container; clear the entry in the failure</span></span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Completed init container for pod&quot;</span>, <span class="string">&quot;containerName&quot;</span>, container.Name, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 7: start containers in podContainerChanges.ContainersToStart.</span></span><br><span class="line"><span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123;</span><br><span class="line">start(<span class="string">&quot;container&quot;</span>, metrics.Container, containerStartSpec(&amp;pod.Spec.Containers[idx]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本来基于 kubernetnes : v1.25.4&lt;/p&gt;
&lt;p&gt;之前那篇文章对 kubelet 的工作原理做了简单的介绍，接下来，我们对 pod 创建的流程中，kubelet 创建 pod 进行一个详细的分析。&lt;/p&gt;
&lt;img src=&quot;kubelet-create-</summary>
      
    
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/categories/kubelet/"/>
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/tags/kubelet/"/>
    
    <category term="创建pod流程" scheme="http://lizhewei91.github.io/tags/%E5%88%9B%E5%BB%BApod%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何构建多CPU架构容器镜像</title>
    <link href="http://lizhewei91.github.io/2023/02/27/09/"/>
    <id>http://lizhewei91.github.io/2023/02/27/09/</id>
    <published>2023-02-27T04:47:09.000Z</published>
    <updated>2023-06-01T09:06:03.160Z</updated>
    
    <content type="html"><![CDATA[<p>构建多架构镜像的方法有两种：</p><ul><li>manifest</li><li>docker buildx</li></ul><h1 id="buildx"><a href="#buildx" class="headerlink" title="buildx"></a>buildx</h1><p>首先 docker 版本要在 19.03 以上（含），启动 docker buildx，<code>export DOCKER_CLI_EXPERIMENTAL=enabled</code></p><p>build-demo示例链接：<a href="https://github.com/lizhewei91/buildx-demo">https://github.com/lizhewei91/buildx-demo</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@build-cloud-product-clone-4 buildx-demo]# tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── buildx-demo</span><br><span class="line">├── Dockfile.buildx</span><br><span class="line">├── go.mod</span><br><span class="line">├── main.go</span><br><span class="line">└── Makefile</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-buildx-示例"><a href="#Dockerfile-buildx-示例" class="headerlink" title="Dockerfile.buildx 示例"></a>Dockerfile.buildx 示例</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> BASE_IMAGE</span><br><span class="line"><span class="keyword">ARG</span> BASE_IMAGE_VERSION</span><br><span class="line"><span class="keyword">FROM</span> --platform=$&#123;TARGETPLATFORM&#125; $&#123;BASE_IMAGE&#125;:$&#123;BASE_IMAGE_VERSION&#125; AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/buildx-demo</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> --platform=$&#123;TARGETPLATFORM&#125; alpine:<span class="number">3.17</span>.<span class="number">2</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /go/src/buildx-demo/bin/buildx-demo /usr/bin/buildx-demo</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/bin/buildx-demo&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="Makefile示例"><a href="#Makefile示例" class="headerlink" title="Makefile示例"></a>Makefile示例</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGET_PLATFORMS ?= linux/amd64,linux/arm64</span><br><span class="line">BASE_IMAGE ?= golang</span><br><span class="line">BASE_IMAGE_VERSION ?= alpine3.17</span><br><span class="line">IMAGE_REPO ?= hub.easystack.cn/multi/buildx-demo</span><br><span class="line">IMAGE_VERSION ?= v0.0.1</span><br><span class="line">DOCKER_HUB_REPO ?= hub.easystack.cn</span><br><span class="line">DOCKER_HUB_USERNAME ?= xxx</span><br><span class="line">DOCKER_HUB_PASSWORD ?= xxx</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="section">all: docker-hub-login build images</span></span><br><span class="line"></span><br><span class="line"><span class="section">docker-hub-login:</span></span><br><span class="line">        docker logout</span><br><span class="line">        docker login $&#123;DOCKER_HUB_REPO&#125; -u $&#123;DOCKER_HUB_USERNAME&#125; -p $&#123;DOCKER_HUB_PASSWORD&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">        go build -o /go/src/buildx-demo/bin/buildx-demo main.go</span><br><span class="line"></span><br><span class="line"><span class="section">images:</span></span><br><span class="line">        docker buildx build \</span><br><span class="line">                --build-arg BASE_IMAGE=<span class="variable">$(BASE_IMAGE)</span> \</span><br><span class="line">                --build-arg BASE_IMAGE_VERSION=<span class="variable">$(BASE_IMAGE_VERSION)</span> \</span><br><span class="line">                --platform <span class="variable">$(TARGET_PLATFORMS)</span> \</span><br><span class="line">                -t <span class="variable">$(IMAGE_REPO)</span>:<span class="variable">$(IMAGE_VERSION)</span> \</span><br><span class="line">                -f ./Dockfile.buildx --push .</span><br></pre></td></tr></table></figure><h2 id="验证镜像"><a href="#验证镜像" class="headerlink" title="验证镜像"></a>验证镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 拉去镜像到本地</span><br><span class="line">$ docker pull hub.easystack.cn/multi/buildx-demo:v0.0.1</span><br><span class="line"></span><br><span class="line">// 查看镜像信息</span><br><span class="line">$ docker manifest inspect hub.easystack.cn/multi/buildx-demo:v0.0.1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;schemaVersion&quot;</span>: 2,</span><br><span class="line">   <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.list.v2+json&quot;</span>,</span><br><span class="line">   <span class="string">&quot;manifests&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: 701,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:7d95c40e65abaa83c9d1a2e462026070f43f7ceaacba57f3c6a70fb840bcd196&quot;</span>,</span><br><span class="line">         <span class="string">&quot;platform&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;architecture&quot;</span>: <span class="string">&quot;amd64&quot;</span>,</span><br><span class="line">            <span class="string">&quot;os&quot;</span>: <span class="string">&quot;linux&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: 701,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:ff6b7d6df4241220f9c1f665864e7f009620a8c39edecf3b8463a62d01c6f228&quot;</span>,</span><br><span class="line">         <span class="string">&quot;platform&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;architecture&quot;</span>: <span class="string">&quot;arm64&quot;</span>,</span><br><span class="line">            <span class="string">&quot;os&quot;</span>: <span class="string">&quot;linux&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h1><h2 id="manifest是什么，干什么用？"><a href="#manifest是什么，干什么用？" class="headerlink" title="manifest是什么，干什么用？"></a>manifest是什么，干什么用？</h2><p>manifest是一个文件，这个文件包含了有关于镜像信息，如层、大小和摘要。docker manifest命令还向用户提供附加信息，比如构建镜像的操作系统和体系结构。而manifest list是一个镜像清单列表，用于存放多个不同os/arch的镜像信息。我们可以创建一个manifest list来指向两个镜像(一个linux 64位和一个指向arm64位的镜像)，然后对用户提供一个唯一的镜像名称。<strong>从Docker registry v2.3和Docker 1.10 开始，Docker hub就可以pull multi architecture Docker镜像了。</strong></p><p><strong>一个镜像的manifest文件信息如下：</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker manifest inspect java</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">&quot;schemaVersion&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;config&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.container.image.v1+json&quot;</span>,</span><br><span class="line">                <span class="string">&quot;size&quot;</span>: <span class="number">4733</span>,</span><br><span class="line">                <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:d23bdf5b1b1b1afce5f1d0fd33e7ed8afbc084b594b9ccf742a5b27080d8a4a8&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;layers&quot;</span>: [ #---镜像层的摘要信息</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;size&quot;</span>: <span class="number">51361210</span>,</span><br><span class="line">                        <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:5040bd2983909aa8896b9932438c3f1479d25ae837a5f6220242a264d0221f2d&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">...................</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个manifest list的例子如下：</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;schemaVersion&quot;</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.list.v2+json&quot;</span>,</span><br><span class="line">   <span class="string">&quot;manifests&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: <span class="number">1357</span>,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:9b47044b1e79b965a8e1653e7f9c04b5f63e00b9161bedd5baef69bb8b4c4834&quot;</span>,</span><br><span class="line">         <span class="string">&quot;platform&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;architecture&quot;</span>: <span class="string">&quot;amd64&quot;</span>,</span><br><span class="line">            <span class="string">&quot;os&quot;</span>: <span class="string">&quot;linux&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: <span class="number">1357</span>,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:8aecae775e1f81d3889929ef15647187b414c833b0798d060bfd778bee668ced&quot;</span>,</span><br><span class="line">         <span class="string">&quot;platform&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;architecture&quot;</span>: <span class="string">&quot;arm64&quot;</span>,</span><br><span class="line">            <span class="string">&quot;os&quot;</span>: <span class="string">&quot;linux&quot;</span>,</span><br><span class="line">            <span class="string">&quot;variant&quot;</span>: <span class="string">&quot;v8&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：manifest的功能目前仅仅作用于docker 官方的镜像仓库。</strong></p><p>总结：简单的说manifest list就是多个manifest的一个集合，通过列表方式来管理。</p><h2 id="manifest-list处理流程："><a href="#manifest-list处理流程：" class="headerlink" title="manifest list处理流程："></a>manifest list处理流程：</h2><img src="/2023/02/27/09/1676966412440-973b407a-131f-48d2-a414-1d2e0efec236.png" class="" title="img"><img src="/2023/02/27/09/1676966412789-274aaf7c-7f07-43c8-9479-171a5fc0a048.png" class="" title="img"><h2 id="开启docker子命令manifest功能："><a href="#开启docker子命令manifest功能：" class="headerlink" title="开启docker子命令manifest功能："></a>开启docker子命令manifest功能：</h2><p>manifest是做为docker客户端的子命令存在，不过这个子命令目前处在实验性中一般没有开启。我们需要手动开始这个子命令的功能。开启过程如下：</p><h3 id="编辑config-json"><a href="#编辑config-json" class="headerlink" title="编辑config.json"></a>编辑config.json</h3><p>docker 的默认配置文件config.json是在$HOME目录下的.docker目录下。编辑config.json文件，若目录和文件不存在手动创建。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim ~/.docker/config.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;experimental&quot;</span>: <span class="string">&quot;enabled&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编辑daemon-json"><a href="#编辑daemon-json" class="headerlink" title="编辑daemon.json"></a>编辑daemon.json</h3><p>编辑daemon.json，若目录和文件不存在手动创建</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;experimental&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br><span class="line">$ docker manifest --<span class="built_in">help</span>    <span class="comment">#----查看manifest帮助信息</span></span><br></pre></td></tr></table></figure><p>开启docker的实验性功能后docker pull可以拉取指定平台镜像如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull --platform arm64  镜像 --platform：该参数是用于拉取指定平台的镜像，也是实验性功能，在上面步骤中开启后就会出现。通 过该参数可以手动指定需要的CPU平台镜像，而不用自动去识别。</span><br></pre></td></tr></table></figure><h2 id="使用manifest创建多CPU架构的镜像："><a href="#使用manifest创建多CPU架构的镜像：" class="headerlink" title="使用manifest创建多CPU架构的镜像："></a>使用manifest创建多CPU架构的镜像：</h2><p>查看一个镜像的manifest文件信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest inspect nginx</span><br></pre></td></tr></table></figure><p>查看一个镜像的manifest文件的详细信息，包括cpu平台架构等信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest inspect --verbose nginx</span><br></pre></td></tr></table></figure><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>这里准备好了两个不同CPU架构的镜像如下：<br>这里的镜像是自己在docker hub上创建的仓库<br>xxx/public_docker:nginx-arm64<br>xxx/public_docker:nginx-x86<br><strong>必须将上面两个镜像推到docker hub上面</strong></p><h3 id="创建一个manifest-list列表："><a href="#创建一个manifest-list列表：" class="headerlink" title="创建一个manifest list列表："></a>创建一个manifest list列表：</h3><p>创建一个自定义命名的镜像名的manifest list，然后用该列表关联仓库里面的两个不同架构的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest create xxx/public_docker:nginx-v1 xxx/public_docker:nginx-arm64 xxx/public_docker:nginx-x86</span><br></pre></td></tr></table></figure><h3 id="docker-manifest-annotate-注释manifest-list"><a href="#docker-manifest-annotate-注释manifest-list" class="headerlink" title="docker manifest annotate 注释manifest list"></a>docker manifest annotate 注释manifest list</h3><p>我们按照上述方法创建出来的 manifest list 中并没有说明其中的 manifest 是什么操作系统和平台的，<code>docker manifest annotate</code> 命令用于注释创建出来的 manifest list。例如注释某个 manifest 是 <code>linxu</code>系统 <code>arm64</code> 平台的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest annotate xxx/public_docker:nginx-v1 xxx/public_docker:nginx-x86 –os linux –<span class="built_in">arch</span> amd64</span><br><span class="line">$ docker manifest annotate xxx/public_docker:nginx-v1 xxx/public_docker:nginx-arm64 –os linux –<span class="built_in">arch</span> arm64</span><br></pre></td></tr></table></figure><h3 id="将创建好的manifest-list-推到仓库中："><a href="#将创建好的manifest-list-推到仓库中：" class="headerlink" title="将创建好的manifest list 推到仓库中："></a>将创建好的manifest list 推到仓库中：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest push xxx/public_docker:nginx-v1</span><br></pre></td></tr></table></figure><h3 id="查看仓库中创建好的manifest-list："><a href="#查看仓库中创建好的manifest-list：" class="headerlink" title="查看仓库中创建好的manifest list："></a>查看仓库中创建好的manifest list：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest inspect xxx/public_docker:nginx-v1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;构建多架构镜像的方法有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;manifest&lt;/li&gt;
&lt;li&gt;docker buildx&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;buildx&quot;&gt;&lt;a href=&quot;#buildx&quot; class=&quot;headerlink&quot; title=&quot;buildx</summary>
      
    
    
    
    <category term="镜像" scheme="http://lizhewei91.github.io/categories/%E9%95%9C%E5%83%8F/"/>
    
    
    <category term="buildx" scheme="http://lizhewei91.github.io/tags/buildx/"/>
    
    <category term="manifest" scheme="http://lizhewei91.github.io/tags/manifest/"/>
    
  </entry>
  
  <entry>
    <title>在k8s中，实现应用配置文件热更新</title>
    <link href="http://lizhewei91.github.io/2023/02/10/44/"/>
    <id>http://lizhewei91.github.io/2023/02/10/44/</id>
    <published>2023-02-10T08:32:44.000Z</published>
    <updated>2023-06-01T09:02:14.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前，在k8s部署的工作负载使用 <code>ConfigMap</code> 或 <code>Secret</code>时，通过两种方式：</p><ul><li>环境变量 Env 方式挂载</li><li>文件方式挂载</li></ul><p>当更新 <code>ConfigMap </code>或 <code>Secret</code> 时，挂载到Pod中的数据存在两种情况：</p><ul><li>Env 方式挂载的环境变量不会同步更新</li><li>文件方式挂载的数据会同步更新（存在秒级延时）</li></ul><p>大部分场景下，在更新了 <code>ConfigMap</code> 或 <code>Secret</code> 中的信息后，都希望Pod内业务能读取到最新的值。通常都会手动去滚动更新一下Pod，重新读取环境变量或文件内容。当前社区已经有对应的开源工具 <a href="https://github.com/stakater/Reloader">Reloader</a> 实现了 <code>ConfigMap</code>/<code>Secret</code> 更新时自动触发Pod的滚动更新。</p><h1 id="Reloader介绍"><a href="#Reloader介绍" class="headerlink" title="Reloader介绍"></a>Reloader介绍</h1><p>Reloader 通过 watch <code>ConfigMap</code> 和 <code>Secret</code> 中的变化，对 <code>Deployment</code>、 <code>DaemonSet</code> 和 <code>StatefulSet</code> 等负载的 <code>Pod</code> 进行滚动升级。</p><p>官方文档：<a href="https://github.com/stakater/Reloader">Reloader</a></p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>Reloader 兼容的 K8s 版本为 &gt;=1.9。</p><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><p>以下使用Deployment举例：</p><ul><li>Deployment 中使用的所有 ConfigMap 和 Secret 变动都会触发 Pod 滚动更新</li></ul><p>在Deployment 的 <code>metadata.annotations</code> 中添加 <code>reloader.stakater.com/auto: &quot;true&quot;</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    reloader.stakater.com/<span class="keyword">auto</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="keyword">template</span>:</span><br></pre></td></tr></table></figure><ul><li>Deployment 中的部分 ConfigMap 和 Secret 变动会触发 Pod 滚动更新</li></ul><p>在 Deployment 的 <code>metadata.annotations</code>中添加<code>reloader.stakater.com/search: &quot;true&quot;</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    reloader.stakater.com/search: <span class="string">&quot;true&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="keyword">template</span>:</span><br></pre></td></tr></table></figure><p>同时在需要触发 Pod 更新的 ConfigMap 或 Secret 中的 <code>metadata.annotations</code>中添加 <code>reloader.stakater.com/match: &quot;true&quot;</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    reloader.stakater.com/match: <span class="string">&quot;true&quot;</span></span><br><span class="line">data:</span><br><span class="line">  key: <span class="keyword">value</span></span><br></pre></td></tr></table></figure><ul><li>Deployment 中指定 ConfigMap 或 Secret 的变动触发 Pod 滚动更新</li></ul><p>在Deployment 的 <code>metadata.annotations</code>中添加 <code>configmap.reloader.stakater.com/reload: &quot;foo-configmap,bar-configmap,baz-configmap&quot;</code>，指定这些 ConfigMap 才会触发 Pod 的更新。多个 ConfigMap 使用逗号分隔</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    configmap.reloader.stakater.com/reload: <span class="string">&quot;foo-configmap,bar-configmap,baz-configmap&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="keyword">template</span>: </span><br><span class="line">    metadata:</span><br></pre></td></tr></table></figure><p>在Deployment 的 <code>metadata.annotations</code> 中添加 <code>secret.reloader.stakater.com/reload: &quot;foo-secret,bar-secret,baz-secret&quot;</code>，指定这些 Secret 才会触发 Pod 的更新。多个 Secret 使用逗号分隔</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    secret.reloader.stakater.com/reload: <span class="string">&quot;foo-secret,bar-secret,baz-secret&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="keyword">template</span>: </span><br><span class="line">    metadata:</span><br></pre></td></tr></table></figure><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><ul><li>忽略 ConfigMap 或 Secret 变动（<strong>全局</strong>）</li></ul><p>在 Reloader deployment的 <code>spec.template.spec.container.args</code> 中添加参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>–resources-to-ignore=configMaps</td><td>忽略 configMaps 变动</td></tr><tr><td>–resources-to-ignore=secrets</td><td>忽略 secrets 变动</td></tr></tbody></table><p><code>--resources-to-ignore</code>参数只支持忽略一种资源，若要同时忽略 configMaps 和 secrets 的变动，则只需要把 Reloader 副本数降为0。</p><ul><li>通过使用 <code>--namespace-selector</code> 参数，Reloader可以配置为只监视带有(一个或多个)标签的命名空间，例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--namespace-selector=reloder:enabled,test:true</span><br></pre></td></tr></table></figure><p>只有标记为如下命名空间 YAML 的命名空间才会被监视：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kind: Namespace</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  ...</span><br><span class="line">  labels:</span><br><span class="line">    reloder: enabled</span><br><span class="line">    test: true</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>如果您只想通过标签的键选择命名空间，请使用 <code>&quot;*&quot;</code> 作为值。例如，对于 <code>--namespace-selector=select-this:*</code> 所有标签键为<code>&quot;select-this&quot;</code>的命名空间将被选中，而不管标签的值是多少。</p><h1 id="实战验证"><a href="#实战验证" class="headerlink" title="实战验证"></a>实战验证</h1><h2 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h2><ol><li>创建一个测试 namespace</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create ns ns1</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 reloader</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/stakater/Reloader/master/deployments/kubernetes/reloader.yaml</span><br></pre></td></tr></table></figure><ol start="3"><li>创建configmap</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-config-file</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ns1</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line"><span class="comment">#    reloader.stakater.com/match: &quot;true&quot;</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">info.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    user=lzw</span></span><br><span class="line"><span class="string">    age=30</span></span><br><span class="line"><span class="string"></span><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-config-env</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ns1</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line"><span class="comment">#    reloader.stakater.com/match: &quot;true&quot;</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">COUNTRY:</span> <span class="string">china</span></span><br><span class="line">  <span class="attr">CITY:</span> <span class="string">beijing</span></span><br></pre></td></tr></table></figure><ol start="4"><li>创建 deployment</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ns1</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line"><span class="comment">#    configmap.reloader.stakater.com/reload: &quot;test-config-file&quot;</span></span><br><span class="line"><span class="comment">#    reloader.stakater.com/search: &quot;true&quot;</span></span><br><span class="line">     <span class="attr">reloader.stakater.com/auto:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="comment"># Define the environment variable</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">COUNTRY</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">test-config-env</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">COUNTRY</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CITY</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">test-config-env</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">CITY</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">&quot;/etc/foo&quot;</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">test-config-file</span></span><br></pre></td></tr></table></figure><h2 id="Reloader功能验证"><a href="#Reloader功能验证" class="headerlink" title="Reloader功能验证"></a>Reloader功能验证</h2><ol><li>更新 configmap（以文件方式挂载）</li></ol><p>使用命令 <code>kubectl -nns1 edit cm test-config-file</code> 编辑configmap，设置 <code>user</code> 的值为 <code>ted</code>。查看pod已经滚动更新。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ kubectl edit cm -n ns1 test-config-file</span><br><span class="line">configmap/test-config-file edited</span><br><span class="line">➜ kubectl get pods -n ns1</span><br><span class="line">NAME                     READY   STATUS              RESTARTS   AGE</span><br><span class="line">nginx-5dff48f5dd-m528h   0/1     ContainerCreating   0          6s</span><br><span class="line">nginx-6f455f8cd5-9h7pp   1/1     Running             0          34m</span><br></pre></td></tr></table></figure><p>查看新启动 pod 中 configmap 所挂载的文件内容，发现 <code>user</code> 的值已经变为 <code>lzw-test</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ kubectl <span class="built_in">exec</span> -it nginx-5dff48f5dd-m528h  -nns1 -- <span class="built_in">cat</span> /etc/foo/info.yaml</span><br><span class="line">user=lzw-test</span><br><span class="line">age=30</span><br></pre></td></tr></table></figure><ol start="2"><li>更新 configmap（以环境变量方式注入）</li></ol><p>使用命令 <code>kubectl -nns1edit cm test-config-env</code> 编辑 configmap，设置 <code>CITY</code> 的值为 <code>shenzhen</code>。查看 pod 已经滚动更新。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ kubectl edit cm -n ns1 test-config-env</span><br><span class="line">configmap/test-config-env edited</span><br><span class="line">➜ kubectl get pods -n ns1</span><br><span class="line">NAME                     READY   STATUS              RESTARTS   AGE</span><br><span class="line">nginx-5b4cb86669-9cv6k   0/1     ContainerCreating   0          6s</span><br><span class="line">nginx-5dff48f5dd-m528h   1/1     Running             0          9m35s</span><br></pre></td></tr></table></figure><p>查看新启动 pod 中 configmap 所注入的环境变量，发现 <code>CITY</code> 的值已经变为 <code>shenzhen</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ kubectl <span class="built_in">exec</span> -it nginx-5b4cb86669-9cv6k -nns1 -- <span class="built_in">env</span>|grep CITY</span><br><span class="line">CITY=shenzhen</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>Reloader 自动触发滚动更新，可能会导致业务中断。使用该功能时需要评估 pod 滚动更新对业务带来的影响。</p></li><li><p><code>reloader.stakater.com/auto</code>的优先级高于 <code>reloader.stakater.com/search</code>。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;目前，在k8s部署的工作负载使用 &lt;code&gt;ConfigMap&lt;/code&gt; 或 &lt;code&gt;Secret&lt;/code&gt;时，通过两种方式：</summary>
      
    
    
    
    <category term="reloader" scheme="http://lizhewei91.github.io/categories/reloader/"/>
    
    
    <category term="reloader" scheme="http://lizhewei91.github.io/tags/reloader/"/>
    
    <category term="configMap" scheme="http://lizhewei91.github.io/tags/configMap/"/>
    
    <category term="secret" scheme="http://lizhewei91.github.io/tags/secret/"/>
    
  </entry>
  
  <entry>
    <title>用插件扩展 kubectl</title>
    <link href="http://lizhewei91.github.io/2023/02/10/25/"/>
    <id>http://lizhewei91.github.io/2023/02/10/25/</id>
    <published>2023-02-10T06:48:25.000Z</published>
    <updated>2023-06-01T09:10:18.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="krew"><a href="#krew" class="headerlink" title="krew"></a>krew</h1><h2 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h2><ol><li>你需要安装一个可用的 <code>kubectl</code> 可执行文件。</li></ol><h2 id="安装-krew"><a href="#安装-krew" class="headerlink" title="安装 krew"></a>安装 krew</h2><p>官方文档：<a href="https://krew.sigs.k8s.io/docs/user-guide/">https://krew.sigs.k8s.io/docs/user-guide/</a></p><p>安装 krew 插件管理器。Krew 是一个由 Kubernetes SIG CLI 社区维护的插件管理器。</p><ol><li><p>Make sure that <code>git</code> is installed.</p></li><li><p>Run this command to download and install <code>krew</code>:</p></li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(</span><br><span class="line">  <span class="built_in">set</span> -x; <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(mktemp -d)</span>&quot;</span> &amp;&amp;</span><br><span class="line">  OS=<span class="string">&quot;<span class="subst">$(uname | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)</span>&quot;</span> &amp;&amp;</span><br><span class="line">  ARCH=<span class="string">&quot;<span class="subst">$(uname -m | sed -e &#x27;s/x86_64/amd64/&#x27; -e &#x27;s/\(arm\)\(64\)\?.*/\1\2/&#x27; -e &#x27;s/aarch64$/arm64/&#x27;)</span>&quot;</span> &amp;&amp;</span><br><span class="line">  KREW=<span class="string">&quot;krew-<span class="variable">$&#123;OS&#125;</span>_<span class="variable">$&#123;ARCH&#125;</span>&quot;</span> &amp;&amp;</span><br><span class="line">  curl -fsSLO <span class="string">&quot;https://github.com/kubernetes-sigs/krew/releases/latest/download/<span class="variable">$&#123;KREW&#125;</span>.tar.gz&quot;</span> &amp;&amp;</span><br><span class="line">  tar zxvf <span class="string">&quot;<span class="variable">$&#123;KREW&#125;</span>.tar.gz&quot;</span> &amp;&amp;</span><br><span class="line">  ./<span class="string">&quot;<span class="variable">$&#123;KREW&#125;</span>&quot;</span> install krew</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="3"><li>Add the <code>$HOME/.krew/bin</code> directory to your PATH environment variable. To do this, update your <code>.bashrc</code> or <code>.zshrc</code> file and append the following line:</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$&#123;KREW_ROOT:-<span class="variable">$HOME</span>/.krew&#125;</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure><p>and restart your shell.</p><ol start="4"><li>Run <code>kubectl krew</code> to check the installation.</li></ol><h2 id="编写-kubectl-插件"><a href="#编写-kubectl-插件" class="headerlink" title="编写 kubectl 插件"></a>编写 kubectl 插件</h2><p>你可以用任何编程语言或脚本编写插件，允许你编写命令行命令。</p><p>不需要安装插件或预加载，插件可执行程序从 <code>kubectl</code> 二进制文件接收继承的环境， 插件根据其名称确定它希望实现的命令路径。 例如，名为 <code>kubectl-foo</code> 的插件提供了命令 <code>kubectl foo</code>。 必须将插件的可执行文件安装在 <code>PATH</code> 中的某个位置。</p><h3 id="示例插件"><a href="#示例插件" class="headerlink" title="示例插件"></a>示例插件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的参数处理</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;version&quot;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的参数处理</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;config&quot;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$KUBECONFIG</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I am a plugin named kubectl-foo&quot;</span></span><br></pre></td></tr></table></figure><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>要使用某插件，先要使其可执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">chmod</span> +x ./kubectl-foo</span><br></pre></td></tr></table></figure><p>并将它放在你的 <code>PATH</code> 中的任何地方：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">mv</span> ./kubectl-foo /usr/local/bin</span><br></pre></td></tr></table></figure><p>你现在可以调用你的插件作为 <code>kubectl</code> 命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl foo</span><br><span class="line"></span><br><span class="line">I am a plugin named kubectl-foo</span><br></pre></td></tr></table></figure><p>所有参数和标记按原样传递给可执行文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl foo version</span><br><span class="line"></span><br><span class="line">1.0.0</span><br></pre></td></tr></table></figure><p>所有环境变量也按原样传递给可执行文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ KUBECONFIG=/etc/kube/config kubectl foo config</span><br><span class="line"></span><br><span class="line">/etc/kube/config</span><br></pre></td></tr></table></figure><p>此外，传递给插件的第一个参数总是调用它的位置的绝对路径（在上面的例子中，<code>$0</code> 将等于 <code>/usr/local/bin/kubectl-foo</code>）。</p><h3 id="查看插件列表"><a href="#查看插件列表" class="headerlink" title="查看插件列表"></a>查看插件列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl plugin list</span><br><span class="line"></span><br><span class="line">The following compatible plugins are available:</span><br><span class="line"></span><br><span class="line">/root/.krew/bin/kubectl-krew</span><br><span class="line">/usr/local/bin/kubectl-foo           // kubectl-foo 为新添加的插件</span><br></pre></td></tr></table></figure><h2 id="分发-kubectl-插件"><a href="#分发-kubectl-插件" class="headerlink" title="分发 kubectl 插件"></a>分发 kubectl 插件</h2><p>参考：<a href="https://kubernetes.io/zh-cn/docs/tasks/extend-kubectl/kubectl-plugins/#%E5%88%86%E5%8F%91-kubectl-%E6%8F%92%E4%BB%B6">分发kubectl插件</a></p><h2 id="krew-相关命令"><a href="#krew-相关命令" class="headerlink" title="krew 相关命令"></a>krew 相关命令</h2><ol><li>升级</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl krew update</span><br></pre></td></tr></table></figure><ol start="2"><li>查看可用插件列表</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl krew search</span><br><span class="line"></span><br><span class="line">NAME             DESCRIPTION                                         INSTALLED</span><br><span class="line">access-matrix    Show an RBAC access matrix <span class="keyword">for</span> server resources     no</span><br><span class="line">advise-psp       Suggests PodSecurityPolicies <span class="keyword">for</span> cluster.           no</span><br><span class="line">auth-proxy       Authentication proxy to a pod or service            no</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="3"><li>关键字搜索</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl krew search pod</span><br><span class="line"></span><br><span class="line">NAME                DESCRIPTION                                         INSTALLED</span><br><span class="line">evict-pod           Evicts the given pod                                no</span><br><span class="line">pod-dive            Shows a pod<span class="string">&#x27;s workload tree and info inside a node  no</span></span><br><span class="line"><span class="string">pod-logs            Display a list of pods to get logs from             no</span></span><br><span class="line"><span class="string">pod-shell           Display a list of pods to execute a shell in        no</span></span><br></pre></td></tr></table></figure><ol start="4"><li>查看插件详情</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl krew info tree</span><br><span class="line"></span><br><span class="line">NAME: tree</span><br><span class="line">VERSION: v0.4.0</span><br><span class="line">DESCRIPTION:</span><br><span class="line">  This plugin shows sub-resources of a specified Kubernetes API object <span class="keyword">in</span> a</span><br><span class="line">  tree view <span class="keyword">in</span> the command-line. The parent-child relationship is discovered</span><br><span class="line">  using ownerReferences on the child object.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;krew&quot;&gt;&lt;a href=&quot;#krew&quot; class=&quot;headerlink&quot; title=&quot;krew&quot;&gt;&lt;/a&gt;krew&lt;/h1&gt;&lt;h2 id=&quot;准备开始&quot;&gt;&lt;a href=&quot;#准备开始&quot; class=&quot;headerlink&quot; title=&quot;准备开始&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="kubectl 插件" scheme="http://lizhewei91.github.io/categories/kubectl-%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="kubectl-plugins" scheme="http://lizhewei91.github.io/tags/kubectl-plugins/"/>
    
    <category term="krew" scheme="http://lizhewei91.github.io/tags/krew/"/>
    
  </entry>
  
  <entry>
    <title>kubelet-device-manager 源码分析</title>
    <link href="http://lizhewei91.github.io/2023/01/16/19/"/>
    <id>http://lizhewei91.github.io/2023/01/16/19/</id>
    <published>2023-01-16T06:24:19.000Z</published>
    <updated>2023-06-01T09:02:31.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建-DeviceManager"><a href="#创建-DeviceManager" class="headerlink" title="创建 DeviceManager"></a>创建 DeviceManager</h1><p>Device Manager 和 cgroup Manager、QoS Container Manager 等一样，都属于 kubelet 管理的众多 Manager 之一。Device Manager在 kubelet 启动时的 NewContainerManager 中创建。</p><p><u><em>kubernetes/pkg/kubelet/cm/container_manager_linux.go#198</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContainerManager</span><span class="params">(mountUtil mount.Interface, cadvisorInterface cadvisor.Interface, nodeConfig NodeConfig, failSwapOn <span class="type">bool</span>, devicePluginEnabled <span class="type">bool</span>, recorder record.EventRecorder)</span></span> (ContainerManager, <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">cm := &amp;containerManagerImpl&#123;</span><br><span class="line">cadvisorInterface:   cadvisorInterface,</span><br><span class="line">mountUtil:           mountUtil,</span><br><span class="line">NodeConfig:          nodeConfig,</span><br><span class="line">subsystems:          subsystems,</span><br><span class="line">cgroupManager:       cgroupManager,</span><br><span class="line">capacity:            capacity,</span><br><span class="line">internalCapacity:    internalCapacity,</span><br><span class="line">cgroupRoot:          cgroupRoot,</span><br><span class="line">recorder:            recorder,</span><br><span class="line">qosContainerManager: qosContainerManager,</span><br><span class="line">&#125;</span><br><span class="line">... </span><br><span class="line">klog.InfoS(<span class="string">&quot;Creating device plugin manager&quot;</span>, <span class="string">&quot;devicePluginEnabled&quot;</span>, devicePluginEnabled)</span><br><span class="line"><span class="keyword">if</span> devicePluginEnabled &#123;</span><br><span class="line">cm.deviceManager, err = devicemanager.NewManagerImpl(machineInfo.Topology, cm.topologyManager)</span><br><span class="line">cm.topologyManager.AddHintProvider(cm.deviceManager)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cm.deviceManager, err = devicemanager.NewManagerStub()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">return</span> cm, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ManagerImpl结构体"><a href="#ManagerImpl结构体" class="headerlink" title="ManagerImpl结构体"></a>ManagerImpl结构体</h2><p>我们有必要先了解 Device Manager 的结构体：</p><p><u><em>kubernetes/pkg/kubelet/cm/devicemanager/manager.go#57</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ManagerImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">checkpointdir <span class="type">string</span></span><br><span class="line"></span><br><span class="line">endpoints <span class="keyword">map</span>[<span class="type">string</span>]endpointInfo <span class="comment">// Key is ResourceName</span></span><br><span class="line">mutex     sync.Mutex</span><br><span class="line"></span><br><span class="line">server plugin.Server</span><br><span class="line"></span><br><span class="line"><span class="comment">// activePods is a method for listing active pods on the node</span></span><br><span class="line"><span class="comment">// so the amount of pluginResources requested by existing pods</span></span><br><span class="line"><span class="comment">// could be counted when updating allocated devices</span></span><br><span class="line">activePods ActivePodsFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// sourcesReady provides the readiness of kubelet configuration sources such as apiserver update readiness.</span></span><br><span class="line"><span class="comment">// We use it to determine when we can purge inactive pods from checkpointed state.</span></span><br><span class="line">sourcesReady config.SourcesReady</span><br><span class="line"></span><br><span class="line"><span class="comment">// allDevices holds all the devices currently registered to the device manager</span></span><br><span class="line">allDevices ResourceDeviceInstances</span><br><span class="line"></span><br><span class="line"><span class="comment">// healthyDevices contains all of the registered healthy resourceNames and their exported device IDs.</span></span><br><span class="line">healthyDevices <span class="keyword">map</span>[<span class="type">string</span>]sets.String</span><br><span class="line"></span><br><span class="line"><span class="comment">// unhealthyDevices contains all of the unhealthy devices and their exported device IDs.</span></span><br><span class="line">unhealthyDevices <span class="keyword">map</span>[<span class="type">string</span>]sets.String</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocatedDevices contains allocated deviceIds, keyed by resourceName.</span></span><br><span class="line">allocatedDevices <span class="keyword">map</span>[<span class="type">string</span>]sets.String</span><br><span class="line"></span><br><span class="line"><span class="comment">// podDevices contains pod to allocated device mapping.</span></span><br><span class="line">podDevices        *podDevices</span><br><span class="line">checkpointManager checkpointmanager.CheckpointManager</span><br><span class="line"></span><br><span class="line"><span class="comment">// List of NUMA Nodes available on the underlying machine</span></span><br><span class="line">numaNodes []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Store of Topology Affinties that the Device Manager can query.</span></span><br><span class="line">topologyAffinityStore topologymanager.Store</span><br><span class="line"></span><br><span class="line"><span class="comment">// devicesToReuse contains devices that can be reused as they have been allocated to</span></span><br><span class="line"><span class="comment">// init containers.</span></span><br><span class="line">devicesToReuse PodReusableDevices</span><br><span class="line"></span><br><span class="line"><span class="comment">// pendingAdmissionPod contain the pod during the admission phase</span></span><br><span class="line">pendingAdmissionPod *v1.Pod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是核心字段 的说明：</p><ul><li><p><strong>checkpointdir：</strong>kubelet对外暴露的socket文件，/var/lib/kubelet/device-plugins/kubelet.sock</p></li><li><p><strong>endpoints：</strong>map对象，key 为 Resource Name，value 为 endpoint 接口( 包括 getPreferredAllocation、allocate、preStartContainer、setStopTime、isStopped、stopGracePeriodExpired )，每个 endpoint 接口对应一个已注册的 device plugin，负责与 device plugin 的 gRPC 通信及缓存 device plugin 反馈的 device states。</p></li><li><p><strong>server：</strong>暴漏一个 gRPC 服务。</p></li><li><p><strong>activePods：</strong>用来获取该节点上所有 active pods，即 non-Terminated 状态的 Pods。在 kubelet 的initializeRuntimeDependentModules 时会注册 activePods Func 为如下函数</p></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> GetActivePods() []*v1.Pod &#123;</span><br><span class="line">allPods := kl.podManager.GetPods()</span><br><span class="line">activePods := kl.filterOutInactivePods(allPods)</span><br><span class="line"><span class="keyword">return</span> activePods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>allDevices：</strong>保存当前注册到设备管理器的所有设备</p></li><li><p> <strong>healthyDevices:</strong> map对象，key为 Resource Name，value为对应的健康的 device IDs。 </p></li><li><p> **unhealthyDevices: **map对象，key为 Resource Name，value为对应的不健康的 device IDs。</p></li><li><p><strong>allocatedDevices:</strong>  map对象，key为Resource Name，value为已经分配出去的device IDs。</p></li><li><p><strong>podDevices：</strong>记录每一个pod中每个容器的设备分配情况</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建-DeviceManager&quot;&gt;&lt;a href=&quot;#创建-DeviceManager&quot; class=&quot;headerlink&quot; title=&quot;创建 DeviceManager&quot;&gt;&lt;/a&gt;创建 DeviceManager&lt;/h1&gt;&lt;p&gt;Device Manager</summary>
      
    
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/categories/kubelet/"/>
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/tags/kubelet/"/>
    
    <category term="device-manager" scheme="http://lizhewei91.github.io/tags/device-manager/"/>
    
  </entry>
  
  <entry>
    <title>kubelet 工作原理分析</title>
    <link href="http://lizhewei91.github.io/2023/01/11/14/"/>
    <id>http://lizhewei91.github.io/2023/01/11/14/</id>
    <published>2023-01-11T11:32:14.000Z</published>
    <updated>2023-06-01T09:01:31.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。</p><h1 id="kubelet-主要功能"><a href="#kubelet-主要功能" class="headerlink" title="kubelet 主要功能"></a>kubelet 主要功能</h1><p>kubelet 默认监听四个端口，分别为 10250 、10255、10248、4194。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LISTEN     0      128          *:10250           *:*                   users ((&quot;kubelet&quot;,pid=48500,fd=28))</span><br><span class="line">LISTEN     0      128          *:10255           *:*                   users:((&quot;kubelet&quot;,pid=48500,fd=26))</span><br><span class="line">LISTEN     0      128          *:4194            *:*                   users:((&quot;kubelet&quot;,pid=48500,fd=13))</span><br><span class="line">LISTEN     0      128    127.0.0.1:10248         *:*                   users:((&quot;kubelet&quot;,pid=48500,fd=23))</span><br></pre></td></tr></table></figure><ul><li><p><strong>10250（kubelet API）</strong>：kubelet server 与 apiserver 通信的端口，定期请求 apiserver 获取自己所应当处理的任务，通过该端口可以访问获取 node 资源以及状态。</p></li><li><p><strong>10248（健康检查端口）</strong>：通过访问该端口可以判断 kubelet 是否正常工作, 通过 kubelet 的启动参数 <code>--healthz-port</code> 和 <code>--healthz-bind-address</code> 来指定监听的地址和端口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:10248/healthz </span><br><span class="line">ok</span><br></pre></td></tr></table></figure></li><li><p><strong>4194（cAdvisor 监听）</strong>：kublet 通过该端口可以获取到该节点的环境信息以及 node 上运行的容器状态等内容，访问 <a href="http://localhost:4194/">http://localhost:4194</a> 可以看到 cAdvisor 的管理界面,通过 kubelet 的启动参数 <code>--cadvisor-port</code> 可以指定启动的端口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl  http://127.0.0.1:4194/metrics</span><br></pre></td></tr></table></figure></li><li><p><strong>10255 （readonly API</strong>）：提供了 pod 和 node 的信息，接口以只读形式暴露出去，访问该端口不需要认证和鉴权。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  获取 pod 的接口，与 apiserver 的 </span><br><span class="line">// http://127.0.0.1:8080/api/v1/pods?fieldSelector=spec.nodeName=  接口类似</span><br><span class="line">$ curl  http://127.0.0.1:10255/pods</span><br><span class="line"></span><br><span class="line">// 节点信息接口,提供磁盘、网络、CPU、内存等信息</span><br><span class="line">$ curl http://127.0.0.1:10255/spec/</span><br></pre></td></tr></table></figure></li></ul><h2 id="pod管理"><a href="#pod管理" class="headerlink" title="pod管理"></a>pod管理</h2><p>Kubelet 以 PodSpec 的方式工作。PodSpec 是描述一个 Pod 的 YAML 或 JSON 对象。 kubelet 采用一组通过各种机制提供的 PodSpecs（主要通过 apiserver），并确保这些 PodSpecs 中描述的 Pod 正常健康运行。</p><p>官方提供了3种方式来获取容器信息：</p><ul><li>apiserver：通过 API Server 监听 etcd 目录获取数据；</li><li>File：启动参数 –config 指定的配置目录下的文件；</li><li>通过 url 从网络上某个地址来获取信息</li></ul><p>拿apiserver来说，如果Kubelet 监听到etcd中有新的绑定到本节点的 Pod，则按照 Pod 清单的要求创建该 Pod；如果发现本地的 Pod 被修改，则 Kubelet 会做出相应的修改。</p><h2 id="容器健康检查"><a href="#容器健康检查" class="headerlink" title="容器健康检查"></a>容器健康检查</h2><p>容器健康检查这个我们在前面已经聊过，主要是通过LivenessProbe 与ReadinessProbe来判断容器是否健康。</p><ul><li>LivenessProbe ：用于判断容器是否健康，告诉 Kubelet 一个容器什么时候处于不健康的状态。如果 LivenessProbe 探针探测到容器不健康，则 Kubelet 将删除该容器，并根据容器的重启策略做相应的处理。如果一个容器不包含 LivenessProbe 探针，那么 Kubelet 认为该容器的 LivenessProbe 探针返回的值永远是 “Success”；</li><li>ReadinessProbe：用于判断容器是否启动完成且准备接收请求。如果 ReadinessProbe 探针探测到失败，则 Pod 的状态将被修改。Endpoint Controller 将从 Service 的 Endpoint 中删除包含该容器所在 Pod 的 IP 地址的 Endpoint 条目。</li></ul><h2 id="容器监控"><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h2><p>Kubelet 通过 cAdvisor 获取其所在节点及容器的数据。cAdvisor 是一个开源的分析容器资源使用率和性能特性的代理工具，集成到 Kubelet中，当Kubelet启动时会同时启动cAdvisor，且一个cAdvisor只监控一个Node节点的信息。cAdvisor 自动查找所有在其所在节点上的容器，自动采集 CPU、内存、文件系统和网络使用的统计信息。cAdvisor 通过它所在节点机的 Root 容器，采集并分析该节点机的全面使用情况。</p><h1 id="kubelet组件中的模块"><a href="#kubelet组件中的模块" class="headerlink" title="kubelet组件中的模块"></a>kubelet组件中的模块</h1><img src="/2023/01/11/14/kubelet-8175571.png" class=""><h1 id="kubelet-工作原理"><a href="#kubelet-工作原理" class="headerlink" title="kubelet 工作原理"></a>kubelet 工作原理</h1><p>其实，kubelet也是按照“控制器”的模式来工作的，它的实际工作原理，可以用如下的一张图表示：</p><img src="/2023/01/11/14/1620.png" class="" title="img"><p>可以看到，kubelet的工作核心，就是一个控制循环，即: SyncLoop ( 图中的大圆圈 )。而驱动这个控制循环的事件，包括四种：</p><ol><li>Pod 更新事件</li><li>Pod 生命周期变化</li><li>kubelet 本身设置的执行周期</li><li>定时的清理事件</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器</summary>
      
    
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/categories/kubelet/"/>
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/tags/kubelet/"/>
    
  </entry>
  
  <entry>
    <title>NVIDIA/kubevirt-gpu-device-plugin源码分析</title>
    <link href="http://lizhewei91.github.io/2023/01/10/32/"/>
    <id>http://lizhewei91.github.io/2023/01/10/32/</id>
    <published>2023-01-10T08:38:32.000Z</published>
    <updated>2023-06-01T09:01:56.564Z</updated>
    
    <content type="html"><![CDATA[<p>NVIDIA K8s Device Plugin为Kubevirt虚拟机分配gpu和vgpu，该篇文章基于NVIDIA/kubevirt-gpu-device-plugin:v1.2.1，<a href="https://github.com/NVIDIA/kubevirt-gpu-device-plugin/tree/v1.2.1">https://github.com/NVIDIA/kubevirt-gpu-device-plugin/tree/v1.2.1</a></p><h1 id="kubevirt-gpu-device-plugin启动"><a href="#kubevirt-gpu-device-plugin启动" class="headerlink" title="kubevirt-gpu-device-plugin启动"></a>kubevirt-gpu-device-plugin启动</h1><p>还是一样的套路，一切从main.go开始</p><p><u><em>Kubevirt-gpu-device-plugin/cmd/main.go#33</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">device_plugin.InitiateDevicePlugin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数调用 InitiateDevicePlugin 函数，直接看 InitiateDevicePlugin</p><p><u><em>Kubevirt-gpu-device-plugin/pkg/device_plugin/device_plugin.go#73</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitiateDevicePlugin</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Identifies GPUs and represents it in appropriate structures</span></span><br><span class="line">createIommuDeviceMap()</span><br><span class="line"><span class="comment">//Identifies vGPUs and represents it in appropriate structures</span></span><br><span class="line">createVgpuIDMap()</span><br><span class="line"><span class="comment">//Creates and starts device plugin</span></span><br><span class="line">createDevicePlugins()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InitiateDevicePlugin 函数主要做三件事：</p><ol><li>发现所有加载了 VFIO-PCI 驱动程序的 Nvidia gpu，并创建相应的映射</li><li>发现节点上配置的所有 Nvidia vgpu，并创建相应的映射</li><li>创建并启动 device-plugin</li></ol><h2 id="CreateIommuDeviceMap"><a href="#CreateIommuDeviceMap" class="headerlink" title="CreateIommuDeviceMap"></a>CreateIommuDeviceMap</h2><p><u><em>Kubevirt-gpu-device-plugin/pkg/device-plugin/device-plugin.go#155</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discovers all Nvidia GPUs which are loaded with VFIO-PCI driver and creates corresponding maps</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createIommuDeviceMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">iommuMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]NvidiaGpuDevice)</span><br><span class="line">deviceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line"><span class="comment">//Walk directory to discover pci devices</span></span><br><span class="line">filepath.Walk(basePath, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error accessing file path %q: %v\n&quot;</span>, path, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Not a device, continuing&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Retrieve vendor for the device</span></span><br><span class="line">vendorID, err := readIDFromFile(basePath, info.Name(), <span class="string">&quot;vendor&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get vendor ID for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Nvidia vendor id is &quot;10de&quot;. Proceed if vendor id is 10de</span></span><br><span class="line"><span class="keyword">if</span> vendorID == <span class="string">&quot;10de&quot;</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Nvidia device &quot;</span>, info.Name())</span><br><span class="line"><span class="comment">//Retrieve iommu group for the device</span></span><br><span class="line">driver, err := readLink(basePath, info.Name(), <span class="string">&quot;driver&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get driver for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> driver == <span class="string">&quot;vfio-pci&quot;</span> &#123;</span><br><span class="line">iommuGroup, err := readLink(basePath, info.Name(), <span class="string">&quot;iommu_group&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get IOMMU Group for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;Iommu Group &quot;</span> + iommuGroup)</span><br><span class="line">_, exists := iommuMap[iommuGroup]</span><br><span class="line"><span class="keyword">if</span> !exists &#123;</span><br><span class="line">deviceID, err := readIDFromFile(basePath, info.Name(), <span class="string">&quot;device&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could get deviceID for PCI address &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Device Id %s&quot;</span>, deviceID)</span><br><span class="line">deviceMap[deviceID] = <span class="built_in">append</span>(deviceMap[deviceID], iommuGroup)</span><br><span class="line">&#125;</span><br><span class="line">iommuMap[iommuGroup] = <span class="built_in">append</span>(iommuMap[iommuGroup], NvidiaGpuDevice&#123;info.Name()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createIommuDeviceMap的主要流程如下图：</p><img src="/2023/01/10/32/createIommuDeviceMap.png" class="" title="createIommuDeviceMap"><h2 id="CreateVgpuIDMap"><a href="#CreateVgpuIDMap" class="headerlink" title="CreateVgpuIDMap"></a>CreateVgpuIDMap</h2><p><u><em>Kubevirt-gpu-device-plugin/pkg/device-plugin/device-plugin.go#208</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discovers all Nvidia vGPUs configured on a node and creates corresponding maps</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createVgpuIDMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">vGpuMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]NvidiaGpuDevice)</span><br><span class="line">gpuVgpuMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line"><span class="comment">//Walk directory to discover vGPU devices</span></span><br><span class="line">filepath.Walk(vGpuBasePath, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error accessing file path %q: %v\n&quot;</span>, path, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Not a device, continuing&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Read vGPU type name</span></span><br><span class="line">vGpuID, err := readVgpuIDFromFile(vGpuBasePath, info.Name(), <span class="string">&quot;mdev_type/name&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get vGPU type identifier for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Retrieve the gpu ID for this vGPU</span></span><br><span class="line">gpuID, err := readGpuIDForVgpu(vGpuBasePath, info.Name())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get vGPU type identifier for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Gpu id is %s&quot;</span>, gpuID)</span><br><span class="line">log.Printf(<span class="string">&quot;Vgpu id is %s&quot;</span>, vGpuID)</span><br><span class="line">gpuVgpuMap[gpuID] = <span class="built_in">append</span>(gpuVgpuMap[gpuID], info.Name())</span><br><span class="line">vGpuMap[vGpuID] = <span class="built_in">append</span>(vGpuMap[vGpuID], NvidiaGpuDevice&#123;info.Name()&#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/10/32/createVgpuIDMap.png" class="" title="createVgpuIDMap"><ol><li>通过filePath.Walk遍历“/sys/bus/mdev/devices”目录下的所有文件，得到所有 vgpu 相应设备文件</li><li>读取readVgpuIDFromFile(“/sys/bus/mdev/devices”,info.Name(),”mdev_type/name”)，获得vgpu的vGpuID</li><li>读取readGpuIDFromVgpu(“/sys/bus/mdev/devices”,info.Name())，获取vgpu对应的gpuID</li><li>最后，通过 gpuVgpuMap=map[ <gpuID> ] []string{ <vgpu-id1>,<vgpu-id2>…} 和 vGpuMap=map[ <vGpuID> ] []NvidiaGpuDevice{ {addr:<addr1>},{addr:<addr2>}} 存储映射关系。</li></ol><h2 id="CreateDevicePlugins"><a href="#CreateDevicePlugins" class="headerlink" title="CreateDevicePlugins"></a>CreateDevicePlugins</h2><p><u><em>Kubevirt-gpu-device-plugin/pkg/device-plugin/device-plugin.go#82</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Starts gpu pass through and vGPU device plugin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createDevicePlugins</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> devicePlugins []*GenericDevicePlugin</span><br><span class="line"><span class="keyword">var</span> vGpuDevicePlugins []*GenericVGpuDevicePlugin</span><br><span class="line"><span class="keyword">var</span> devs []*pluginapi.Device</span><br><span class="line">log.Printf(<span class="string">&quot;Iommu Map %s&quot;</span>, iommuMap)</span><br><span class="line">log.Printf(<span class="string">&quot;Device Map %s&quot;</span>, deviceMap)</span><br><span class="line">log.Println(<span class="string">&quot;vGPU Map &quot;</span>, vGpuMap)</span><br><span class="line">log.Println(<span class="string">&quot;GPU vGPU Map &quot;</span>, gpuVgpuMap)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Iterate over deivceMap to create device plugin for each type of GPU on the host</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> deviceMap &#123;</span><br><span class="line">devs = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> v &#123;</span><br><span class="line">devs = <span class="built_in">append</span>(devs, &amp;pluginapi.Device&#123;</span><br><span class="line">ID:     dev,</span><br><span class="line">Health: pluginapi.Healthy,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">deviceName := getDeviceName(k)</span><br><span class="line"><span class="keyword">if</span> deviceName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error: Could not find device name for device id: %s&quot;</span>, k)</span><br><span class="line">deviceName = k</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;DP Name %s&quot;</span>, deviceName)</span><br><span class="line">dp := NewGenericDevicePlugin(deviceName, <span class="string">&quot;/sys/kernel/iommu_groups/&quot;</span>, devs)</span><br><span class="line">err := startDevicePlugin(dp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error starting %s device plugin: %v&quot;</span>, dp.deviceName, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">devicePlugins = <span class="built_in">append</span>(devicePlugins, dp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Iterate over vGpuMap to create device plugin for each type of vGPU on the host</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> vGpuMap &#123;</span><br><span class="line">devs = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> v &#123;</span><br><span class="line">devs = <span class="built_in">append</span>(devs, &amp;pluginapi.Device&#123;</span><br><span class="line">ID:     dev.addr,</span><br><span class="line">Health: pluginapi.Healthy,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">deviceName := getDeviceName(k)</span><br><span class="line"><span class="keyword">if</span> deviceName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">deviceName = k</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;DP Name %s&quot;</span>, deviceName)</span><br><span class="line">dp := NewGenericVGpuDevicePlugin(deviceName, vGpuBasePath, devs)</span><br><span class="line">err := startVgpuDevicePlugin(dp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error starting %s device plugin: %v&quot;</span>, dp.deviceName, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">vGpuDevicePlugins = <span class="built_in">append</span>(vGpuDevicePlugins, dp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-stop</span><br><span class="line">log.Printf(<span class="string">&quot;Shutting down device plugin controller&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> devicePlugins &#123;</span><br><span class="line">v.Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createDevicePlugin的流程图如下：</p><img src="/2023/01/10/32/kubevirt-device-plugin.png" class="" title="kubevirt-device-plugin"><p>启动kubevirt-gpu-device-plugin步骤主要有以下几点：</p><ol><li>遍历 deviveMap 将所有 device 设备类型下的所有 gpu 标记为 healthy </li><li>remove 并重建 socket 文件（”/var/lib/kubelet/device-plugins”+”kubevirt-<deviceName>.sock”）</li><li>启动 devicePlugin 的 grpc server，对外提供服务</li><li>请求kubelet socket链接，进行Regster</li><li>启动一个协程对设备进行healthCheck，并监听device-plguin自身socket文件</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>kubevirt-gpu-device-plugin使用前提，是用户使用 vfio-pci 将设备透传至 vm 内，然后，通过读取 vm 内的 pci 设备文件，获取设备的相关信息。iommu,vfio-pci等相关的内容，后续有时间会再补充。</p><h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><p><a href="https://rtoax.blog.csdn.net/article/details/110843839#t11">https://rtoax.blog.csdn.net/article/details/110843839#t11</a></p><p><a href="https://cloud.tencent.com/developer/article/1816469">https://cloud.tencent.com/developer/article/1816469</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;NVIDIA K8s Device Plugin为Kubevirt虚拟机分配gpu和vgpu，该篇文章基于NVIDIA/kubevirt-gpu-device-plugin:v1.2.1，&lt;a href=&quot;https://github.com/NVIDIA/kubevirt</summary>
      
    
    
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/categories/device-plugins/"/>
    
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/tags/device-plugins/"/>
    
    <category term="gpu" scheme="http://lizhewei91.github.io/tags/gpu/"/>
    
    <category term="kubevirt-gpu-device-plugin" scheme="http://lizhewei91.github.io/tags/kubevirt-gpu-device-plugin/"/>
    
  </entry>
  
  <entry>
    <title>NVIDIA/k8s-device-plugin源码分析</title>
    <link href="http://lizhewei91.github.io/2023/01/06/46/"/>
    <id>http://lizhewei91.github.io/2023/01/06/46/</id>
    <published>2023-01-06T07:43:46.000Z</published>
    <updated>2023-06-01T09:01:49.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="device-plugin启动"><a href="#device-plugin启动" class="headerlink" title="device-plugin启动"></a>device-plugin启动</h1><p>该篇文章基于NVIDIA/k8s-device-plugin: v0.13.0，<a href="https://github.com/NVIDIA/k8s-device-plugin/tree/v0.13.0">https://github.com/NVIDIA/k8s-device-plugin/tree/v0.13.0</a></p><p>一切从 main 函数开始作为入口：</p><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/main.go#35</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> configFile <span class="type">string</span></span><br><span class="line"></span><br><span class="line">c := cli.NewApp()</span><br><span class="line">c.Name = <span class="string">&quot;NVIDIA Device Plugin&quot;</span></span><br><span class="line">c.Usage = <span class="string">&quot;NVIDIA device plugin for Kubernetes&quot;</span></span><br><span class="line">c.Version = info.GetVersionString()</span><br><span class="line">c.Action = <span class="function"><span class="keyword">func</span><span class="params">(ctx *cli.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> start(ctx, c.Flags)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 接下来，调用 start 函数</p><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/main.go#133</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">(c *cli.Context, flags []cli.Flag)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Starting FS watcher.&quot;</span>)</span><br><span class="line">watcher, err := newFSWatcher(pluginapi.DevicePluginPath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create FS watcher: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> watcher.Close()</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Starting OS watcher.&quot;</span>)</span><br><span class="line">sigs := newOSWatcher(syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> restarting <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> restartTimeout &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line"><span class="keyword">var</span> plugins []*NvidiaDevicePlugin</span><br><span class="line">restart:</span><br><span class="line"><span class="comment">// If we are restarting, stop plugins from previous run.</span></span><br><span class="line"><span class="keyword">if</span> restarting &#123;</span><br><span class="line">err := stopPlugins(plugins)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error stopping plugins from previous run: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Starting Plugins.&quot;</span>)</span><br><span class="line">plugins, restartPlugins, err := startPlugins(c, flags, restarting)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error starting plugins: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> restartPlugins &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Failed to start one or more plugins. Retrying in 30s...&quot;</span>)</span><br><span class="line">restartTimeout = time.After(<span class="number">30</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restarting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start an infinite loop, waiting for several indicators to either log</span></span><br><span class="line"><span class="comment">// some messages, trigger a restart of the plugins, or exit the program.</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// If the restart timout has expired, then restart the plugins</span></span><br><span class="line"><span class="keyword">case</span> &lt;-restartTimeout:</span><br><span class="line"><span class="keyword">goto</span> restart</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a kubelet restart by watching for a newly created</span></span><br><span class="line"><span class="comment">// &#x27;pluginapi.KubeletSocket&#x27; file. When this occurs, restart this loop,</span></span><br><span class="line"><span class="comment">// restarting all of the plugins in the process.</span></span><br><span class="line"><span class="keyword">case</span> event := &lt;-watcher.Events:</span><br><span class="line"><span class="keyword">if</span> event.Name == pluginapi.KubeletSocket &amp;&amp; event.Op&amp;fsnotify.Create == fsnotify.Create &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;inotify: %s created, restarting.&quot;</span>, pluginapi.KubeletSocket)</span><br><span class="line"><span class="keyword">goto</span> restart</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Watch for any other fs errors and log them.</span></span><br><span class="line"><span class="keyword">case</span> err := &lt;-watcher.Errors:</span><br><span class="line">log.Printf(<span class="string">&quot;inotify: %s&quot;</span>, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Watch for any signals from the OS. On SIGHUP, restart this loop,</span></span><br><span class="line"><span class="comment">// restarting all of the plugins in the process. On all other</span></span><br><span class="line"><span class="comment">// signals, exit the loop and exit the program.</span></span><br><span class="line"><span class="keyword">case</span> s := &lt;-sigs:</span><br><span class="line"><span class="keyword">switch</span> s &#123;</span><br><span class="line"><span class="keyword">case</span> syscall.SIGHUP:</span><br><span class="line">log.Println(<span class="string">&quot;Received SIGHUP, restarting.&quot;</span>)</span><br><span class="line"><span class="keyword">goto</span> restart</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">log.Printf(<span class="string">&quot;Received signal \&quot;%v\&quot;, shutting down.&quot;</span>, s)</span><br><span class="line"><span class="keyword">goto</span> exit</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">exit:</span><br><span class="line">err = stopPlugins(plugins)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error stopping plugins: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/06/46/k8s-device-plugin%E5%90%AF%E5%8A%A8.png" class="" title="k8s-device-plugin启动"><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#92</em></u></p><p>K8s-device-plugin的启动流程中，nvidiaDevicePlugin.Start主要有三个步骤，1.启动device-plugin的grpc服务；2.向kubelet注册；3.启动协程对设备checkHealth。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Start() <span class="type">error</span> &#123;</span><br><span class="line">plugin.initialize()</span><br><span class="line"></span><br><span class="line">err := plugin.Serve()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Could not start device plugin for &#x27;%s&#x27;: %s&quot;</span>, plugin.rm.Resource(), err)</span><br><span class="line">plugin.cleanup()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Starting to serve &#x27;%s&#x27; on %s&quot;</span>, plugin.rm.Resource(), plugin.socket)</span><br><span class="line"></span><br><span class="line">err = plugin.Register()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Could not register device plugin: %s&quot;</span>, err)</span><br><span class="line">plugin.Stop()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Registered device plugin for &#x27;%s&#x27; with Kubelet&quot;</span>, plugin.rm.Resource())</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := plugin.rm.CheckHealth(plugin.stop, plugin.health)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Failed to start health check: %v; continuing with health checks disabled&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/06/46/start%E6%B5%81%E7%A8%8B.png" class="" title="startl流程"><h3 id="Serve"><a href="#Serve" class="headerlink" title="Serve"></a>Serve</h3><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#136</em></u></p><p>k8s-device-plugin 启动 gRPC 服务，对外提供服务</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Serve() <span class="type">error</span> &#123;</span><br><span class="line">os.Remove(plugin.socket)</span><br><span class="line">sock, err := net.Listen(<span class="string">&quot;unix&quot;</span>, plugin.socket)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pluginapi.RegisterDevicePluginServer(plugin.server, plugin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">lastCrashTime := time.Now()</span><br><span class="line">restartCount := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Starting GRPC server for &#x27;%s&#x27;&quot;</span>, plugin.rm.Resource())</span><br><span class="line">err := plugin.server.Serve(sock)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;GRPC server for &#x27;%s&#x27; crashed with error: %v&quot;</span>, plugin.rm.Resource(), err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// restart if it has not been too often</span></span><br><span class="line"><span class="comment">// i.e. if server has crashed more than 5 times and it didn&#x27;t last more than one hour each time</span></span><br><span class="line"><span class="keyword">if</span> restartCount &gt; <span class="number">5</span> &#123;</span><br><span class="line"><span class="comment">// quit</span></span><br><span class="line">log.Fatalf(<span class="string">&quot;GRPC server for &#x27;%s&#x27; has repeatedly crashed recently. Quitting&quot;</span>, plugin.rm.Resource())</span><br><span class="line">&#125;</span><br><span class="line">timeSinceLastCrash := time.Since(lastCrashTime).Seconds()</span><br><span class="line">lastCrashTime = time.Now()</span><br><span class="line"><span class="keyword">if</span> timeSinceLastCrash &gt; <span class="number">3600</span> &#123;</span><br><span class="line"><span class="comment">// it has been one hour since the last crash.. reset the count</span></span><br><span class="line"><span class="comment">// to reflect on the frequency</span></span><br><span class="line">restartCount = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">restartCount++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for server to start by launching a blocking connexion</span></span><br><span class="line">conn, err := plugin.dial(plugin.socket, <span class="number">5</span>*time.Second)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/06/46/serve%E5%90%AF%E5%8A%A8.png" class="" title="serve启动"><p>serve主要负责重建nvidia.sock文件，并且注册5个grpc接口到grpc.Server。</p><h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#186</em></u></p><p>Serve之后，接着进入Register流程，其代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Register() <span class="type">error</span> &#123;</span><br><span class="line">conn, err := plugin.dial(pluginapi.KubeletSocket, <span class="number">5</span>*time.Second)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">client := pluginapi.NewRegistrationClient(conn)</span><br><span class="line">reqt := &amp;pluginapi.RegisterRequest&#123;</span><br><span class="line">Version:      pluginapi.Version,</span><br><span class="line">Endpoint:     path.Base(plugin.socket),</span><br><span class="line">ResourceName: <span class="type">string</span>(plugin.rm.Resource()),</span><br><span class="line">Options: &amp;pluginapi.DevicePluginOptions&#123;</span><br><span class="line">GetPreferredAllocationAvailable: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = client.Register(context.Background(), reqt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Register的实现流程图如下：</p><img src="/2023/01/06/46/register%E6%B5%81%E7%A8%8B.png" class="" title="register流程"><ul><li>注册的Resource Name是<code>nvidia.com/gpu</code></li><li>注册的Version是<code>v1beta1</code></li></ul><h3 id="CheckHealth"><a href="#CheckHealth" class="headerlink" title="CheckHealth"></a>CheckHealth</h3><p><u><em>k8s-device-plugin/internal/rm/health.go#42</em></u></p><p>启动协程开始对管理的devices进行健康状态空空，一旦发现有device unhealthy，则发送到NvidiaDevicePlugin的health channel。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *nvmlResourceManager)</span></span> checkHealth(stop &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, devices Devices, unhealthy <span class="keyword">chan</span>&lt;- *Device) <span class="type">error</span> &#123;</span><br><span class="line">disableHealthChecks := strings.ToLower(os.Getenv(envDisableHealthChecks))</span><br><span class="line"><span class="keyword">if</span> disableHealthChecks == <span class="string">&quot;all&quot;</span> &#123;</span><br><span class="line">disableHealthChecks = allHealthChecks</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> strings.Contains(disableHealthChecks, <span class="string">&quot;xids&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret := r.nvml.Init()</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line"><span class="keyword">if</span> *r.config.Flags.FailOnInitError &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to initialize NVML: %v&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret := r.nvml.Shutdown()</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error shutting down NVML: %v&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> formalize the full list and document it.</span></span><br><span class="line"><span class="comment">// http://docs.nvidia.com/deploy/xid-errors/index.html#topic_4</span></span><br><span class="line"><span class="comment">// Application errors: the GPU should still be healthy</span></span><br><span class="line">applicationErrorXids := []<span class="type">uint64</span>&#123;</span><br><span class="line"><span class="number">13</span>, <span class="comment">// Graphics Engine Exception</span></span><br><span class="line"><span class="number">31</span>, <span class="comment">// GPU memory page fault</span></span><br><span class="line"><span class="number">43</span>, <span class="comment">// GPU stopped processing</span></span><br><span class="line"><span class="number">45</span>, <span class="comment">// Preemptive cleanup, due to previous errors</span></span><br><span class="line"><span class="number">68</span>, <span class="comment">// Video processor exception</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skippedXids := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]<span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> _, id := <span class="keyword">range</span> applicationErrorXids &#123;</span><br><span class="line">skippedXids[id] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, additionalXid := <span class="keyword">range</span> getAdditionalXids(disableHealthChecks) &#123;</span><br><span class="line">skippedXids[additionalXid] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eventSet, ret := r.nvml.EventSetCreate()</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create event set: %v&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> eventSet.Free()</span><br><span class="line"></span><br><span class="line">parentToDeviceMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*Device)</span><br><span class="line">deviceIDToGiMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">deviceIDToCiMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">eventMask := <span class="type">uint64</span>(nvml.EventTypeXidCriticalError | nvml.EventTypeDoubleBitEccError | nvml.EventTypeSingleBitEccError)</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> devices &#123;</span><br><span class="line">uuid, gi, ci, err := r.getDevicePlacement(d)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Warning: could not determine device placement for %v: %v; Marking it unhealthy.&quot;</span>, d.ID, err)</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">deviceIDToGiMap[d.ID] = gi</span><br><span class="line">deviceIDToCiMap[d.ID] = ci</span><br><span class="line">parentToDeviceMap[uuid] = d</span><br><span class="line"></span><br><span class="line">gpu, ret := r.nvml.DeviceGetHandleByUUID(uuid)</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;unable to get device handle from UUID: %v; marking it as unhealthy&quot;</span>, ret)</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">supportedEvents, ret := gpu.GetSupportedEventTypes()</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;unabled to determine the supported events for %v: %v; marking it as unhealthy&quot;</span>, d.ID, ret)</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = gpu.RegisterEvents(eventMask&amp;supportedEvents, eventSet)</span><br><span class="line"><span class="keyword">if</span> ret == nvml.ERROR_NOT_SUPPORTED &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Warning: Device %v is too old to support healthchecking.&quot;</span>, d.ID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Marking device %v as unhealthy: %v&quot;</span>, d.ID, ret)</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stop:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e, ret := eventSet.Wait(<span class="number">5000</span>)</span><br><span class="line"><span class="keyword">if</span> ret == nvml.ERROR_TIMEOUT &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error waiting for event: %v; Marking all devices as unhealthy&quot;</span>, ret)</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> devices &#123;</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e.EventType != nvml.EventTypeXidCriticalError &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Skipping non-nvmlEventTypeXidCriticalError event: %+v&quot;</span>, e)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> skippedXids[e.EventData] &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Skipping event %+v&quot;</span>, e)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Processing event %+v&quot;</span>, e)</span><br><span class="line">eventUUID, ret := e.Device.GetUUID()</span><br><span class="line"><span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line"><span class="comment">// If we cannot reliably determine the device UUID, we mark all devices as unhealthy.</span></span><br><span class="line">log.Printf(<span class="string">&quot;Failed to determine uuid for event %v: %v; Marking all devices as unhealthy.&quot;</span>, e, ret)</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> devices &#123;</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d, exists := parentToDeviceMap[eventUUID]</span><br><span class="line"><span class="keyword">if</span> !exists &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Ignoring event for unexpected device: %v&quot;</span>, eventUUID)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> d.IsMigDevice() &amp;&amp; e.GpuInstanceId != <span class="number">0xFFFFFFFF</span> &amp;&amp; e.ComputeInstanceId != <span class="number">0xFFFFFFFF</span> &#123;</span><br><span class="line">gi := deviceIDToGiMap[d.ID]</span><br><span class="line">ci := deviceIDToCiMap[d.ID]</span><br><span class="line"><span class="keyword">if</span> !(<span class="type">uint32</span>(gi) == e.GpuInstanceId &amp;&amp; <span class="type">uint32</span>(ci) == e.ComputeInstanceId) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Event for mig device %v (gi=%v, ci=%v)&quot;</span>, d.ID, gi, ci)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;XidCriticalError: Xid=%d on Device=%s; marking device as unhealthy.&quot;</span>, e.EventData, d.ID)</span><br><span class="line">unhealthy &lt;- d</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checkhealth的主要原理图如下：</p><img src="/2023/01/06/46/checkhealth.png" class="" title="checkhealth"><p>需要特别说明<code>healthcheck</code>部分：</p><ul><li>healthcheck启动协程对管理的devices进行健康状态监控，一旦发现有device unhealthy，则发送到NvidiaDevicePlugin的health channel。device plugin的ListAndWatch会从health channel中获取这些unhealthy devices，并通知到kubelet进行更新。</li><li>只监控<code>EventTypeXidCriticalError</code>事件，一旦监控到某个device的这个Event，就认为该device unhealthy。关于<code>EventTypeXidCriticalError</code>的说明，请参考NVIDIA的<a href="https://docs.nvidia.com/deploy/nvml-api/group__nvmlEventType.html">nvml api文档</a>。</li><li>可以通过设置NVIDIA device plugin Pod内的环境变量<code>DP_DISABLE_HEALTHCHECKS</code>为”all”来取消healthcheck。不设置或者设置为其他值都会启动healthcheck，默认部署时不设置。</li></ul><h2 id="stopPlugins"><a href="#stopPlugins" class="headerlink" title="stopPlugins"></a>stopPlugins</h2><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/main.go#275</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Stop() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> plugin == <span class="literal">nil</span> || plugin.server == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Stopping to serve &#x27;%s&#x27; on %s&quot;</span>, plugin.rm.Resource(), plugin.socket)</span><br><span class="line">plugin.server.Stop()</span><br><span class="line"><span class="keyword">if</span> err := os.Remove(plugin.socket); err != <span class="literal">nil</span> &amp;&amp; !os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">plugin.cleanup()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/06/46/stop-plugins.png" class="" title="stop-plugins"><p>stopPlugins主要做三件事：</p><ol><li>停止 device-plugin 的 grpc server</li><li>移除 plugin socket 文件 （/var/lib/kubelet/device-plugins/nvidia-gpu.sock）</li><li>清空 nvidiaDevicePlugin 相关字段。（plugin.server=nil; plugin.health=nil; plugin.stop=nil）</li></ol><h2 id="ListAndWatch"><a href="#ListAndWatch" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h2><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#219</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> ListAndWatch(e *pluginapi.Empty, s pluginapi.DevicePlugin_ListAndWatchServer) <span class="type">error</span> &#123;</span><br><span class="line">s.Send(&amp;pluginapi.ListAndWatchResponse&#123;Devices: plugin.apiDevices()&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-plugin.stop:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> d := &lt;-plugin.health:</span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> there is no way to recover from the Unhealthy state.</span></span><br><span class="line">d.Health = pluginapi.Unhealthy</span><br><span class="line">log.Printf(<span class="string">&quot;&#x27;%s&#x27; device marked unhealthy: %s&quot;</span>, plugin.rm.Resource(), d.ID)</span><br><span class="line">s.Send(&amp;pluginapi.ListAndWatchResponse&#123;Devices: plugin.apiDevices()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>listAndWatch 的实现流程图如下：</p><img src="/2023/01/06/46/listAndWatch.png" class="" title="listAndWatch"><h2 id="Allocate"><a href="#Allocate" class="headerlink" title="Allocate"></a>Allocate</h2><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#254</em></u></p><p>allocateRequest的请求结构体如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AllocateRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">ContainerRequests    []*ContainerAllocateRequest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ContainerAllocateRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">DevicesIDs           []<span class="type">string</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>allocateResponse的结构体如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AllocateResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">ContainerResponses   []*ContainerAllocateResponse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ContainerAllocateResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Envs                <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> </span><br><span class="line">Mounts              []*Mount </span><br><span class="line">Devices             []*DeviceSpec</span><br><span class="line">Annotations         <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Allocate 在容器创建期间调用，这样设备插件可以运行一些特定于设备的操作，并告诉 kubelet 如何令 Device 可在容器中访问的所需执行的具体步骤。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Allocate(ctx context.Context, reqs *pluginapi.AllocateRequest) (*pluginapi.AllocateResponse, <span class="type">error</span>) &#123;</span><br><span class="line">responses := pluginapi.AllocateResponse&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, req := <span class="keyword">range</span> reqs.ContainerRequests &#123;</span><br><span class="line"><span class="comment">// If the devices being allocated are replicas, then (conditionally)</span></span><br><span class="line"><span class="comment">// error out if more than one resource is being allocated.</span></span><br><span class="line"><span class="keyword">if</span> plugin.config.Sharing.TimeSlicing.FailRequestsGreaterThanOne &amp;&amp; rm.AnnotatedIDs(req.DevicesIDs).AnyHasAnnotations() &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(req.DevicesIDs) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;request for &#x27;%v: %v&#x27; too large: maximum request size for shared resources is 1&quot;</span>, plugin.rm.Resource(), <span class="built_in">len</span>(req.DevicesIDs))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, id := <span class="keyword">range</span> req.DevicesIDs &#123;</span><br><span class="line"><span class="keyword">if</span> !plugin.rm.Devices().Contains(id) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;invalid allocation request for &#x27;%s&#x27;: unknown device: %s&quot;</span>, plugin.rm.Resource(), id)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response := pluginapi.ContainerAllocateResponse&#123;&#125;</span><br><span class="line"></span><br><span class="line">ids := req.DevicesIDs</span><br><span class="line">deviceIDs := plugin.deviceIDsFromAnnotatedDeviceIDs(ids)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> *plugin.config.Flags.Plugin.DeviceListStrategy == spec.DeviceListStrategyEnvvar &#123;</span><br><span class="line">response.Envs = plugin.apiEnvs(plugin.deviceListEnvvar, deviceIDs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *plugin.config.Flags.Plugin.DeviceListStrategy == spec.DeviceListStrategyVolumeMounts &#123;</span><br><span class="line">response.Envs = plugin.apiEnvs(plugin.deviceListEnvvar, []<span class="type">string</span>&#123;deviceListAsVolumeMountsContainerPathRoot&#125;)</span><br><span class="line">response.Mounts = plugin.apiMounts(deviceIDs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *plugin.config.Flags.Plugin.PassDeviceSpecs &#123;</span><br><span class="line">response.Devices = plugin.apiDeviceSpecs(*plugin.config.Flags.NvidiaDriverRoot, ids)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *plugin.config.Flags.GDSEnabled &#123;</span><br><span class="line">response.Envs[<span class="string">&quot;NVIDIA_GDS&quot;</span>] = <span class="string">&quot;enabled&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *plugin.config.Flags.MOFEDEnabled &#123;</span><br><span class="line">response.Envs[<span class="string">&quot;NVIDIA_MOFED&quot;</span>] = <span class="string">&quot;enabled&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">responses.ContainerResponses = <span class="built_in">append</span>(responses.ContainerResponses, &amp;response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;responses, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/06/46/allocate.png" class="" title="allocate"><ul><li>Allocate中会遍历ContainerRequests，将DeviceIDs封装到ContainerAllocateResponse的<code>Envs:NVIDIA_VISIBLE_DEVICES</code>中，格式为：”<code>$&#123;ID_1&#125;,$&#123;ID_2&#125;,...</code>”</li><li>除此之外，并没有封装Mounts, Devices, Annotations。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>NVIDIA/k8s-device-plugin的代码中，依赖于nvidia-docker代码库，存在很多golang调用C库的地方，还需要大家自行到 <a href="https://docs.nvidia.com/deploy/nvml-api">nvml api文档</a> 中查看相关C函数声明。这篇博客介绍NVIDIA/k8s-device-plugin的代码实现流程，下一篇博客我觉得还有必要对kubelet device plugin manger进行代码分析，如此才能完整的理解整个交互细节。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;device-plugin启动&quot;&gt;&lt;a href=&quot;#device-plugin启动&quot; class=&quot;headerlink&quot; title=&quot;device-plugin启动&quot;&gt;&lt;/a&gt;device-plugin启动&lt;/h1&gt;&lt;p&gt;该篇文章基于NVIDIA/k8s-d</summary>
      
    
    
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/categories/device-plugins/"/>
    
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/tags/device-plugins/"/>
    
    <category term="nvidia" scheme="http://lizhewei91.github.io/tags/nvidia/"/>
    
    <category term="gpu" scheme="http://lizhewei91.github.io/tags/gpu/"/>
    
  </entry>
  
  <entry>
    <title>浅谈k8s中device-plugins机制</title>
    <link href="http://lizhewei91.github.io/2022/11/29/16/"/>
    <id>http://lizhewei91.github.io/2022/11/29/16/</id>
    <published>2022-11-29T02:53:16.000Z</published>
    <updated>2023-06-01T09:01:18.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Extended-Resource"><a href="#Extended-Resource" class="headerlink" title="Extended Resource"></a>Extended Resource</h1><p>官方链接：<a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/extended-resource-node/">extended-resource-node</a></p><p><strong>特性状态</strong>： <code>Kubernetes v1.9 [stable]</code></p><p>可以用一句话来概括这个特性：通过向apiserver发送一个 patch node 的请求，为这个node增加一个自定义的资源类型，用于以该资源的配额统计和相应的QoS的配置。</p><h2 id="为节点增加扩展资源"><a href="#为节点增加扩展资源" class="headerlink" title="为节点增加扩展资源"></a>为节点增加扩展资源</h2><p>为在一个节点上发布一种新的扩展资源，需要发送一个 HTTP PATCH 请求到 Kubernetes API server。 例如：假设你的一个节点上带有四个 dongle 资源。 下面是一个 PATCH 请求的示例，该请求为你的节点发布四个 dongle 资源。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/json-patch+json</span><br><span class="line">Host: k8s-master:8080</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;op&quot;: &quot;add&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;4&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>注意：Kubernetes 不需要了解 dongle 资源的含义和用途。 前面的 PATCH 请求告诉 Kubernetes 你的节点拥有四个你称之为 dongle 的东西。</p></blockquote><p>启动一个代理（proxy），以便你可以很容易地向 Kubernetes API server 发送请求：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure><p>在另一个命令窗口中，发送 HTTP PATCH 请求。 用你的节点名称替换 <code>&lt;your-node-name&gt;</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --header &quot;Content-Type: application/json-patch+json&quot; \</span><br><span class="line">  --request PATCH \</span><br><span class="line">  --data &#x27;[&#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;, &quot;value&quot;: &quot;4&quot;&#125;]&#x27; \</span><br><span class="line">  http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong> 在前面的请求中，<code>~1</code> 为 patch 路径中 “/” 符号的编码。 JSON-Patch 中的操作路径值被解析为 JSON 指针。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl describe node &lt;your-node-name&gt;</span><br></pre></td></tr></table></figure><img src="/2022/11/29/16/image-20221129110411083.png" class="" title="image-20221129110411083"><h2 id="清理扩展资源"><a href="#清理扩展资源" class="headerlink" title="清理扩展资源"></a>清理扩展资源</h2><p>这里是一个从节点移除 dongle 资源发布的 PATCH 请求。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/json-patch+json</span><br><span class="line">Host: k8s-master:8080</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;op&quot;: &quot;remove&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>启动一个代理，以便你可以很容易地向 Kubernetes API 服务器发送请求：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure><p>在另一个命令窗口中，发送 HTTP PATCH 请求。用你的节点名称替换 <code>&lt;your-node-name&gt;</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --header &quot;Content-Type: application/json-patch+json&quot; \</span><br><span class="line">--request PATCH \</span><br><span class="line">--data &#x27;[&#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;&#125;]&#x27; \</span><br><span class="line">http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status</span><br></pre></td></tr></table></figure><p>验证 dongle 资源的发布已经被移除：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl describe node &lt;your-node-name&gt; | grep dongle</span><br></pre></td></tr></table></figure><p>(你应该看不到任何输出)</p><blockquote><p>扩展资源是 <code>kubernetes.io</code> 域名之外的标准资源名称。 它们使得集群管理员能够颁布非 Kubernetes 内置资源，而用户可以使用他们。</p><p>使用扩展资源需要两个步骤。首先，集群管理员必须颁布扩展资源。 其次，用户必须在 Pod 中请求扩展资源。</p></blockquote><h1 id="Device-Plugins"><a href="#Device-Plugins" class="headerlink" title="Device Plugins"></a>Device Plugins</h1><p>官方链接：<a href="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/">device-plugins</a></p><p><strong>特性状态：</strong> <code>Kubernetes v1.26 [stable]</code></p><p>Kubernetes 提供了一个 <a href="https://git.k8s.io/design-proposals-archive/resource-management/device-plugin.md">设备插件框架</a>， 你可以用它来将系统硬件资源发布到 <a href="https://kubernetes.io/docs/reference/generated/kubelet">Kubelet</a>。</p><p>供应商可以实现设备插件，由你手动部署或作为 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a> 来部署，而不必定制 Kubernetes 本身的代码。目标设备包括 GPU、高性能 NIC、FPGA、 InfiniBand 适配器以及其他类似的、可能需要特定于供应商的初始化和设置的计算资源。</p><h2 id="设备插件框架"><a href="#设备插件框架" class="headerlink" title="设备插件框架"></a>设备插件框架</h2><img src="/2022/11/29/16/device-plugin-overview.png" class="" title="Process"><p>设备插件的常规工作流程包括以下几个步骤：</p><ul><li>初始化。在这个阶段，设备插件将执行供应商特定的初始化和设置， 以确保设备处于就绪状态。</li><li>插件使用主机路径 <code>/var/lib/kubelet/device-plugins/</code> 下的 Unix 套接字启动一个 gRPC 服务，如：<code>/var/lib/kubelet/device-plugins/nvidia-gpu.sock</code>，该服务实现以下接口：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service DevicePlugin &#123;</span><br><span class="line">    // GetDevicePluginOptions 返回与设备管理器沟通的选项。</span><br><span class="line">    rpc GetDevicePluginOptions(Empty) returns (DevicePluginOptions) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // ListAndWatch 返回 Device 列表构成的数据流。</span><br><span class="line">    // 当 Device 状态发生变化或者 Device 消失时，ListAndWatch</span><br><span class="line">    // 会返回新的列表。</span><br><span class="line">    rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // Allocate 在容器创建期间调用，这样设备插件可以运行一些特定于设备的操作，</span><br><span class="line">    // 并告诉 kubelet 如何令 Device 可在容器中访问的所需执行的具体步骤</span><br><span class="line">    rpc Allocate(AllocateRequest) returns (AllocateResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // GetPreferredAllocation 从一组可用的设备中返回一些优选的设备用来分配，</span><br><span class="line">    // 所返回的优选分配结果不一定会是设备管理器的最终分配方案。</span><br><span class="line">    // 此接口的设计仅是为了让设备管理器能够在可能的情况下做出更有意义的决定。</span><br><span class="line">    rpc GetPreferredAllocation(PreferredAllocationRequest) returns (PreferredAllocationResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // PreStartContainer 在设备插件注册阶段根据需要被调用，调用发生在容器启动之前。</span><br><span class="line">    // 在将设备提供给容器使用之前，设备插件可以运行一些诸如重置设备之类的特定于</span><br><span class="line">    // 具体设备的操作，</span><br><span class="line">    rpc PreStartContainer(PreStartContainerRequest) returns (PreStartContainerResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>插件通过 Unix socket 在主机路径 <code>/var/lib/kubelet/device-plugins/kubelet.sock</code> 处向 kubelet 注册自身。</p></li><li><p>成功注册自身后，设备插件将以服务模式运行，在此期间，它将持续监控设备运行状况， 并在设备状态发生任何变化时向 kubelet 报告。它还负责响应 <code>Allocate</code> gRPC 请求。 在 <code>Allocate</code> 期间，设备插件可能还会做一些设备特定的准备；例如 GPU 清理或 QRNG 初始化。 如果操作成功，则设备插件将返回 <code>AllocateResponse</code>，其中包含用于访问被分配的设备容器运行时的配置。 kubelet 将此信息传递到容器运行时。</p></li></ul><h3 id="处理-kubelet-重启"><a href="#处理-kubelet-重启" class="headerlink" title="处理 kubelet 重启"></a>处理 kubelet 重启</h3><ul><li>设备插件应能监测到 kubelet 重启，并且向新的 kubelet 实例来重新注册自己。 新的 kubelet 实例启动时会删除 <code>/var/lib/kubelet/device-plugins</code> 下所有已经存在的 Unix 套接字。 </li><li>设备插件需要能够监控到它的 Unix 套接字被删除，并且当发生此类事件时重新注册自己。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Extended-Resource&quot;&gt;&lt;a href=&quot;#Extended-Resource&quot; class=&quot;headerlink&quot; title=&quot;Extended Resource&quot;&gt;&lt;/a&gt;Extended Resource&lt;/h1&gt;&lt;p&gt;官方链接：&lt;a hr</summary>
      
    
    
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/categories/device-plugins/"/>
    
    
    <category term="kubernetnes" scheme="http://lizhewei91.github.io/tags/kubernetnes/"/>
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/tags/device-plugins/"/>
    
  </entry>
  
  <entry>
    <title>性能剖析大杀器 pprof</title>
    <link href="http://lizhewei91.github.io/2022/11/28/56/"/>
    <id>http://lizhewei91.github.io/2022/11/28/56/</id>
    <published>2022-11-28T12:28:56.000Z</published>
    <updated>2023-06-01T07:36:49.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h1><p>在 Go 语言中，PProf 是用于可视化和分析性能分析数据的工具，pprof 以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）。</p><p>而刚刚提到的 profile.proto 是一个 Protobuf v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式。</p><h2 id="可以做什么"><a href="#可以做什么" class="headerlink" title="可以做什么"></a>可以做什么</h2><ul><li><strong>CPU Profiling</strong>：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。</li><li><strong>Memory Profiling</strong>：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。</li><li><strong>Block Profiling</strong>：阻塞分析，记录Goroutine阻塞等待同步（包括定时器通道）的位置，默认不开启，需要调用 <code>runtime.SetBlockProfileRate</code>进行设置。</li><li><strong>Mutex Profiling</strong>：互斥锁分析，报告互斥锁的竞争情况，默认不开启，需要调用 <code>runtime.SetMutexProfileFraction </code>进行设置。</li><li><strong>Goroutine Profiling</strong>：Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。</li></ul><p>其中像是 Goroutine Profiling 这项功能会在实际排查中会经常用到。因为很多问题出现时的表象就是 Goroutine 暴增，而这时候我们要做的事情之一就是查看应用程序中的 Goroutine 正在做什么事情，因为什么阻塞了，然后再进行下一步。</p><h2 id="采样方式"><a href="#采样方式" class="headerlink" title="采样方式"></a>采样方式</h2><ul><li><strong>runtime/pprof</strong>：采集程序（非 Server）的指定区块的运行数据进行分析。</li><li><strong>net/http/pprof</strong>：基于HTTP Server运行，并且可以采集运行时数据进行分析。</li><li><strong>go test</strong>：通过运行测试用例，并指定所需标识来进行采集。</li></ul><h2 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h2><ul><li>Report generation：报告生成。</li><li>Interactive terminal use：交互式终端使用。</li><li>Web interface：Web 界面。</li></ul><h1 id="服务型应用"><a href="#服务型应用" class="headerlink" title="服务型应用"></a>服务型应用</h1><p>如果你的应用程序是一直运行的，比如 web 应用，那么可以使用<code>net/http/pprof</code>库，它能够在提供 HTTP 服务进行分析。</p><p>如果使用了默认的 <code>http.DefaultServeMux</code>（通常是代码直接使用 <code>http.ListenAndServe(“0.0.0.0:8080”, nil)</code>），只需要在你的web server端代码中按如下方式导入<code>net/http/pprof</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span> </span><br></pre></td></tr></table></figure><h2 id="为什么要初始化net-http-pprof"><a href="#为什么要初始化net-http-pprof" class="headerlink" title="为什么要初始化net/http/pprof"></a>为什么要初始化net/http/pprof</h2><p>在我们的例子中，你会发现我们在引用上对 <code>net/http/pprof</code>包进行了默认的初始化（也就是 _），如果你曾经漏了，或者没加，你会发现压根调用不了 pprof 的相关接口，这是为什么呢，我们一起看看下面该包的初始化方法，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/&quot;</span>, Index)</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/cmdline&quot;</span>, Cmdline)</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/profile&quot;</span>, Profile)</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/symbol&quot;</span>, Symbol)</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/trace&quot;</span>, Trace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 <code>net/http/pprof</code>会在初始化函数中对标准库中<code>net/http</code>所默认提供的 <code>DefaultServeMux</code> 进行路由注册，源码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line"> DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们在例子中使用的 HTTP Server，也是使用的标准库中默认提供的，因此便完美的结合在了一起，这也恰好也是最小示例的模式。</p><p>这时候你可能会注意到另外一个问题，那就是我们的实际项目中，都是有相对独立的 ServeMux 的，这时候我们只要仿照着将 pprof 对应的路由注册进去就好了，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/&quot;</span>, pprof.Index)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/cmdline&quot;</span>, pprof.Cmdline)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/profile&quot;</span>, pprof.Profile)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/symbol&quot;</span>, pprof.Symbol)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/trace&quot;</span>, pprof.Trace)</span><br></pre></td></tr></table></figure><p>如果你使用的是gin框架，那么推荐使用 <a href="https://github.com/gin-contrib/pprof">github.com/gin-contrib/pprof</a>，在代码中通过以下命令注册 pprof 相关路由。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.Register(router)</span><br></pre></td></tr></table></figure><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> datas []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;len:%d\n&quot;</span>, Add(str))</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">_ = http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">datas = <span class="built_in">append</span>(datas, str)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(datas)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们运行这个程序，访问 <code>http://127.0.0.1:8080/debug/pprof/</code> 地址，检查是否正常响应。</p><h3 id="通过浏览器访问"><a href="#通过浏览器访问" class="headerlink" title="通过浏览器访问"></a>通过浏览器访问</h3><p>第一种方式，我们可以直接通过浏览器，进行查看，那么在第一步我们可以先查看总览页面，也就是访问 <code>http://127.0.0.1:8080/debug/pprof/</code>，如下：    </p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/debug/pprof/</span><br><span class="line"></span><br><span class="line">Types of profiles available:</span><br><span class="line">CountProfile</span><br><span class="line"><span class="number">3</span>allocs</span><br><span class="line"><span class="number">0</span>block</span><br><span class="line"><span class="number">0</span>cmdline</span><br><span class="line"><span class="number">5</span>goroutine</span><br><span class="line"><span class="number">3</span>heap</span><br><span class="line"><span class="number">0</span>mutex</span><br><span class="line"><span class="number">0</span>profile</span><br><span class="line"><span class="number">8</span>threadcreate</span><br><span class="line"><span class="number">0</span>trace</span><br><span class="line">full goroutine stack dump</span><br></pre></td></tr></table></figure><ul><li><strong>allocs</strong>：查看过去所有内存分配的样本，访问路径为<code>$HOST/debug/pprof/allocs</code>。</li><li><strong>block</strong>：查看导致阻塞同步的堆栈跟踪，访问路径为<code>$HOST/debug/pprof/block</code>。</li><li><strong>cmdline</strong>：当前程序的命令行的完整调用路径，访问路径为<code>$HOST/debug/pprof/cmdline</code>。</li><li><strong>goroutine</strong>：查看当前所有运行的 goroutines 堆栈跟踪，访问路径为<code>$HOST/debug/pprof/goroutine</code>。</li><li><strong>heap</strong>：查看活动对象的内存分配情况， 访问路径为<code>$HOST/debug/pprof/heap</code>。</li><li><strong>mutex</strong>：查看导致互斥锁的竞争持有者的堆栈跟踪，访问路径为<code>$HOST/debug/pprof/mutex</code>。</li><li><strong>profile</strong>：默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件，访问路径为<code>$HOST/debug/pprof/profile</code>。</li><li><strong>threadcreate</strong>：查看创建新OS线程的堆栈跟踪，访问路径为<code>$HOST/debug/pprof/threadcreate</code>。</li></ul><p>如果在相应的路径上加“<code>?debug=1</code>”，则可以直接在浏览器中访问，如图所示：</p><img src="/2022/11/28/56/1639809085480-2c7d9448-375f-4b98-913e-81020195a0c6-20221128222049403.png" class="" title="image.png"><blockquote><p>若不新增debug参数，则会直接下载对应的profile文件。</p><p><strong>注意：</strong>debug的访问方式具有时效性，在实际场景中，我们通常将profile文件保存下来，便于二次分析。</p></blockquote><h3 id="通过交互式终端使用"><a href="#通过交互式终端使用" class="headerlink" title="通过交互式终端使用"></a>通过交互式终端使用</h3><h4 id="CPU-Profiling"><a href="#CPU-Profiling" class="headerlink" title="CPU Profiling"></a>CPU Profiling</h4><p>第二种方式，我们可以直接通过命令行，来完成对正在运行的应用程序 pprof 的抓取和分析。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/profile?seconds=60</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:6060/debug/pprof/profile?seconds=60</span></span><br><span class="line">Saved profile in /Users/eddycjy/pprof/pprof.samples.cpu<span class="number">.002</span>.pb.gz</span><br><span class="line">Type: cpu</span><br><span class="line">Duration: <span class="number">1</span>mins, Total samples = <span class="number">37.25</span>s (<span class="number">61.97</span>%)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure><p>执行该命令后，需等待 60 秒（可调整 seconds 的值），pprof 会进行 CPU Profiling，结束后将默认进入 pprof 的命令行交互式模式，可以对分析的结果进行查看或导出。另外如果你所启动的 HTTP Server 是 TLS 的方式，那么在调用<code>go tool pprof</code> 时，需要将调用路径改为：<code>go tool pprof https+insecure://localhost:8080/debug/pprof/profile\?seconds\=60</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) top10</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">1.38</span>s, <span class="number">100</span>% of <span class="number">1.38</span>s total</span><br><span class="line">Showing top <span class="number">10</span> nodes out of <span class="number">50</span></span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     <span class="number">0.60</span>s <span class="number">43.48</span>% <span class="number">43.48</span>%      <span class="number">0.80</span>s <span class="number">57.97</span>%  runtime.kevent</span><br><span class="line">     <span class="number">0.31</span>s <span class="number">22.46</span>% <span class="number">65.94</span>%      <span class="number">0.31</span>s <span class="number">22.46</span>%  runtime.libcCall</span><br><span class="line">     <span class="number">0.21</span>s <span class="number">15.22</span>% <span class="number">81.16</span>%      <span class="number">0.22</span>s <span class="number">15.94</span>%  syscall.syscall</span><br><span class="line">     <span class="number">0.15</span>s <span class="number">10.87</span>% <span class="number">92.03</span>%      <span class="number">0.26</span>s <span class="number">18.84</span>%  runtime.pthread_cond_wait</span><br><span class="line">     <span class="number">0.04</span>s  <span class="number">2.90</span>% <span class="number">94.93</span>%      <span class="number">0.04</span>s  <span class="number">2.90</span>%  runtime.pthread_cond_signal</span><br><span class="line">     <span class="number">0.02</span>s  <span class="number">1.45</span>% <span class="number">96.38</span>%      <span class="number">0.02</span>s  <span class="number">1.45</span>%  runtime.walltime</span><br><span class="line">     <span class="number">0.02</span>s  <span class="number">1.45</span>% <span class="number">97.83</span>%      <span class="number">0.02</span>s  <span class="number">1.45</span>%  runtime.write1</span><br><span class="line">     <span class="number">0.01</span>s  <span class="number">0.72</span>% <span class="number">98.55</span>%      <span class="number">0.01</span>s  <span class="number">0.72</span>%  log.itoa</span><br><span class="line">     <span class="number">0.01</span>s  <span class="number">0.72</span>% <span class="number">99.28</span>%      <span class="number">0.01</span>s  <span class="number">0.72</span>%  runtime.(*mcache).prepareForSweep</span><br><span class="line">     <span class="number">0.01</span>s  <span class="number">0.72</span>%   <span class="number">100</span>%      <span class="number">0.01</span>s  <span class="number">0.72</span>%  runtime.memmove</span><br></pre></td></tr></table></figure><ul><li>flat：函数自身的运行耗时。</li><li>flat%：函数自身在 CPU 运行耗时总比例。</li><li>sum%：函数自身累积使用 CPU 总比例。</li><li>cum：函数自身及其调用函数的运行总耗时。</li><li>cum%：函数自身及其调用函数的运行耗时总比例。</li><li>Name：函数名。</li></ul><p>在大多数的情况下，我们可以通过这五列得出一个应用程序的运行情况，知道当前是什么函数，正在做什么事情，占用了多少资源，谁又是占用资源的大头，以此来得到一个初步的分析方向。</p><blockquote><p>另外在交互命令行中，pprof 还支持了大量的其它命令，具体可执行 pprof help 查看帮助说明。</p></blockquote><h4 id="Heap-Profiling"><a href="#Heap-Profiling" class="headerlink" title="Heap Profiling"></a>Heap Profiling</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.001</span>.pb.gz</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">4</span>:<span class="number">56</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) </span><br></pre></td></tr></table></figure><p>执行该命令后，能够很快的拉取到其结果，因为它不需要像 CPU Profiling 做采样等待，这里需要注意的一点是 <code>Type</code> 这一个选项，你可以看到它默认显示的是 <code>inuse_space</code>，实际上可以针对多种内存概况进行分析，常用的类别如下：</p><p>一共有四种类型：</p><ol><li><strong>inuse_space</strong>：分析应用程序的常驻内存占用情况。</li><li><strong>alloc_objects</strong>：分析应用程序的内存临时分配情况。</li><li><strong>inuse_objects</strong>：查看每个函数所分别的对象数量。</li><li><strong>alloc_space</strong>：查看分配的内存空间大小。</li></ol><ul><li>inuse_space：分析应用程序的常驻内存占用情况。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$  <span class="keyword">go</span> tool pprof -inuse_space http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.002</span>.pb.gz</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">4</span>:<span class="number">59</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">4130.49</span>kB, <span class="number">100</span>% of <span class="number">4130.49</span>kB total</span><br><span class="line">Showing top <span class="number">10</span> nodes out of <span class="number">20</span></span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line"> <span class="number">1567.04</span>kB <span class="number">37.94</span>% <span class="number">37.94</span>%  <span class="number">1567.04</span>kB <span class="number">37.94</span>%  main.Add (inline)</span><br><span class="line"> <span class="number">1537.69</span>kB <span class="number">37.23</span>% <span class="number">75.17</span>%  <span class="number">1537.69</span>kB <span class="number">37.23</span>%  runtime.allocm</span><br><span class="line">  <span class="number">513.56</span>kB <span class="number">12.43</span>% <span class="number">87.60</span>%   <span class="number">513.56</span>kB <span class="number">12.43</span>%  regexp/syntax.init</span><br><span class="line">  <span class="number">512.20</span>kB <span class="number">12.40</span>%   <span class="number">100</span>%   <span class="number">512.20</span>kB <span class="number">12.40</span>%  runtime.malg</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%  <span class="number">1567.04</span>kB <span class="number">37.94</span>%  main.main.func1</span><br></pre></td></tr></table></figure><ul><li>alloc_objects：分析应用程序的内存临时分配情况。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof -alloc_objects http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.003</span>.pb.gz</span><br><span class="line">Type: alloc_objects</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">5</span>:<span class="number">01</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">311313</span>, <span class="number">99.07</span>% of <span class="number">314251</span> total</span><br><span class="line">Dropped <span class="number">39</span> nodes (cum &lt;= <span class="number">1571</span>)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    <span class="number">163842</span> <span class="number">52.14</span>% <span class="number">52.14</span>%     <span class="number">311313</span> <span class="number">99.07</span>%  main.main.func1</span><br><span class="line">    <span class="number">131074</span> <span class="number">41.71</span>% <span class="number">93.85</span>%     <span class="number">131074</span> <span class="number">41.71</span>%  fmt.Sprintf</span><br><span class="line">     <span class="number">16397</span>  <span class="number">5.22</span>% <span class="number">99.07</span>%      <span class="number">16397</span>  <span class="number">5.22</span>%  main.Add (inline)</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>% <span class="number">99.07</span>%     <span class="number">131074</span> <span class="number">41.71</span>%  log.Printf</span><br></pre></td></tr></table></figure><p>另外还有 inuse_objects 和 alloc_space 类别，分别对应查看每个函数所分别的对象数量和查看分配的内存空间大小，具体可根据情况选用。</p><h4 id="Goroutine-Profiling"><a href="#Goroutine-Profiling" class="headerlink" title="Goroutine Profiling"></a>Goroutine Profiling</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/goroutine</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8080/debug/pprof/goroutine</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.goroutine<span class="number">.001</span>.pb.gz</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">5</span>:<span class="number">04</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) </span><br></pre></td></tr></table></figure><p>在查看 goroutine 时，我们可以使用 traces 命令，这个命令会打印出对应的所有调用栈，以及指标信息，可以让我们很便捷的查看到整个调用链路有什么，分别在哪里使用了多少个 goroutine，并且能够通过分析查看到谁才是真正的调用方，输出结果如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) traces</span><br><span class="line">Type: goroutine</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">         <span class="number">2</span>   runtime.gopark</span><br><span class="line">             runtime.netpollblock</span><br><span class="line">             internal/poll.runtime_pollWait</span><br><span class="line">             ...</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">         <span class="number">1</span>   runtime.gopark</span><br><span class="line">             runtime.netpollblock</span><br><span class="line">             ...</span><br><span class="line">             net/http.ListenAndServe</span><br><span class="line">             main.main</span><br><span class="line">             runtime.main</span><br></pre></td></tr></table></figure><p>在调用栈上来讲，其展示顺序是<strong>自下而上</strong>的，也就是 <code>runtime.main</code> 方法调用了 <code>main.main</code> 方法，<code>main.main</code> 方法又调用了 <code>net/http.ListenAndServe</code> 方法，这里对应的也就是我们所使用的示例代码了，排查起来会非常方便。</p><p>每个调用堆栈信息用 <code>-----------</code> 分割，函数方法前的就是指标数据，像 Goroutine Profiling 展示是就是该方法占用的 goroutine 的数量。而 Heap Profiling 展示的就是占用的内存大小，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">...</span><br><span class="line">Type: inuse_space</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) traces</span><br><span class="line">Type: inuse_space</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  <span class="number">13.55</span>MB</span><br><span class="line">   <span class="number">13.55</span>MB   main.Add</span><br><span class="line">             main.main.func1</span><br><span class="line">-----------+-------------------------------------------------------</span><br></pre></td></tr></table></figure><h4 id="Mutex-Profiling"><a href="#Mutex-Profiling" class="headerlink" title="Mutex Profiling"></a>Mutex Profiling</h4><p>怎么样的情况下会造成阻塞呢，一般有如下方式：调用 chan（通道）、调用 <code>sync.Mutex</code> （同步锁）、调用 <code>time.Sleep()</code> 等等。那么为了验证互斥锁的竞争持有者的堆栈跟踪，我们可以根据以上的 <code>sync.Mutex</code> 方式，来调整先前的示例代码，代码如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"> runtime.SetMutexProfileFraction(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> m sync.Mutex</span><br><span class="line"> <span class="keyword">var</span> datas = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">999</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   m.Lock()</span><br><span class="line">   <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">   datas[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">  &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> _ = http.ListenAndServe(<span class="string">&quot;:6061&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别注意的是 <code>runtime.SetMutexProfileFraction</code> 语句，如果未来希望进行互斥锁的采集，那么需要通过调用该方法来设置采集频率，若不设置或没有设置大于 0 的数值，默认是不进行采集的。</p><p>接下来我们进行调用 <code>go tool pprof</code> 进行分析，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8081/debug/pprof/mutex</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8081/debug/pprof/mutex</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.contentions.delay<span class="number">.002</span>.pb.gz</span><br><span class="line">Type: delay</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">5</span>:<span class="number">18</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) </span><br></pre></td></tr></table></figure><p>我们查看调用 top 命令，查看互斥量的排名：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">1.77</span>ms, <span class="number">100</span>% of <span class="number">1.77</span>ms total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    <span class="number">1.77</span>ms   <span class="number">100</span>%   <span class="number">100</span>%     <span class="number">1.77</span>ms   <span class="number">100</span>%  sync.(*Mutex).Unlock</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%     <span class="number">1.77</span>ms   <span class="number">100</span>%  main.main.func1</span><br></pre></td></tr></table></figure><p>接下来我们可以调用 list 命令，看到指定函数的代码情况（包含特定的指标信息，例如：耗时），若函数名不明确，默认会对函数名进行模糊匹配，如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) list main</span><br><span class="line">Total: <span class="number">1.77</span>ms</span><br><span class="line">ROUTINE ======================== main.main.func1 in /Volumes/D/<span class="keyword">go</span>/src/github.com/lizw91/pprof/main.<span class="keyword">go</span></span><br><span class="line">         <span class="number">0</span>     <span class="number">1.77</span>ms (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">17</span>:   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">         .          .     <span class="number">18</span>:           <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">         .          .     <span class="number">19</span>:                   m.Lock()</span><br><span class="line">         .          .     <span class="number">20</span>:                   <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">         .          .     <span class="number">21</span>:                   datas[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">         .     <span class="number">1.77</span>ms     <span class="number">22</span>:           &#125;(i)</span><br><span class="line">         .          .     <span class="number">23</span>:   &#125;</span><br><span class="line">         .          .     <span class="number">24</span>:</span><br><span class="line">         .          .     <span class="number">25</span>:   _ = http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">         .          .     <span class="number">26</span>:&#125;</span><br></pre></td></tr></table></figure><p>我们可以在输出的分析中比较准确的看到引起互斥锁的函数在哪里，锁开销在哪里，在本例中是第 22 行。</p><h4 id="Block-Profiling"><a href="#Block-Profiling" class="headerlink" title="Block Profiling"></a>Block Profiling</h4><p>与 Mutex 的 <code>runtime.SetMutexProfileFraction</code> 相似，Block 也需要调用 <code>runtime.SetBlockProfileRate()</code> 进行采集量的设置，否则默认关闭，若设置的值小于等于 0 也会认为是关闭。</p><p>与上小节 Mutex 相比，主体代码不变，仅是新增 <code>runtime.SetBlockProfileRate()</code>的调用，如下：</p><p><strong>示例代码</strong> </p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.SetBlockProfileRate(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m sync.Mutex</span><br><span class="line"><span class="keyword">var</span> datas = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">m.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.Unlock()</span><br><span class="line">datas[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_ = http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们查看调用 top 命令，查看阻塞情况的排名：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8081/debug/pprof/block</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8081/debug/pprof/block</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.contentions.delay<span class="number">.003</span>.pb.gz</span><br><span class="line">Type: delay</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">5</span>:<span class="number">21</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">48.97</span>ms, <span class="number">100</span>% of <span class="number">48.97</span>ms total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">   <span class="number">48.97</span>ms   <span class="number">100</span>%   <span class="number">100</span>%    <span class="number">48.97</span>ms   <span class="number">100</span>%  sync.(*Mutex).Lock (inline)</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%    <span class="number">48.97</span>ms   <span class="number">100</span>%  main.main.func1</span><br></pre></td></tr></table></figure><p>同样的，我们也可以调用 list 命令查看具体的阻塞情况，执行方式和排查模式与先前概述的一致。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) list main</span><br><span class="line">Total: <span class="number">48.97</span>ms</span><br><span class="line">ROUTINE ======================== main.main.func1 in /Volumes/D/<span class="keyword">go</span>/src/github.com/lizw91/pprof/main.<span class="keyword">go</span></span><br><span class="line">         <span class="number">0</span>    <span class="number">48.97</span>ms (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">14</span>:<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">         .          .     <span class="number">15</span>:   <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">         .          .     <span class="number">16</span>:   <span class="keyword">var</span> datas = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">         .          .     <span class="number">17</span>:   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">         .          .     <span class="number">18</span>:           <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">         .    <span class="number">48.97</span>ms     <span class="number">19</span>:                   m.Lock()</span><br><span class="line">         .          .     <span class="number">20</span>:                   <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">         .          .     <span class="number">21</span>:                   datas[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">         .          .     <span class="number">22</span>:           &#125;(i)</span><br><span class="line">         .          .     <span class="number">23</span>:   &#125;</span><br><span class="line">         .          .     <span class="number">24</span>:</span><br></pre></td></tr></table></figure><h3 id="查看可视化界面"><a href="#查看可视化界面" class="headerlink" title="查看可视化界面"></a>查看可视化界面</h3><p>接下来我们继续使用前面的示例程序，将其重新运行起来，然后在其它窗口执行下述命令：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 cpu 指标</span></span><br><span class="line">$ wget -O cpu.profile http:<span class="comment">//127.0.0.1:8080/debug/pprof/profile?seconds=30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 heap 指标 </span></span><br><span class="line">$ wget -O mem.profile http:<span class="comment">//127.0.0.1:8080/debug/pprof/profile?seconds=30</span></span><br></pre></td></tr></table></figure><p>默认需要等待 30 秒，执行完毕后可在当前目录下发现采集的文件 cpu.profile，针对可视化界面我们有两种方式可进行下一步分析：</p><ol><li>方法一<strong>（推荐）</strong>：该命令将在所指定的端口号运行一个 pprof 的分析用的站点</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof -http=:<span class="number">8081</span> cpu.profile  </span><br></pre></td></tr></table></figure><ol><li>方法二：通过 web 命令将以 svg 的文件格式写入图形，然后在 Web 浏览器中将其打开。</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof cpu.profile</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Feb <span class="number">1</span>, <span class="number">2020</span> at <span class="number">12</span>:<span class="number">09</span>pm (CST)</span><br><span class="line">Duration: <span class="number">30</span>s, Total samples = <span class="number">60</span>ms (  <span class="number">0.2</span>%)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) web</span><br></pre></td></tr></table></figure><blockquote><p>如果出现错误提示 Could not execute dot; may need to install graphviz.，那么意味着你需要安装 graphviz组件。</p><p>另外方法一所运行的站点，实际上包含了方法二的内容（svg图片），并且更灵活，因此非特殊情况，我们会直接使用方法一的方式运行站点来做观察和分析。</p></blockquote><p>通过 pprof 所提供的可视化界面，我们能够更方便、更直观的看到 Go 应用程序的调用链、使用情况等。</p><p>另外在 View 菜单栏中，PProf 还支持多种分析方式的切换，如下：</p><img src="/2022/11/28/56/1639561832030-18ced959-237a-4a72-9121-a05850d0e4b9.png" class="" title="img"><p>view 菜单栏</p><p>接下来我们将基于 CPU Profiling 所抓取的 Profile 进行一一介绍，而其它 Profile 类型的分析模式也是互通的，只要我们了解了一种，其余的也就会了。</p><h4 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h4><img src="/2022/11/28/56/1639561878713-40879f4c-8c9b-429d-bff5-bcfdffc32fc1.png" class="" title="img"><ul><li>flat：函数自身的运行耗时。</li><li>flat%：函数自身在 CPU 运行耗时总比例。</li><li>sum%：函数自身累积使用 CPU 总比例。</li><li>cum：函数自身及其调用函数的运行总耗时。</li><li>cum%：函数自身及其调用函数的运行耗时总比例。</li><li>Name：函数名。</li></ul><h4 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h4><img src="/2022/11/28/56/1639561986430-2a11499e-5106-4273-8ce7-85caacd60ac0.png" class="" title="img"><p>该视图展示的为整体的函数调用流程，框越大、线越粗、框颜色越鲜艳（红色）就代表它占用的时间越久，开销越大。相反若框颜色越淡，越小则代表在整体的函数调用流程中，它的开销是相对较小的。因此我们可以用此视图去分析谁才是开销大头，它又是因为什么调用流程而被调用的。</p><h4 id="Peek"><a href="#Peek" class="headerlink" title="Peek"></a>Peek</h4><img src="/2022/11/28/56/1639562053535-d85c624d-78ca-4460-93a2-d46fdb060ca1.png" class="" title="img"><p>peek 栏目，此视图相较于 Top 视图，增加了所属的上下文信息的展示，也就是函数的输出调用者/被调用者。</p><h4 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h4><img src="/2022/11/28/56/1639562087329-46ed34bf-0b80-4510-bc2c-9dbf5b34a0da.png" class="" title="img"><p>source 栏目，该视图主要是增加了面向源代码的追踪和分析，可以看到其开销主要消耗在哪里。</p><h4 id="flame-graph"><a href="#flame-graph" class="headerlink" title="flame graph"></a>flame graph</h4><img src="/2022/11/28/56/1639568828478-ad6f5933-8572-4dbd-b73d-f637ba70a610-20221128223022437.png" class="" title="image.png"><p>Flame Graph（火焰图）它是可动态的，调用顺序由上到下（A -&gt; B -&gt; C -&gt; D），每一块代表一个函数、颜色越鲜艳（红）、区块越大代表占用 CPU 的时间更长。同时它也支持点击块深入进行分析。</p><p>我们选择页面上的 main.main.func1 区块，将会进入到其属下的下一层级，如下：</p><img src="/2022/11/28/56/1639568868468-031d2b33-b044-4827-a283-5bd689ab07d3-20221128223104007.png" class="" title="image.png"><p>进一步查看 flame graph，这样子我们就可以根据不同函数的多维度层级进行分析，能够更好的观察其流转并发现问题。</p><h1 id="工具型应用"><a href="#工具型应用" class="headerlink" title="工具型应用"></a>工具型应用</h1><p>如果你的应用程序是运行一段时间就结束退出类型。那么最好的办法是在应用退出的时候把 profiling 的报告保存到文件中，进行分析。对于这种情况，可以使用<code>runtime/pprof</code>库。 首先在代码中导入<code>runtime/pprof</code>工具：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;runtime/pprof&quot;</span></span><br></pre></td></tr></table></figure><h2 id="CPU性能分析"><a href="#CPU性能分析" class="headerlink" title="CPU性能分析"></a>CPU性能分析</h2><p>开启CPU性能分析：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.StartCPUProfile(w io.Writer) </span><br></pre></td></tr></table></figure><p>停止CPU性能分析：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.StopCPUProfile() </span><br></pre></td></tr></table></figure><p>应用执行结束后，就会生成一个文件，保存了我们的 CPU profiling 数据。得到采样数据之后，使用 <code>go tool pprof</code>工具进行 CPU 性能分析。</p><h2 id="内存性能优化"><a href="#内存性能优化" class="headerlink" title="内存性能优化"></a>内存性能优化</h2><p>记录程序的堆栈信息</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.WriteHeapProfile(w io.Writer)</span><br></pre></td></tr></table></figure><p><code>go tool pprof</code>默认是使用<code>-inuse_space</code> 进行统计，还可以使用 <code>-inuse-objects</code> 查看分配对象的数量。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime_pprof/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;runtime/pprof&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段有问题的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logicCode</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-c:</span><br><span class="line">fmt.Printf(<span class="string">&quot;recv from chan, value:%v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> isCPUPprof <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> isMemPprof <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">flag.BoolVar(&amp;isCPUPprof, <span class="string">&quot;cpu&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;turn cpu pprof on&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;isMemPprof, <span class="string">&quot;mem&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;turn mem pprof on&quot;</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isCPUPprof &#123;</span><br><span class="line">file, err := os.Create(<span class="string">&quot;./cpu.pprof&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;create cpu pprof failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">pprof.StartCPUProfile(file)</span><br><span class="line"><span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> logicCode()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">20</span> * time.Second)</span><br><span class="line"><span class="keyword">if</span> isMemPprof &#123;</span><br><span class="line">file, err := os.Create(<span class="string">&quot;./mem.pprof&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;create mem pprof failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">pprof.WriteHeapProfile(file)</span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过flag我们可以在命令行控制是否开启 CPU和  Mem 的性能分析。 将上面的代码保存并编译成runtime_pprof 可执行文件，执行时加上 -cpu 命令行参数如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span> -cpu</span><br></pre></td></tr></table></figure><p>等待30秒后会在当前目录下生成一个 cpu.pprof 文件。然后，执行<code>go tool pprof</code>命令就可以查看</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof cpu.pprof</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">8</span>:<span class="number">25</span>pm (CST)</span><br><span class="line">Duration: <span class="number">20.19</span>s, Total samples = <span class="number">119.64</span>s (<span class="number">592.65</span>%)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">119.62</span>s, <span class="number">100</span>% of <span class="number">119.64</span>s total</span><br><span class="line">Dropped <span class="number">2</span> nodes (cum &lt;= <span class="number">0.60</span>s)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    <span class="number">52.65</span>s <span class="number">44.01</span>% <span class="number">44.01</span>%     <span class="number">52.65</span>s <span class="number">44.01</span>%  runtime.chanrecv</span><br><span class="line">    <span class="number">51.04</span>s <span class="number">42.66</span>% <span class="number">86.67</span>%    <span class="number">103.69</span>s <span class="number">86.67</span>%  runtime.selectnbrecv</span><br><span class="line">    <span class="number">15.93</span>s <span class="number">13.31</span>%   <span class="number">100</span>%    <span class="number">119.63</span>s   <span class="number">100</span>%  main.logicCode</span><br></pre></td></tr></table></figure><h1 id="压测工具wrk"><a href="#压测工具wrk" class="headerlink" title="压测工具wrk"></a>压测工具wrk</h1><p>推荐使用：</p><p><a href="https://github.com/wg/wrk">https://github.com/wg/wrk</a> </p><p><a href="https://github.com/adjust/go-wrk">https://github.com/adjust/go-wrk</a></p><p>使用wrk进行压测:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>-wrk -n <span class="number">50000</span> http:<span class="comment">//127.0.0.1:8080/book/list</span></span><br></pre></td></tr></table></figure><p>在上面压测进行的同时，打开另一个终端执行:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/profile?seconds=60</span></span><br></pre></td></tr></table></figure><h1 id="pprof与性能测试结合"><a href="#pprof与性能测试结合" class="headerlink" title="pprof与性能测试结合"></a>pprof与性能测试结合</h1><p><code>go test</code> 命令有两个参数和 pprof 相关，它们分别指定生成的 CPU 和 Memory profiling 保存的文件：</p><ul><li>-cpuprofile：cpu profiling 数据要保存的文件地址</li><li>-memprofile：memory profiling 数据要报文的文件地址</li></ul><p>我们还可以选择将pprof与性能测试相结合，比如：</p><p>比如下面执行测试的同时，也会执行 CPU profiling，并把结果保存在 cpu.prof 文件中：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test -bench . -cpuprofile=cpu.profile</span><br></pre></td></tr></table></figure><p>比如下面执行测试的同时，也会执行 Mem profiling，并把结果保存在 cpu.prof 文件中：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test -bench . -memprofile=./mem.profile</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 获取的 Profiling 数据是动态的，要想获得有效的数据，请保证应用处于较大的负载（比如正在生成中运行的服务，或者通过其他工具模拟访问压力）。否则如果应用处于空闲状态，得到的结果可能没有任何意义。所以，<strong>Profiling 一般和性能测试一起使用</strong></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pprof&quot;&gt;&lt;a href=&quot;#pprof&quot; class=&quot;headerlink&quot; title=&quot;pprof&quot;&gt;&lt;/a&gt;pprof&lt;/h1&gt;&lt;p&gt;在 Go 语言中，PProf 是用于可视化和分析性能分析数据的工具，pprof 以 profile.proto 读取</summary>
      
    
    
    
    <category term="pprof" scheme="http://lizhewei91.github.io/categories/pprof/"/>
    
    
    <category term="pprof" scheme="http://lizhewei91.github.io/tags/pprof/"/>
    
    <category term="性能分析" scheme="http://lizhewei91.github.io/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
    <category term="golang" scheme="http://lizhewei91.github.io/tags/golang/"/>
    
  </entry>
  
</feed>
