<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lizhewei&#39;Blog</title>
  <icon>https://www.gravatar.com/avatar/239ff887da8d6962c7547552e4f6946b</icon>
  
  <link href="http://lizhewei91.github.io/atom.xml" rel="self"/>
  
  <link href="http://lizhewei91.github.io/"/>
  <updated>2023-12-13T09:43:06.791Z</updated>
  <id>http://lizhewei91.github.io/</id>
  
  <author>
    <name>lizhewei</name>
    <email>tyutlizhewei@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NVIDIA/gpu-operator分析: 原理解析</title>
    <link href="http://lizhewei91.github.io/2023/12/13/04/"/>
    <id>http://lizhewei91.github.io/2023/12/13/04/</id>
    <published>2023-12-13T08:31:04.000Z</published>
    <updated>2023-12-13T09:43:06.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们知道，如果在Kubernetes中支持GPU设备调度，需要做如下的工作：</p><ul><li>节点上安装nvidia驱动</li><li>节点上安装nvidia-docker</li><li>集群部署gpu device plugin，用于为调度到该节点的pod分配GPU设备。</li></ul><p>除此之外，如果你需要监控集群GPU资源使用情况，你可能还需要安装 <a href="https://github.com/NVIDIA/dcgm-exporter">DCGM exporter</a> 结合 Prometheus 输出 GPU 资源监控信息。</p><p>要安装和管理这么多的组件，对于运维人员来说压力不小。基于此，NVIDIA开源了一款叫 <a href="https://github.com/NVIDIA/gpu-operator">NVIDIA GPU Operator</a> 的工具，该工具基于 <a href="https://github.com/operator-framework">Operator Framework</a> 实现，用于自动化管理上面我们提到的这些组件。</p><p>在之前的文章中，作者分别介绍了NVIDIA GPU Operator所涉及的每一个组件并且演示了如何手动部署这些组件，在本篇文章中将介绍详细介绍NVIDIA GPU Operator的工作原理。</p><h1 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h1><p>从前面的文章中，我们知道NVIDIA GPU Operator总共包含如下的几个组件：</p><img src="/2023/12/13/04/gpu-operator%E6%80%BB%E7%BB%93-2460579.png" class="" title="gpu-operator总结"><ul><li><p><a href="https://github.com/kubernetes-sigs/node-feature-discovery"><strong>NFD(Node Feature Discovery)</strong></a>：用于给节点打上某些标签，这些标签包括cpu id、内核版本、操作系统版本等标签。</p></li><li><p><a href="https://gitlab.com/nvidia/container-images/driver"><strong>NVIDIA Driver</strong></a>：基于容器的方式在节点上安装NVIDIA GPU驱动，在k8s集群中以DaemonSet方式部署，只有节点拥有标签“nvidia.com/gpu.present=true”时，DaemonSet控制的Pod才会在该节点上运行。</p></li><li><p><a href="https://github.com/NVIDIA/nvidia-container-toolkit"><strong>NVIDIA Container Toolkit</strong></a>：能够实现在容器中使用GPU设备，在k8s集群中以DaemonSet方式部署，只有节点拥有标签“nvidia.com/gpu.present=true”时，DaemonSet控制的Pod才会在该节点上运行。</p></li><li><p><a href="https://github.com/NVIDIA/k8s-device-plugin"><strong>NVIDIA Device Plugin</strong></a>：NVIDIA Device Plugin用于实现将GPU设备以Kubernetes扩展资源的方式供用户使用，在k8s集群中以DaemonSet方式部署，只有节点拥有标签“nvidia.com/gpu.present=true”时，DaemonSet控制的Pod才会在该节点上运行。</p></li><li><p><a href="https://github.com/NVIDIA/dcgm-exporter"><strong>DCGM Exporter</strong></a>：周期性的收集节点GPU设备的状态（当前温度、总的显存、已使用显存、使用率等），然后结合Prometheus和Grafana将这些指标用丰富的仪表盘展示给用户。在k8s集群中以DaemonSet方式部署，只有节点拥有标签“nvidia.com/gpu.present=true”时，DaemonSet控制的Pod才会在该节点上运行。</p></li><li><p><a href="https://github.com/NVIDIA/gpu-feature-discovery"><strong>GFD(GPU Feature Discovery)</strong></a>：用于收集节点的GPU设备属性（GPU驱动版本、GPU型号等），并将这些属性以节点标签的方式透出。在k8s集群中以DaemonSet方式部署，只有节点拥有标签“nvidia.com/gpu.present=true”时，DaemonSet控制的Pod才会在该节点上运行。</p></li></ul><ul><li><strong>NVIDIA MIG Manager</strong>：</li></ul><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><h1 id="源码介绍"><a href="#源码介绍" class="headerlink" title="源码介绍"></a>源码介绍</h1><h2 id="前提说明"><a href="#前提说明" class="headerlink" title="前提说明"></a>前提说明</h2><ul><li><p>gpu-operator 的代码地址：<a href="https://github.com/NVIDIA/gpu-operator/tree/v23.9.0">https://github.com/NVIDIA/gpu-operator/tree/v23.9.0</a></p></li><li><p>本文分析的 tag 分支：v23.9.0</p></li></ul><h2 id="NVIDIA-GPU-operator-的-CRDs"><a href="#NVIDIA-GPU-operator-的-CRDs" class="headerlink" title="NVIDIA GPU operator 的 CRDs"></a>NVIDIA GPU operator 的 CRDs</h2><p>当我们使用 helm install 部署 gpu-operator 时，默认会部署 4 个 CRDs资源：</p><h3 id="clusterpolicies-nvidia-com"><a href="#clusterpolicies-nvidia-com" class="headerlink" title="clusterpolicies.nvidia.com"></a>clusterpolicies.nvidia.com</h3><p>保存 gpu-operator 需要部署组件的配置信息。helm install 执行同时会创建 cluster-policy 的CR，可以通过kubectl 命令获取：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">clusterpolicies.nvidia.com</span> <span class="string">cluster-policy</span> <span class="string">-o</span> <span class="string">yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">nvidia.com/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2023-12-11T07:05:26Z&quot;</span></span><br><span class="line">  <span class="attr">generation:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/component:</span> <span class="string">gpu-operator</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/instance:</span> <span class="string">release-name</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/managed-by:</span> <span class="string">Helm</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">gpu-operator</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/version:</span> <span class="string">v23.9.0</span></span><br><span class="line">    <span class="attr">helm.sh/chart:</span> <span class="string">gpu-operator-v23.9.0</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-policy</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;5277388&quot;</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">345a5fd4-4549-4605-8fee-880fee68f40e</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ccManager:</span></span><br><span class="line">    <span class="attr">defaultMode:</span> <span class="string">&quot;off&quot;</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">env:</span> []</span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s-cc-manager</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia/cloud-native</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v0.1.1</span></span><br><span class="line">  <span class="attr">cdi:</span></span><br><span class="line">    <span class="attr">default:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">daemonsets:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/managed-by:</span> <span class="string">gpu-operator</span></span><br><span class="line">      <span class="attr">helm.sh/chart:</span> <span class="string">gpu-operator-v23.9.0</span></span><br><span class="line">    <span class="attr">priorityClassName:</span> <span class="string">system-node-critical</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="attr">tolerations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="attr">key:</span> <span class="string">nvidia.com/gpu</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">    <span class="attr">updateStrategy:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">dcgm:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">hostPort:</span> <span class="number">5555</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dcgm</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia/cloud-native</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">3.2</span><span class="number">.6</span><span class="number">-1</span><span class="string">-ubuntu20.04</span></span><br><span class="line">  <span class="attr">dcgmExporter:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DCGM_EXPORTER_LISTEN</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">:9400</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DCGM_EXPORTER_KUBERNETES</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DCGM_EXPORTER_COLLECTORS</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">/etc/dcgm-exporter/dcp-metrics-included.csv</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">dcgm-exporter</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia/k8s</span></span><br><span class="line">    <span class="attr">serviceMonitor:</span></span><br><span class="line">      <span class="attr">additionalLabels:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">honorLabels:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">15s</span></span><br><span class="line">      <span class="attr">relabelings:</span> []</span><br><span class="line">    <span class="attr">version:</span> <span class="number">3.2</span><span class="number">.6</span><span class="number">-3.1</span><span class="number">.9</span><span class="string">-ubuntu20.04</span></span><br><span class="line">  <span class="attr">devicePlugin:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="string">any</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">time-slicing-config-all</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PASS_DEVICE_SPECS</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FAIL_ON_INIT_ERROR</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DEVICE_LIST_STRATEGY</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">envvar</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DEVICE_ID_STRATEGY</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">uuid</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NVIDIA_VISIBLE_DEVICES</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">all</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NVIDIA_DRIVER_CAPABILITIES</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">all</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s-device-plugin</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v0.14.2-ubi8</span></span><br><span class="line">  <span class="attr">driver:</span></span><br><span class="line">    <span class="attr">certConfig:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">cugpudriver-lzw</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">kernelModuleConfig:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">licensingConfig:</span></span><br><span class="line">      <span class="attr">configMapName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">nlsEnabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">manager:</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ENABLE_GPU_POD_EVICTION</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ENABLE_AUTO_DRAIN</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DRAIN_USE_FORCE</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DRAIN_POD_SELECTOR_LABEL</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DRAIN_TIMEOUT_SECONDS</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">0s</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DRAIN_DELETE_EMPTYDIR_DATA</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">k8s-driver-manager</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia/cloud-native</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v0.6.4</span></span><br><span class="line">    <span class="attr">rdma:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">useHostMofed:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">repoConfig:</span></span><br><span class="line">      <span class="attr">configMapName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">docker.io/library</span></span><br><span class="line">    <span class="attr">startupProbe:</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="number">120</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">60</span></span><br><span class="line">    <span class="attr">upgradePolicy:</span></span><br><span class="line">      <span class="attr">autoUpgrade:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">drain:</span></span><br><span class="line">        <span class="attr">deleteEmptyDir:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">force:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">maxParallelUpgrades:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">      <span class="attr">podDeletion:</span></span><br><span class="line">        <span class="attr">deleteEmptyDir:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">force:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">waitForCompletion:</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">useNvidiaDriverCRD:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">usePrecompiled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">11.7</span><span class="number">.1</span><span class="number">-510.108</span><span class="number">.03</span></span><br><span class="line">    <span class="attr">virtualTopology:</span></span><br><span class="line">      <span class="attr">config:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">gfd:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GFD_SLEEP_INTERVAL</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">60s</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">GFD_FAIL_ON_INIT_ERROR</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gpu-feature-discovery</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v0.8.2-ubi8</span></span><br><span class="line">  <span class="attr">kataManager:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">artifactsDir:</span> <span class="string">/opt/nvidia-gpu-operator/artifacts/runtimeclasses</span></span><br><span class="line">      <span class="attr">runtimeClasses:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">artifacts:</span></span><br><span class="line">          <span class="attr">pullSecret:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">nvcr.io/nvidia/cloud-native/kata-gpu-artifacts:ubuntu22.04-535.54.03</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">kata-qemu-nvidia-gpu</span></span><br><span class="line">        <span class="attr">nodeSelector:</span> &#123;&#125;</span><br><span class="line">      <span class="bullet">-</span> <span class="attr">artifacts:</span></span><br><span class="line">          <span class="attr">pullSecret:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">nvcr.io/nvidia/cloud-native/kata-gpu-artifacts:ubuntu22.04-535.86.10-snp</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">kata-qemu-nvidia-gpu-snp</span></span><br><span class="line">        <span class="attr">nodeSelector:</span></span><br><span class="line">          <span class="attr">nvidia.com/cc.capable:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s-kata-manager</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia/cloud-native</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v0.1.2</span></span><br><span class="line">  <span class="attr">mig:</span></span><br><span class="line">    <span class="attr">strategy:</span> <span class="string">single</span></span><br><span class="line">  <span class="attr">migManager:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="string">all-disabled</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">default-mig-parted-config</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">WITH_REBOOT</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">    <span class="attr">gpuClientsConfig:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s-mig-manager</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia/cloud-native</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v0.5.5-ubuntu20.04</span></span><br><span class="line">  <span class="attr">nodeStatusExporter:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gpu-operator-validator</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia/cloud-native</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v23.9.0</span></span><br><span class="line">  <span class="attr">operator:</span></span><br><span class="line">    <span class="attr">defaultRuntime:</span> <span class="string">containerd</span></span><br><span class="line">    <span class="attr">initContainer:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">cuda</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia</span></span><br><span class="line">      <span class="attr">version:</span> <span class="number">12.2</span><span class="number">.2</span><span class="string">-base-ubi8</span></span><br><span class="line">    <span class="attr">runtimeClass:</span> <span class="string">nvidia</span></span><br><span class="line">  <span class="attr">psa:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">psp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">sandboxDevicePlugin:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kubevirt-gpu-device-plugin</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.2.3</span></span><br><span class="line">  <span class="attr">sandboxWorkloads:</span></span><br><span class="line">    <span class="attr">defaultWorkload:</span> <span class="string">container</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">toolkit:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">container-toolkit</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">installDir:</span> <span class="string">/usr/local/nvidia</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia/k8s</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.13.5-centos7</span></span><br><span class="line">  <span class="attr">validator:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gpu-operator-validator</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">plugin:</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">WITH_WORKLOAD</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia/cloud-native</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v23.9.0</span></span><br><span class="line">  <span class="attr">vfioManager:</span></span><br><span class="line">    <span class="attr">driverManager:</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ENABLE_GPU_POD_EVICTION</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ENABLE_AUTO_DRAIN</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">k8s-driver-manager</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia/cloud-native</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v0.6.2</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">cuda</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">12.2</span><span class="number">.2</span><span class="string">-base-ubi8</span></span><br><span class="line">  <span class="attr">vgpuDeviceManager:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">vgpu-device-manager</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia/cloud-native</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v0.2.4</span></span><br><span class="line">  <span class="attr">vgpuManager:</span></span><br><span class="line">    <span class="attr">driverManager:</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ENABLE_GPU_POD_EVICTION</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ENABLE_AUTO_DRAIN</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">k8s-driver-manager</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia/cloud-native</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v0.6.4</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">vgpu-manager</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2023-12-11T07:07:54Z&quot;</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">ClusterPolicy</span> <span class="string">is</span> <span class="string">ready</span> <span class="string">as</span> <span class="string">all</span> <span class="string">resources</span> <span class="string">have</span> <span class="string">been</span> <span class="string">successfully</span> <span class="string">reconciled</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">Reconciled</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Ready</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2023-12-11T07:07:54Z&quot;</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">Ready</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;False&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Error</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">state:</span> <span class="string">ready</span></span><br></pre></td></tr></table></figure><p>可以看到在 CR 的 spec 部分保存了各组件的配置信息，这些配置信息来源于 helm chart 的 values.yaml。</p><p>另外，出了保存各组件的配置信息，在 status 部分，还有一个字段state保存 gpu-operator 状态。</p><h3 id="nvidiadrivers-nvidia-com"><a href="#nvidiadrivers-nvidia-com" class="headerlink" title="nvidiadrivers.nvidia.com"></a>nvidiadrivers.nvidia.com</h3><p>您可以创建一个或多个NVIDIA驱动程序自定义资源实例，通过 nodeSelector 以指定要在特定节点上配置的NVIDIA GPU驱动程序类型和驱动程序版本。<a href="https://docs.nvidia.com/datacenter/cloud-native/gpu-operator/latest/gpu-driver-configuration.html">nvidiadrivers.nvidia.com文档</a></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">nvidia.com/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NVIDIADriver</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demo-gold</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">driverType:</span> <span class="string">gpu</span></span><br><span class="line">  <span class="attr">env:</span> []</span><br><span class="line">  <span class="attr">image:</span> <span class="string">driver</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span> []</span><br><span class="line">  <span class="attr">manager:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">driver.config:</span> <span class="string">&quot;gold&quot;</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">nvcr.io/nvidia</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">&quot;535.104.12&quot;</span></span><br></pre></td></tr></table></figure><h3 id="nodefeatures-nfd-k8s-sigs-io"><a href="#nodefeatures-nfd-k8s-sigs-io" class="headerlink" title="nodefeatures.nfd.k8s-sigs.io"></a>nodefeatures.nfd.k8s-sigs.io</h3><p>// TODO</p><h3 id="nodefeaturerules-nfd-k8s-sigs-io"><a href="#nodefeaturerules-nfd-k8s-sigs-io" class="headerlink" title="nodefeaturerules.nfd.k8s-sigs.io"></a>nodefeaturerules.nfd.k8s-sigs.io</h3><p>// TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;我们知道，如果在Kubernetes中支持GPU设备调度，需要做如下的工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点上安装nvidia驱动&lt;/li&gt;</summary>
      
    
    
    
    <category term="gpu-operator" scheme="http://lizhewei91.github.io/categories/gpu-operator/"/>
    
    
    <category term="gpu-operator" scheme="http://lizhewei91.github.io/tags/gpu-operator/"/>
    
  </entry>
  
  <entry>
    <title>NVIDIA/gpu-operator分析一: NVIDIA驱动安装</title>
    <link href="http://lizhewei91.github.io/2023/12/11/31/"/>
    <id>http://lizhewei91.github.io/2023/12/11/31/</id>
    <published>2023-12-11T02:05:31.000Z</published>
    <updated>2023-12-11T02:07:52.942Z</updated>
    
    
    
    
    <category term="gpu-operator" scheme="http://lizhewei91.github.io/categories/gpu-operator/"/>
    
    
    <category term="nvidia-driver" scheme="http://lizhewei91.github.io/tags/nvidia-driver/"/>
    
    <category term="gpu-operator" scheme="http://lizhewei91.github.io/tags/gpu-operator/"/>
    
  </entry>
  
  <entry>
    <title>在 kubernetes 集群中实现 gpu 共享调度</title>
    <link href="http://lizhewei91.github.io/2023/10/24/08/"/>
    <id>http://lizhewei91.github.io/2023/10/24/08/</id>
    <published>2023-10-24T08:26:08.000Z</published>
    <updated>2023-12-07T06:50:41.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><blockquote><p>Kubernetes 集群中，GPU 资源作为一种外部资源(<a href="https://links.jianshu.com/go?to=https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/%23extended-resources">extended resources</a>)，部署Nvidia官方提供的插件(<a href="https://links.jianshu.com/go?to=https://github.com/NVIDIA/k8s-device-plugin">k8s-device-plugin</a>)后，GPU资源在节点上是以个数暴露给 kubernetes 集群来进行调度的，也就是说如果有两个后端应用 pod 需要使用到 GPU 资源，但集群节点上只有一张 GPU 物理卡的情况下，会导致两个后端应用容器中仅有一个可以正常运行，另一个 pod 则会处于 pending 状态。</p></blockquote><p>想要在 Kubenentes 集群中实现 GPUshare，可以采用阿里云于2019年开源的 <a href="https://links.jianshu.com/go?to=https://github.com/AliyunContainerService/gpushare-device-plugin">gpushare-device-plugin</a>：</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>将节点上的 GPU 资源以 GPU 显存或者 GPU 个数的形式暴露给 Kubernetes，实现多容器共享 GPU 资源。</p><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ul><li>虽然有两种方法来衡量 GPU 的能力( CUDA 核心和 GPU 内存)，在推理场景中，我们可以假设 CUDA 核心和 GPU 内存的数量是成比例的。</li><li>通过<strong>将度量单位从“ GPU 数量”更改为“ MiB 中 GPU 内存的数量”</strong>，利用扩展资源来表达设备共享请求，单位为 : Gi。</li><li>用户对共享GPU的诉求是用于模型开发和预测场景。在这种情况下，<strong>用户请求的 GPU 资源上限不超过一个，即应用的资源上限为单个 GPU</strong>。</li><li>不需要改变任何 Kubernetes 的原生代码，只需要利用扩展的资源、调度扩展器和设备插件机制。</li></ul><h1 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h1><p>定义两个新的扩展资源:</p><ul><li><p>GPU -mem，对应 GPU 内存;</p></li><li><p>GPU -count，对应 GPU 设备的数量。</p></li></ul><p>​    <img src="/2023/10/24/08/arch.jpg" class="" title="img"></p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p><strong>gpushare-scheduler-extender：</strong> 它使用 Kubernetes 调度器 extender 扩展机制，在全局调度器筛选和绑定时，负责确定节点上单个GPU 设备是否能够提供足够的 GPU Memory，并在绑定时将 GPU 分配结果记录到 Pod Spec Annotation中，供后续筛选使用。</p><p><strong>gpushare-device-plugin：</strong>它使用 Device Plugin机制，根据 Pod Spec Annotation上记录的 GPU Share Scheduler Extender 的决定负责分配 GPU 设备。</p><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><h2 id="设备资源上报"><a href="#设备资源上报" class="headerlink" title="设备资源上报"></a>设备资源上报</h2><p>Gpushare-device-plugin 插件使用 nvml 库查询 GPU 设备个数和设备的 GPU 内存。节点的 GPU 总内存( 个数 * memory)通过listanwatch() 报告给 Kubelet ; Kubelet 将这些报告给 Kubernetes API Server。</p><p>如果节点有 2 个 GPU，每个 GPU 有 16276 MiB，则该节点的 GPU 内存为16276 * 2 = 32552。则一共上报两种 “扩展资源”：</p><p> <code>aliyun.com/gpu-count: 2</code>和<code>aliyun.com/gpu-mem: 31 </code></p><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>Gpushare-scheduler-extender 将分配信息记录到 pod 注释中，并在调度器进行过滤时根据这些信息确定每个 GPU 是否有足够的GPU -mem。</p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Kubernetes 调度器完成所有默认过滤器后，通过 http 调用 GPU 共享调度器扩展器的 filter 方法。这是因为默认调度器计算扩展的资源，并且只能确定资源总量是否有满足需求的空闲资源。具体确定是否在单个设备上满足需求; 因此，有必要通过 gpushare-scheduler-extender检查单个设备是否有可用的资源。</p><p>如下图所示。Kubernetes 集群中有3个节点，2个 GPU 设备，当用户申请 GPU -mem=8138时，默认调度器扫描所有节点，发现 N1的剩余资源为(16276 * 2 - 16276 - 12207 = 4069)，因此资源需求不满足，因此 N1 节点被过滤掉。</p><p>N2 和 N3 节点剩余资源为 8138 MiB。它们都满足默认调度器的要求。此时，默认调度器委托 gpushare-scheduler-extender 进行二次过滤。</p><img src="/2023/10/24/08/filter.jpg" class="" title="img"><h3 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h3><p>在二次过滤时，gpushare-scheduler-extender 需要判断单个 GPU 设备是否满足资源需求。在检查 N2 节点时，发现该节点虽然有8138MiB的可用资源，但分布在两个设备上:GPU0 和 GPU1只有4069MiB的可用资源。不能满足单个设备 8138 MiB的要求。</p><p>虽然 N3 节点共有8138MiB可用资源，但这些可用资源都属于GPU0，满足单设备需求。因此，精确的调度可以通过过滤GPU共享调度扩展器来实现。</p><h3 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h3><p>当调度器找到满足需求的节点时，它委托 gpushare-scheduler-extender 绑定节点和 pod。在这里，扩展程序需要做两件事:</p><ul><li>根据 binpack 规则在节点中找到 GPU 设备，记录 GPU 设备ID，并在 pod 注释中保存为<code>ALIYUN_GPU_ID</code>。它还将 pod 应用的 GPU内存保存为 pod 注释中的 <code>ALIYUN_COM_GPU_MEM_POD</code>和<code>ALIYUN_COM_GPU_MEM_ASSUME_TIME</code>。如果绑定时未找到图形处理器，则不进行绑定。默认调度程序将在过期超时后重新调度。</li></ul><blockquote><p>注意: 还有一个名为<code>ALIYUN_COM_GPU_MEM_ASSIGNED</code> 的pod注释，初始化为false。它表示在调度期间假定该pod与GPU设备在一起，但在运行时没有分配。</p></blockquote><ul><li>将 pod 和 node 绑定关系上报给 kube-apiserver </li></ul><p>例如，用户想要请求一个gpu-mem:8138 的 pod，选择节点N1:首先分析不同gpu的可用资源，分别是GPU0(12207)、GPU1(8138)、GPU2(4069)和GPU3(16276)。GPU2(4069)的剩余资源不令人满意，因此丢弃设备;在满足要求的其他三个gpu中，选择剩余资源最少的GPU1(8138)。</p><img src="/2023/10/24/08/bind.jpg" class="" title="img"><h2 id="在节点上运行容器"><a href="#在节点上运行容器" class="headerlink" title="在节点上运行容器"></a>在节点上运行容器</h2><p>在创建容器之前，在 Kubelet 中调用 gpushare-device-plugin 中的 Allocate 函数( Allocate 的参数是 GPU 内存请求量) :</p><p>从Kubernetes API Server 获取所有 pending状态和申请gpu共享的pod，该节点中GPU内存请求量由assumedTimestamp排序</p><img src="/2023/10/24/08/sequence.jpg" class="" title="img">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Kubernetes 集群中，GPU 资源作为一种外部资源(&lt;a href=&quot;https://li</summary>
      
    
    
    
    <category term="gpushare" scheme="http://lizhewei91.github.io/categories/gpushare/"/>
    
    
    <category term="gpu" scheme="http://lizhewei91.github.io/tags/gpu/"/>
    
    <category term="gpushare" scheme="http://lizhewei91.github.io/tags/gpushare/"/>
    
  </entry>
  
  <entry>
    <title>利用 kubeadm 部署高可用 k8s 集群</title>
    <link href="http://lizhewei91.github.io/2023/09/25/51/"/>
    <id>http://lizhewei91.github.io/2023/09/25/51/</id>
    <published>2023-09-25T02:16:51.000Z</published>
    <updated>2023-10-07T07:08:58.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高可用拓扑"><a href="#高可用拓扑" class="headerlink" title="高可用拓扑"></a>高可用拓扑</h1><p>可以设置 HA 集群：</p><ul><li>使用堆叠（stacked）控制平面节点，其中 etcd 节点与控制平面节点共存；</li><li>使用外部 etcd 节点，其中 etcd 在与控制平面不同的节点上运行；</li></ul><p>在设置 HA 集群之前，应该仔细考虑每种拓扑的优缺点。</p><h2 id="堆叠（Stacked）-etcd-拓扑"><a href="#堆叠（Stacked）-etcd-拓扑" class="headerlink" title="堆叠（Stacked） etcd 拓扑"></a>堆叠（Stacked） etcd 拓扑</h2><img src="/2023/09/25/51/1646207343118-e2965629-832f-48e1-9e63-c774ba47fb28.png" class="" title="img"><p>主要特点：</p><ul><li>etcd 分布式数据存储集群堆叠在 kubeadm 管理的控制平面节点上，作为控制平面的一个组件运行。</li><li>每个控制平面节点运行 kube-apiserver，kube-scheduler 和 kube-controller-manager 实例。</li><li>kube-apiserver 使用 LB 暴露给工作节点。</li><li>每个控制平面节点创建一个本地 etcd 成员（member），这个 etcd 成员只与该节点的 kube-apiserver 通信。这同样适用于本地 kube-controller-manager 和 kube-scheduler 实例。</li><li>简单概况：每个 master 节点上运行一个 apiserver 和 etcd, etcd 只与本节点 apiserver 通信。</li><li>这种拓扑将控制平面和 etcd 成员耦合在同一节点上。相对使用外部 etcd 集群，设置起来更简单，而且更易于副本管理。</li><li>然而堆叠集群存在耦合失败的风险。如果一个节点发生故障，则 etcd 成员和控制平面实例都将丢失，并且冗余会受到影响。可以通过添加更多控制平面节点来降低此风险。应该为 HA 集群运行至少三个堆叠的控制平面节点（防止脑裂）。</li><li>这是 kubeadm 中的默认拓扑。当使用 kubeadm init 和 kubeadm join –control-plane 时，在控制平面节点上会自动创建本地 etcd 成员。</li></ul><h2 id="外部-etcd-拓扑"><a href="#外部-etcd-拓扑" class="headerlink" title="外部 etcd 拓扑"></a>外部 etcd 拓扑</h2><img src="/2023/09/25/51/1646207402403-1f4b8329-dff3-4a6c-9491-f0a7c33686f9.png" class="" title="img"><p>主要特点：</p><ul><li>具有外部 etcd 的 HA 集群是一种这样的拓扑，其中 etcd 分布式数据存储集群在独立于控制平面节点的其他节点上运行。</li><li>就像堆叠的 etcd 拓扑一样，外部 etcd 拓扑中的每个控制平面节点都运行 kube-apiserver，kube-scheduler 和 kube-controller-manager 实例。</li><li>同样 kube-apiserver 使用负载均衡器暴露给工作节点。但是，etcd 成员在不同的主机上运行，每个 etcd 主机与每个控制平面节点的 kube-apiserver 通信。</li><li>简单概况： etcd 集群运行在单独的主机上，每个 etcd 都与 apiserver 节点通信。</li><li>这种拓扑结构解耦了控制平面和 etcd 成员。因此，它提供了一种 HA 设置，其中失去控制平面实例或者 etcd 成员的影响较小，并且不会像堆叠的 HA 拓扑那样影响集群冗余。</li><li>但是，此拓扑需要两倍于堆叠 HA 拓扑的主机数量。具有此拓扑的 HA 集群至少需要三个用于控制平面节点的主机和三个用于 etcd 节点的主机。</li><li>需要单独设置外部 etcd 集群。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>官方这里主要是解决了高可用场景下 apiserver 与 etcd 集群的关系，以及控制平面节点防止单点故障。但是集群对外访问接口不可能将三个 apiserver 都暴露出去，一个节点挂掉时还是不能自动切换到其他节点。官方只提到了一句“使用负载均衡器将 apiserver 暴露给工作节点”，而这恰恰是部署过程中需要解决的重点问题。</p><p>Notes: 此处的负载均衡器并不是 kube-proxy，此处的 Load Balancer 是针对 apiserver 的。</p><p>最后，我们总结一下两种拓扑：</p><ul><li>堆叠（Stacked） etcd 拓扑：设置简单，易于副本管理 ，不过存在耦合失败风险。如果节点发生故障，则 etcd 成员和控制平面实例有丢失的可能，推荐测试开发环境；</li><li>外部 etcd 拓扑：解耦了控制平面和 etcd 成员，不会像堆叠的 HA 拓扑那样有影响集群冗余的风险，不过需要两倍于堆叠 HA 拓扑的主机数量，设置相对复杂，推荐生产环境。</li></ul><h1 id="部署stacked高可用集群"><a href="#部署stacked高可用集群" class="headerlink" title="部署stacked高可用集群"></a>部署stacked高可用集群</h1><h2 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h2><img src="/2023/09/25/51/1646207655247-b9bb4b48-88d5-4d34-9048-a90ec7355274-5609124.png" class="" title="image.png"><h2 id="资源信息"><a href="#资源信息" class="headerlink" title="资源信息"></a>资源信息</h2><table><thead><tr><th>主机hostname</th><th>IP地址</th><th>安装组件</th></tr></thead><tbody><tr><td>master-01</td><td>192.168.1.143</td><td>containerd、kubeadm、 kubelet、 kubectl</td></tr><tr><td>master-02</td><td>192.168.1.130</td><td>containerd、kubeadm、 kubelet、 kubectl</td></tr><tr><td>master-03</td><td>192.168.1.168</td><td>containerd、kubeadm、 kubelet、 kubectl</td></tr><tr><td>work-01</td><td>106.74.16.106</td><td>containerd、kubeadm、 kubelet、 kubectl</td></tr><tr><td>VIP</td><td>192.168.1.100</td><td></td></tr></tbody></table><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="保证环境正确性"><a href="#保证环境正确性" class="headerlink" title="保证环境正确性"></a>保证环境正确性</h3><table><thead><tr><th>purpose</th><th>commands</th></tr></thead><tbody><tr><td>保证集群各节点互通</td><td>ping -c 3 <ip></td></tr><tr><td>保证MAC地址唯一</td><td>ip link 或 ifconfig -a</td></tr><tr><td>保证集群内主机名唯一</td><td>查询 hostnamectl status，修改 hostnamectl set-hostname <hostname></td></tr><tr><td>保证系统产品uuid唯一</td><td>sudo cat /sys/class/dmi/id/product_uuid</td></tr></tbody></table><p>修改MAC地址参考命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 down</span><br><span class="line">ifconfig eth0 hw ether 00:0C:18:EF:FF:ED</span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><blockquote><p>如product_uuid不唯一，请考虑重装CentOS系统.</p></blockquote><h3 id="检查所需端口"><a href="#检查所需端口" class="headerlink" title="检查所需端口"></a>检查所需端口</h3><p>启用这些<a href="https://kubernetes.io/zh/docs/reference/ports-and-protocols/">必要的端口</a>后才能使 Kubernetes 的各组件相互通信。可以使用 telnet 来检查端口是否启用，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet 127.0.0.1 6443</span><br></pre></td></tr></table></figure><p><strong>控制面</strong> </p><table><thead><tr><th>协议</th><th>方向</th><th>端口范围</th><th>目的</th><th>使用者</th></tr></thead><tbody><tr><td>TCP</td><td>入站</td><td>6443</td><td>Kubernetes API server</td><td>所有</td></tr><tr><td>TCP</td><td>入站</td><td>2379-2380</td><td>etcd server client API</td><td>kube-apiserver, etcd</td></tr><tr><td>TCP</td><td>入站</td><td>10250</td><td>Kubelet API</td><td>自身, 控制面</td></tr><tr><td>TCP</td><td>入站</td><td>10259</td><td>kube-scheduler</td><td>自身</td></tr><tr><td>TCP</td><td>入站</td><td>10257</td><td>kube-controller-manager</td><td>自身</td></tr></tbody></table><p>尽管 etcd 的端口也列举在控制面的部分，但你也可以在外部自己托管 etcd 集群或者自定义端口。</p><p><strong>工作节点</strong> </p><table><thead><tr><th>协议</th><th>方向</th><th>端口范围</th><th>目的</th><th>使用者</th></tr></thead><tbody><tr><td>TCP</td><td>入站</td><td>10250</td><td>Kubelet API</td><td>自身, 控制面</td></tr><tr><td>TCP</td><td>入站</td><td>30000-32767</td><td>NodePort Services</td><td>所有</td></tr></tbody></table><h3 id="禁用swap"><a href="#禁用swap" class="headerlink" title="禁用swap"></a>禁用swap</h3><p>swap仅当内存不够时会使用硬盘块充当额外内存，硬盘的io较内存差距极大，禁用swap以提高性能</p><p>各节点均需执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swapoff -a </span><br><span class="line">sed -i &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><h2 id="安装containerd"><a href="#安装containerd" class="headerlink" title="安装containerd"></a>安装containerd</h2><h3 id="获取containerd安装包"><a href="#获取containerd安装包" class="headerlink" title="获取containerd安装包"></a>获取containerd安装包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget https://github.com/containerd/containerd/releases/download/v1.7.0/cri-containerd-cni-1.7.0-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="查看压缩包中文件"><a href="#查看压缩包中文件" class="headerlink" title="查看压缩包中文件"></a>查看压缩包中文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar -tf cri-containerd-cni-1.7.0-linux-amd64.tar.gz</span><br><span class="line">cri-containerd.DEPRECATED.txt</span><br><span class="line">etc/</span><br><span class="line">etc/systemd/</span><br><span class="line">etc/systemd/system/</span><br><span class="line">etc/systemd/system/containerd.service</span><br><span class="line">etc/crictl.yaml</span><br><span class="line">etc/cni/</span><br><span class="line">etc/cni/net.d/</span><br><span class="line">etc/cni/net.d/10-containerd-net.conflist</span><br><span class="line">usr/</span><br><span class="line">usr/local/</span><br><span class="line">usr/local/sbin/</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="直接将压缩包解压到系统的各个目录中"><a href="#直接将压缩包解压到系统的各个目录中" class="headerlink" title="直接将压缩包解压到系统的各个目录中"></a>直接将压缩包解压到系统的各个目录中</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar -C / -xzf cri-containerd-cni-1.7.0-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo kubeadm init --kubernetes-version=v1.27.6 \</span><br><span class="line">--control-plane-endpoint &quot;106.74.16.106:8443&quot; \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">--service-cidr=10.96.0.0/12 \</span><br><span class="line">--upload-certs</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;高可用拓扑&quot;&gt;&lt;a href=&quot;#高可用拓扑&quot; class=&quot;headerlink&quot; title=&quot;高可用拓扑&quot;&gt;&lt;/a&gt;高可用拓扑&lt;/h1&gt;&lt;p&gt;可以设置 HA 集群：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用堆叠（stacked）控制平面节点，其中 etcd 节点与控制</summary>
      
    
    
    
    <category term="kubeadm" scheme="http://lizhewei91.github.io/categories/kubeadm/"/>
    
    
    <category term="kubeadm" scheme="http://lizhewei91.github.io/tags/kubeadm/"/>
    
  </entry>
  
  <entry>
    <title>nexus 使用总结</title>
    <link href="http://lizhewei91.github.io/2023/09/07/32/"/>
    <id>http://lizhewei91.github.io/2023/09/07/32/</id>
    <published>2023-09-07T09:28:32.000Z</published>
    <updated>2023-09-11T08:04:53.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="部署-nexus-服务"><a href="#部署-nexus-服务" class="headerlink" title="部署 nexus 服务"></a>部署 nexus 服务</h1><p>创建docker-compose.yml文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">nexus3:</span></span><br><span class="line">    <span class="comment"># 镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">sonatype/nexus3:3.59.0</span></span><br><span class="line">    <span class="comment"># 容器名称</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nexus3-lzw-test</span></span><br><span class="line">    <span class="comment"># 重启策略</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">on-failure</span></span><br><span class="line">    <span class="comment"># 端口映射</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># web 服务使用</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:8081&quot;</span></span><br><span class="line">      <span class="comment"># http 仓库使用</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8082:8082&quot;</span></span><br><span class="line">      <span class="comment"># 代理仓库使用</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="comment"># 挂载数据卷</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 将主机的/opt/neuxus3/data目录挂载映射到容器的/nexus-data目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/nexus3/data:/nexus-data</span></span><br><span class="line">    <span class="comment"># 设置环境变量</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 配置nexus3服务的内存，避免小规格机器崩掉</span></span><br><span class="line">      <span class="attr">INSTALL4J_ADD_VM_PARAMS:</span> <span class="string">&quot;-Xms512m -Xmx512m -XX:MaxDirectMemorySize=512m -Djava.util.prefs.userRoot=/nexus-data/javaprefs&quot;</span></span><br></pre></td></tr></table></figure><p> 创建启动脚本start.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仓库数据挂载位置</span></span><br><span class="line">mkdir -p &quot;/opt/nexus3/data&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目录权限</span></span><br><span class="line">chmod -R 777 &quot;/opt/nexus3/data&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">if [ &quot;$1&quot; == &quot;backend&quot; ]; then</span><br><span class="line">    docker-compose up -d</span><br><span class="line">else</span><br><span class="line">  docker-compose up</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>启动 nexus3，启动会比较慢，需要一段时间才能启动成功</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式一、前台启动，查看启动日志调试用</span></span><br><span class="line">sudo sh ./start.sh</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二、后台启动</span></span><br><span class="line">sudo sh ./start.sh backend</span><br></pre></td></tr></table></figure><img src="/2023/09/07/32/image-20230911155849960.png" class="" title="image-20230911155849960"><p>访问 http://<ip>:8081或<a href="http://localhost:8081（本地），查看仓库页面">http://localhost:8081（本地），查看仓库页面</a></p><img src="/2023/09/07/32/image-20230911155929241.png" class="" title="image-20230911155929241"><p>点击右上角“Sign in”，用户名为“admin”，在映射的主机目录/opt/nexus3/data/admin.password文件中查看登录密码</p><img src="/2023/09/07/32/5711b837e3314244a5928be6f168c8f9.png" class="" title="img"><img src="/2023/09/07/32/c354c1d40b9c4e939ac0b7e9c1edbe40.png" class="" title="img"><p>登录后会有引导窗口，跟着知道重新配置密码，开启匿名访问即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;部署-nexus-服务&quot;&gt;&lt;a href=&quot;#部署-nexus-服务&quot; class=&quot;headerlink&quot; title=&quot;部署 nexus 服务&quot;&gt;&lt;/a&gt;部署 nexus 服务&lt;/h1&gt;&lt;p&gt;创建docker-compose.yml文件：&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    <category term="nexus" scheme="http://lizhewei91.github.io/categories/nexus/"/>
    
    
    <category term="nexus" scheme="http://lizhewei91.github.io/tags/nexus/"/>
    
    <category term="docker-repositories" scheme="http://lizhewei91.github.io/tags/docker-repositories/"/>
    
  </entry>
  
  <entry>
    <title>使用 kubebuilder 开发一个 operator 应用</title>
    <link href="http://lizhewei91.github.io/2023/09/01/10/"/>
    <id>http://lizhewei91.github.io/2023/09/01/10/</id>
    <published>2023-09-01T06:55:10.000Z</published>
    <updated>2023-09-05T06:07:56.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubebuilder-介绍"><a href="#Kubebuilder-介绍" class="headerlink" title="Kubebuilder 介绍"></a>Kubebuilder 介绍</h1><p><a href="https://github.com/kubernetes-sigs/kubebuilder">Kubebuilder</a> 是一个使用 CRDs 构建 K8s API 的 SDK，主要是：</p><ul><li>提供脚手架工具初始化 CRDs 工程，自动生成 boilerplate 代码和配置；</li><li>提供代码库封装底层的 K8s go-client；</li></ul><p>方便用户从零开始开发 CRDs，Controllers 和 Admission Webhooks 来扩展 K8s。</p><p>本文主要基于 <strong>kubebuilder v3.11.1</strong>，从零开发一个 operator 应用。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><a href="https://golang.org/dl/">go</a> version v1.20.0+</li><li><a href="https://docs.docker.com/install/">docker</a> version 17.03+.</li><li><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">kubectl</a> version v1.11.3+.</li><li>能够访问 Kubernetes v1.11.3+ 集群.</li></ul><p><strong>安装kubebuilder</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os=$(go env GOOS)</span><br><span class="line">arch=$(go env GOARCH)</span><br><span class="line"></span><br><span class="line">curl -L -o kubebuilder https://go.kubebuilder.io/dl/3.11.1/$&#123;os&#125;/$&#123;arch&#125;</span><br><span class="line">chmod +x kubebuilder &amp;&amp; mv kubebuilder /usr/local/bin/</span><br></pre></td></tr></table></figure><h2 id="项目示例"><a href="#项目示例" class="headerlink" title="项目示例"></a>项目示例</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /go/src/kubebuilder-project</span><br><span class="line">cd /go/src/kubebuilder-project</span><br><span class="line">kubebuilder init --domain chinaunicom.cn --repo=kubebuilder-project</span><br></pre></td></tr></table></figure><blockquote><p>–domain: 设定域名，一般设定为公司域名</p><p>–repo: 如果您的项目在GOPATH中初始化，则隐式调用go mod init将为您插入模块路径。否则必须设置–repo=&lt;模块路径&gt;。</p></blockquote><h3 id="创建-API-和-Controller"><a href="#创建-API-和-Controller" class="headerlink" title="创建 API 和 Controller"></a>创建 API 和 Controller</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubebuilder create api --group extensions --version v1 --kind UnitedDeployment --namespaced true</span><br><span class="line">// 实际上不仅会创建 API，也就是 CRD，还会生成 Controller 的框架</span><br><span class="line"></span><br><span class="line">Create Resource [y/n]</span><br><span class="line">y</span><br><span class="line">Create Controller [y/n]</span><br><span class="line">y</span><br></pre></td></tr></table></figure><p><strong>参数解读</strong>：</p><ul><li>group:  表示该CRD 的 Group组前缀，group=<group>.<domain>, 则该CRD生成的 group=extensions.chinaunicom.cn</li></ul><ul><li>version 一般分三种，按社区标准：<ul><li>v1alpha1: 此 api 不稳定，CRD 可能废弃、字段可能随时调整，不要依赖；</li><li>v1beta1: api 已稳定，会保证向后兼容，特性可能会调整；</li><li>v1: api 和特性都已稳定；</li></ul></li><li>kind: 此 CRD 的类型，使用大驼峰单数形式；</li><li>namespaced: 此 CRD 是k8s集群级别资源，还是 namespace隔离的</li></ul><h3 id="创建-webhook（可选）"><a href="#创建-webhook（可选）" class="headerlink" title="创建 webhook（可选）"></a>创建 webhook（可选）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 创建UnitedSet的 MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook</span><br><span class="line">kubebuilder create webhook --group extensions --version v1 --kind UnitedDeployment --defaulting --programmatic-validation</span><br></pre></td></tr></table></figure><p><strong>参数解读</strong>：</p><ul><li>defaulting: 创建 MutatingAdmissionWebhook</li><li>programmatic-validation: 创建 ValidatingAdmissionWebhook</li></ul><p>至此，kubebuilder 脚手架搭建的 operator 框架已经完成，下面看一下项目结构：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@localhost kubebuilder-project]# tree</span><br><span class="line">.</span><br><span class="line">|-- Dockerfile</span><br><span class="line">|-- Makefile</span><br><span class="line">|-- PROJECT</span><br><span class="line">|-- README.md</span><br><span class="line">|-- api</span><br><span class="line">|   `-- v1</span><br><span class="line">|       |-- groupversion_info.go</span><br><span class="line">|       |-- uniteddeployment_types.go</span><br><span class="line">|       |-- uniteddeployment_webhook.go</span><br><span class="line">|       |-- webhook_suite_test.go</span><br><span class="line">|       `-- zz_generated.deepcopy.go</span><br><span class="line">|-- bin</span><br><span class="line">|   `-- controller-gen</span><br><span class="line">|-- cmd</span><br><span class="line">|   `-- main.go</span><br><span class="line">|-- config</span><br><span class="line">|   |-- certmanager</span><br><span class="line">|   |   |-- certificate.yaml</span><br><span class="line">|   |   |-- kustomization.yaml</span><br><span class="line">|   |   `-- kustomizeconfig.yaml</span><br><span class="line">|   |-- crd</span><br><span class="line">|   |   |-- kustomization.yaml</span><br><span class="line">|   |   |-- kustomizeconfig.yaml</span><br><span class="line">|   |   `-- patches</span><br><span class="line">|   |       |-- cainjection_in_uniteddeployments.yaml</span><br><span class="line">|   |       `-- webhook_in_uniteddeployments.yaml</span><br><span class="line">|   |-- default</span><br><span class="line">|   |   |-- kustomization.yaml</span><br><span class="line">|   |   |-- manager_auth_proxy_patch.yaml</span><br><span class="line">|   |   |-- manager_config_patch.yaml</span><br><span class="line">|   |   |-- manager_webhook_patch.yaml</span><br><span class="line">|   |   `-- webhookcainjection_patch.yaml</span><br><span class="line">|   |-- manager</span><br><span class="line">|   |   |-- kustomization.yaml</span><br><span class="line">|   |   `-- manager.yaml</span><br><span class="line">|   |-- prometheus</span><br><span class="line">|   |   |-- kustomization.yaml</span><br><span class="line">|   |   `-- monitor.yaml</span><br><span class="line">|   |-- rbac</span><br><span class="line">|   |   |-- auth_proxy_client_clusterrole.yaml</span><br><span class="line">|   |   |-- auth_proxy_role.yaml</span><br><span class="line">|   |   |-- auth_proxy_role_binding.yaml</span><br><span class="line">|   |   |-- auth_proxy_service.yaml</span><br><span class="line">|   |   |-- kustomization.yaml</span><br><span class="line">|   |   |-- leader_election_role.yaml</span><br><span class="line">|   |   |-- leader_election_role_binding.yaml</span><br><span class="line">|   |   |-- role_binding.yaml</span><br><span class="line">|   |   |-- service_account.yaml</span><br><span class="line">|   |   |-- uniteddeployment_editor_role.yaml</span><br><span class="line">|   |   `-- uniteddeployment_viewer_role.yaml</span><br><span class="line">|   |-- samples</span><br><span class="line">|   |   |-- extensions_v1_uniteddeployment.yaml</span><br><span class="line">|   |   `-- kustomization.yaml</span><br><span class="line">|   `-- webhook</span><br><span class="line">|       |-- kustomization.yaml</span><br><span class="line">|       |-- kustomizeconfig.yaml</span><br><span class="line">|       `-- service.yaml</span><br><span class="line">|-- go.mod</span><br><span class="line">|-- go.sum</span><br><span class="line">|-- hack</span><br><span class="line">|   `-- boilerplate.go.txt</span><br><span class="line">`-- internal</span><br><span class="line">    `-- controller</span><br><span class="line">        |-- suite_test.go</span><br><span class="line">        `-- uniteddeployment_controller.go</span><br></pre></td></tr></table></figure><h3 id="定义-CRD-字段"><a href="#定义-CRD-字段" class="headerlink" title="定义 CRD 字段"></a>定义 CRD 字段</h3><p>自定义 UnitedDeploymentSpec 字段</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UnitedDeploymentSpec <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster</span></span><br><span class="line"><span class="comment">// Important: Run &quot;make&quot; to regenerate code after modifying this file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Foo is an example field of UnitedDeployment. Edit uniteddeployment_types.go to remove/update</span></span><br><span class="line">DeploymentName <span class="type">string</span> <span class="string">`json:&quot;deploymentName&quot;`</span></span><br><span class="line">Replicas       *<span class="type">int32</span> <span class="string">`json:&quot;replicas&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 UnitedDeploymentStatus 字段</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UnitedDeploymentStatus <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster</span></span><br><span class="line"><span class="comment">// Important: Run &quot;make&quot; to regenerate code after modifying this file</span></span><br><span class="line">AvailableReplicas *<span class="type">int32</span> <span class="string">`json:&quot;availableReplicas&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>如果修改了 <code>apis/v1/uniteddeployment_types.go</code> ，需要执行以下命令来更新代码和manifests：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make manifests</span><br></pre></td></tr></table></figure><h3 id="使用-code-generator"><a href="#使用-code-generator" class="headerlink" title="使用 code-generator"></a>使用 code-generator</h3><h4 id="更新依赖版本"><a href="#更新依赖版本" class="headerlink" title="更新依赖版本"></a>更新依赖版本</h4><p>初始化项目后的go.mod：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module kubebuilder-project</span><br><span class="line"></span><br><span class="line">go 1.21</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">        github.com/onsi/ginkgo/v2 v2.9.5</span><br><span class="line">        github.com/onsi/gomega v1.27.7</span><br><span class="line">        k8s.io/api v0.27.2</span><br><span class="line">        k8s.io/apimachinery v0.27.2</span><br><span class="line">        k8s.io/client-go v0.27.2</span><br><span class="line">        sigs.k8s.io/controller-runtime v0.15.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>需要将初始化的k8s库更新到要使用的版本，如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">K8S_VERSION=v0.28.0</span><br><span class="line">go get k8s.io/api@<span class="variable">$K8S_VERSION</span></span><br><span class="line">go get k8s.io/client-go@<span class="variable">$K8S_VERSION</span></span><br><span class="line">go get k8s.io/apimachinery@<span class="variable">$K8S_VERSION</span></span><br></pre></td></tr></table></figure><h4 id="安装-code-generator"><a href="#安装-code-generator" class="headerlink" title="安装 code-generator"></a>安装 code-generator</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">K8S_VERSION=v0.28.0</span><br><span class="line">go get k8s.io/code-generator@<span class="variable">$K8S_VERSION</span></span><br><span class="line">go mod vendor</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li>code-generator 包版本, 需要与 kubernetes 相关包版本，保持一致</li><li>需要将依赖复制到 vendor 中</li></ul></blockquote><h4 id="创建-amp-amp-修改所需文件"><a href="#创建-amp-amp-修改所需文件" class="headerlink" title="创建 &amp;&amp; 修改所需文件"></a>创建 &amp;&amp; 修改所需文件</h4><p>需要在api目录下创建code-generator所需的文件，并添加相关注释。</p><ul><li><p>新增 <code>api/v1/doc.go</code></p><p><strong>注意：</strong>修改groupName，package与api的version保持一致。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +groupName=extensions.chinaunicom.cn</span></span><br><span class="line"><span class="keyword">package</span> v1</span><br></pre></td></tr></table></figure></li><li><p>新增 <code>api/v1/register.go</code></p><p><strong>注意：</strong>package与api的version保持一致。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;k8s.io/apimachinery/pkg/runtime/schema&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SchemeGroupVersion is group version used to register these objects.</span></span><br><span class="line"><span class="keyword">var</span> SchemeGroupVersion = GroupVersion</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resource takes an unqualified resource and returns a Group qualified GroupResource</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Resource</span><span class="params">(resource <span class="type">string</span>)</span></span> schema.GroupResource &#123;</span><br><span class="line">    <span class="keyword">return</span> SchemeGroupVersion.WithResource(resource).GroupResource()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 <code>api/v1/&#123;crd&#125;_types.go</code> 文件，添加注释 <code>// +genclient</code></p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//+genclient</span></span><br><span class="line"><span class="comment">//+kubebuilder:object:root=true</span></span><br><span class="line"><span class="comment">//+kubebuilder:subresource:status</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UnitedDeployment is the Schema for the uniteddeployments API</span></span><br><span class="line"><span class="keyword">type</span> UnitedDeployment <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta   <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line">metav1.ObjectMeta <span class="string">`json:&quot;metadata,omitempty&quot;`</span></span><br><span class="line"></span><br><span class="line">Spec   UnitedDeploymentSpec   <span class="string">`json:&quot;spec,omitempty&quot;`</span></span><br><span class="line">Status UnitedDeploymentStatus <span class="string">`json:&quot;status,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="准备-hack-脚本"><a href="#准备-hack-脚本" class="headerlink" title="准备 hack 脚本"></a>准备 hack 脚本</h4><p>在项目 <code>hack</code> 目录下准备以下文件：</p><ul><li>新建 <code>hack/tools.go</code> 文件导入 code-generator 包</li></ul><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:build tools</span></span><br><span class="line"><span class="comment">// +build tools</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This package imports things required by build scripts, to force `go mod` to see them as dependencies</span></span><br><span class="line"><span class="keyword">package</span> tools</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;k8s.io/code-generator&quot;</span></span><br></pre></td></tr></table></figure><ul><li>新建 <code>hack/update-codegen.sh</code>，根据项目修改相应的变量</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">set -o errexit</span><br><span class="line">set -o nounset</span><br><span class="line">set -o pipefail</span><br><span class="line"></span><br><span class="line">SCRIPT_ROOT=$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/..</span><br><span class="line">CODEGEN_PKG=$&#123;CODEGEN_PKG:-$(cd &quot;$&#123;SCRIPT_ROOT&#125;&quot;; ls -d -1 ./vendor/k8s.io/code-generator 2&gt;/dev/null || echo ../code-generator)&#125;</span><br><span class="line"></span><br><span class="line">source &quot;$&#123;CODEGEN_PKG&#125;/kube_codegen.sh&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">generate the code with:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--output-base    because this script should also be able to run inside the vendor <span class="built_in">dir</span> of</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                 k8s.io/kubernetes. The output-base is needed <span class="keyword">for</span> the generators to output into the vendor <span class="built_in">dir</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                 instead of the <span class="variable">$GOPATH</span> directly. For normal projects this can be dropped.</span></span><br><span class="line"></span><br><span class="line">kube::codegen::gen_helpers \</span><br><span class="line">    --input-pkg-root kubebuilder-project/apis \</span><br><span class="line">    --output-base &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/../..&quot; \</span><br><span class="line">    --boilerplate &quot;$&#123;SCRIPT_ROOT&#125;/hack/custom-boilerplate.go.txt&quot;</span><br><span class="line"></span><br><span class="line">kube::codegen::gen_client \</span><br><span class="line">    --with-watch \</span><br><span class="line">    --input-pkg-root kubebuilder-project/apis \</span><br><span class="line">    --output-pkg-root kubebuilder-project/pkg/generated \</span><br><span class="line">    --output-base &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/../..&quot; \</span><br><span class="line">    --boilerplate &quot;$&#123;SCRIPT_ROOT&#125;/hack/custom-boilerplate.go.txt&quot;</span><br></pre></td></tr></table></figure><p>hack 目录下，新建 verify-codegen.sh </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">set -o errexit</span><br><span class="line">set -o nounset</span><br><span class="line">set -o pipefail</span><br><span class="line"></span><br><span class="line">SCRIPT_ROOT=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)/..&quot; &amp;&amp; pwd -P)&quot;</span><br><span class="line">DIFFROOT=&quot;$&#123;SCRIPT_ROOT&#125;/pkg&quot;</span><br><span class="line">TMP_DIFFROOT=&quot;$(mktemp -d -t &quot;$(basename &quot;$0&quot;).XXXXXX&quot;)/pkg&quot;</span><br><span class="line"></span><br><span class="line">cleanup() &#123;</span><br><span class="line">  rm -rf &quot;$&#123;TMP_DIFFROOT&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">trap &quot;cleanup&quot; EXIT SIGINT</span><br><span class="line"></span><br><span class="line">cleanup</span><br><span class="line"></span><br><span class="line">mkdir -p &quot;$&#123;TMP_DIFFROOT&#125;&quot;</span><br><span class="line">cp -a &quot;$&#123;DIFFROOT&#125;&quot;/* &quot;$&#123;TMP_DIFFROOT&#125;&quot;</span><br><span class="line"></span><br><span class="line">&quot;$&#123;SCRIPT_ROOT&#125;/hack/update-codegen.sh&quot;</span><br><span class="line">echo &quot;diffing $&#123;DIFFROOT&#125; against freshly generated codegen&quot;</span><br><span class="line">ret=0</span><br><span class="line">diff -Naupr &quot;$&#123;DIFFROOT&#125;&quot; &quot;$&#123;TMP_DIFFROOT&#125;&quot; || ret=$?</span><br><span class="line">if [[ $ret -eq 0 ]]; then</span><br><span class="line">  echo &quot;$&#123;DIFFROOT&#125; up to date.&quot;</span><br><span class="line">else</span><br><span class="line">  echo &quot;$&#123;DIFFROOT&#125; is out of date. Please run hack/update-codegen.sh&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>hack目录脚本文件，可以参考，<a href="https://github.com/kubernetes/sample-controller/tree/v0.28.0/hack">sample-controller/hack</a> 项目</p><h4 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h4><p><strong>注意</strong>：kubebuilder v3.11.1 版本生成的 api 目录结构, code-generator无法直接使用(将 api 由 <code>api/$&#123;VERSION&#125;</code> 移动至 <code>apis/$&#123;GROUP&#125;/$&#123;VERSION&#125;</code> 即可)</p><p>修改 <code>Makefile</code> ，添加生成命令</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: update-codegen</span></span><br><span class="line"><span class="section">update-codegen:</span></span><br><span class="line">chmod +x ./hack/update-codegen.sh</span><br><span class="line">./hack/update-codegen.sh</span><br></pre></td></tr></table></figure><p>项目根目录下执行<code>make update-codegen </code>即可，将生成如下代码结构：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@localhost kubebuilder-project]# tree -L 4</span><br><span class="line">.</span><br><span class="line">|-- apis</span><br><span class="line">|   `-- extensions</span><br><span class="line">|       `-- v1</span><br><span class="line">|           |-- doc.go</span><br><span class="line">|           |-- groupversion_info.go</span><br><span class="line">|           |-- register.go</span><br><span class="line">|           |-- types.go</span><br><span class="line">|           |-- uniteddeployment_webhook.go</span><br><span class="line">|           |-- webhook_suite_test.go</span><br><span class="line">|           `-- zz_generated.deepcopy.go</span><br><span class="line">`-- pkg</span><br><span class="line">    `-- generated</span><br><span class="line">        |-- clientset</span><br><span class="line">        |   `-- versioned</span><br><span class="line">        |-- informers</span><br><span class="line">        |   `-- externalversions</span><br><span class="line">        `-- listers</span><br><span class="line">            `-- extensions</span><br></pre></td></tr></table></figure><p>这里有一个坑，需要把 <code>apis/extensions/v1</code>目录下，<code>unitddeployment_type.go  </code>修改为 <code>type.go</code>,否则执行命令后，无法生成代码。</p><h3 id="本地调试运行"><a href="#本地调试运行" class="headerlink" title="本地调试运行"></a>本地调试运行</h3><h4 id="CRD安装"><a href="#CRD安装" class="headerlink" title="CRD安装"></a>CRD安装</h4><p>第一种方式：</p><p>在本地机器执行，make install，在 <code>config/crd/bases</code> 目录生成 crd.yaml，拷贝至 k8s 集群机器，执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f extensions.chinaunicom.cn_uniteddeployments.yaml</span></span><br></pre></td></tr></table></figure><p>第二种方式:<br>将代码拷贝至k8s集群机器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make install    // 先生成 config/crd/bases 文件，里面包含 crd 的YAML文件，然后kubectl apply</span></span><br></pre></td></tr></table></figure><p>然后我们就可以看到创建的 CRD 了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get crd |grep united</span></span><br><span class="line">uniteddeployments.extensions.chinaunicom.cn           2023-09-05T02:15:40Z</span><br></pre></td></tr></table></figure><p>创建一个 uniteddeployment 资源</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> kubebuilder-project/config/samples</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f extensions_v1_uniteddeployment.yaml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get uniteddeployments.extensions.chinaunicom.cn</span></span><br><span class="line">NAME                      AGE</span><br><span class="line">uniteddeployment-sample   103s</span><br></pre></td></tr></table></figure><p>看一眼 yaml 文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，通过使用 kubebuilder 与 code-generator 一个完整的 operator 开发框架就搭建好了，剩下的工作就主要是写 controller 与webhook 的业务逻辑。 </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p>kuberbuilder: <a href="https://github.com/kubernetes-sigs/kubebuilder/tree/v3.11.1">https://github.com/kubernetes-sigs/kubebuilder/tree/v3.11.1</a></p></li><li><p>code-generator: <a href="https://github.com/kubernetes/code-generator/tree/v0.28.0">https://github.com/kubernetes/code-generator/tree/v0.28.0</a></p></li><li><p>sample-controller: <a href="https://github.com/kubernetes/sample-controller/tree/v0.28.0">https://github.com/kubernetes/sample-controller/tree/v0.28.0</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kubebuilder-介绍&quot;&gt;&lt;a href=&quot;#Kubebuilder-介绍&quot; class=&quot;headerlink&quot; title=&quot;Kubebuilder 介绍&quot;&gt;&lt;/a&gt;Kubebuilder 介绍&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://githu</summary>
      
    
    
    
    <category term="operator" scheme="http://lizhewei91.github.io/categories/operator/"/>
    
    
    <category term="operator" scheme="http://lizhewei91.github.io/tags/operator/"/>
    
    <category term="code-generator" scheme="http://lizhewei91.github.io/tags/code-generator/"/>
    
    <category term="kubebuilder" scheme="http://lizhewei91.github.io/tags/kubebuilder/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 k8s-admission-webhook</title>
    <link href="http://lizhewei91.github.io/2023/08/29/15/"/>
    <id>http://lizhewei91.github.io/2023/08/29/15/</id>
    <published>2023-08-29T07:13:15.000Z</published>
    <updated>2023-08-29T09:13:53.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Admission-Webhook"><a href="#Admission-Webhook" class="headerlink" title="Admission Webhook"></a>Admission Webhook</h1><p>Admission Webhook 是一种用于接收准入请求并对其进行处理的 HTTP 回调机制。其实就是通过 Webhook 来实现准入控制，分为两种：验证性质的准入 Webhook （<a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook">Validating Admission Webhook</a>） 和 修改性质的准入 Webhook （<a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook">Mutating Admission Webhook</a>）。</p><p>admission webhook 的执行流程，如下图：</p><img src="/2023/08/29/15/v2-0eaa9f408acd640e0d6f4af7aa8be5ba_1440w.png" class="" title="img"><p>从图中可以看到，变更性质的 Mutating Webhook 会先被调用，它们可以修改发送到 API 服务器的对象以执行自定义的设置默认值操作。在完成了所有对象修改并且 API 服务器也验证了所传入的对象之后， 验证性质的 Validating Webhook 会被调用，并通过拒绝请求的方式来强制实施自定义的策略。</p><blockquote><p>Mutating Admission Webhook 是串行执行，Validating Admission Webhook是并行执行</p></blockquote><p>Admission Webhook 有哪些使用场景？如下</p><ul><li>在资源持久化到 ETCD 之前进行<strong>修改</strong>（Mutating Webhook），比如增加 init Container或者 sidecar Container</li><li>在资源持久化到 ETCD 之前进行<strong>校验</strong>（Validating Webhook），不满足条件的资源直接拒绝并给出相应信息</li></ul><p>现在非常火热的的 Service Mesh 应用 istio 就是通过 mutating webhooks 来自动将 Envoy 这个 sidecar 容器注入到 Pod 中去的：</p><p><a href="https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/">https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/</a></p><p>更多详情介绍可参考：<a href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/">https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/</a></p><h1 id="创建配置一个-Admission-Webhook"><a href="#创建配置一个-Admission-Webhook" class="headerlink" title="创建配置一个 Admission Webhook"></a>创建配置一个 Admission Webhook</h1><p>上面我们介绍了 Admission Webhook 的理论知识，接下来我们在一个真实的 Kubernetes 集群中来实际测试使用下，我们将创建一个 webhook 的 webserver，将其部署到集群中，然后创建 webhook 配置查看是否生效。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a><strong>先决条件</strong></h2><p>一个 Kubernetes 当然是必须的，你可以通过二进制或者 Kubeadm 来快速搭建集群，或者使用云服务厂商托管的集群都可以。（1.9版本以上）</p><p>然后确保在 apiserver 中启用了 MutatingAdmissionWebhook和 ValidatingAdmissionWebhook这两个控制器，通过运行下面的命令检查集群中是否启用了准入注册 API：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> kubectl api<span class="literal">-versions</span> |grep admission </span><br><span class="line">admissionregistration.k8s.io/v1</span><br></pre></td></tr></table></figure><p>如果没有开启，修改kube-apiserver参数 <code>--enable-admission-plugins</code>，并重启 kube-apiserver。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">--enable-admission-plugins=MutatingAdmissionWebhook,ValidatingAdmissionWebhook</span><br></pre></td></tr></table></figure><h2 id="编写-webhook"><a href="#编写-webhook" class="headerlink" title="编写 webhook"></a>编写 webhook</h2><p>我们基于上次 crd-controller 的基础上，以一个简单的 Webhook 作为例子，该 Webhook 会在创建 Deployment 资源的时候检查它是否有相应的标签，如果没有的话，则加上（Mutating Webhook），然后在检验它是否有相应的标签（Validating Webhook），有则创建该 Deployment，否则拒绝并给出相应错误提示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Admission-Webhook&quot;&gt;&lt;a href=&quot;#Admission-Webhook&quot; class=&quot;headerlink&quot; title=&quot;Admission Webhook&quot;&gt;&lt;/a&gt;Admission Webhook&lt;/h1&gt;&lt;p&gt;Admission </summary>
      
    
    
    
    <category term="webhook" scheme="http://lizhewei91.github.io/categories/webhook/"/>
    
    
    <category term="webhook" scheme="http://lizhewei91.github.io/tags/webhook/"/>
    
  </entry>
  
  <entry>
    <title>使用swagger-ui可视化Kubernetes-API文档</title>
    <link href="http://lizhewei91.github.io/2023/08/25/41/"/>
    <id>http://lizhewei91.github.io/2023/08/25/41/</id>
    <published>2023-08-25T01:48:41.000Z</published>
    <updated>2023-08-25T01:55:58.405Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中，你可能需要基于 Kubernetes 提供的 API 进行开发，比如开发适合自己的控制台，Kubernetes 官方提供的 API 文档，有两个问题：</p><ol><li>非常的不直观，这个问题其实还好，自己克服一下也不是大问题</li><li>只有 K8S api-server 的接口，这个就难办了，假如有新的 CRD 资源，比如 kubevirt ，又要去找 kubevirt 的 api 文档，关键是找不着</li></ol><h2 id="如何部署-swagger-ui"><a href="#如何部署-swagger-ui" class="headerlink" title="如何部署 swagger-ui"></a>如何部署 swagger-ui</h2><p>打开两个 ssh 连接到你的 K8S 集群中。</p><p>进入第一个窗口，执行如下命令建立一个反向代理</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl proxy --port=8080</span><br></pre></td></tr></table></figure><p>进入第二个窗口，执行如下命令建立获取 k8s的 api 文档信息，输出到一个 <code>k8s-swagger.json</code> 文件中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl localhost:8080/openapi/v2 &gt; k8s-swagger.json</span><br></pre></td></tr></table></figure><p>获取到后，第一个窗口就可以关闭了。</p><p>然后任选一个窗口，执行如下命令运行一个容器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    --rm \</span><br><span class="line">    -d \</span><br><span class="line">    -p 80:8080 \</span><br><span class="line">    -e SWAGGER_JSON=/k8s-swagger.json \</span><br><span class="line">    -v $(pwd)/k8s-swagger.json:/k8s-swagger.json \</span><br><span class="line">    swaggerapi/swagger-ui</span><br></pre></td></tr></table></figure><h2 id="使用-swagger-ui"><a href="#使用-swagger-ui" class="headerlink" title="使用 swagger-ui"></a>使用 swagger-ui</h2><p>此时，你在浏览器上输入 <code>http://ip</code> 就可以看到一个经过可视化的 api 文档界面，其中包括安装在集群上的所有自定义资源的模型和路径！</p><img src="/2023/08/25/41/50a5136b19764f23861be47fcaf4758d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" class="" title="img"><p>里面的 api 非常多，你用得上的，用不上的，这里都有。 不仅有 api-server 的 API ，其他所有你另外安装的 CRD 资源也都有。</p><p>比如我自己安装的 VirtualMachineInstance 资源，根据关键字，立马就找到 KubeVirt 创建虚拟机的 API</p><img src="/2023/08/25/41/c1ea7c9fa54f4ba785dec6ab083dff1d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" class="" title="img"><p>点击上面的 <code>Try it out</code> 可以修改请求体的参数，请生成一个 curl 命令，方便你进行调试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在工作中，你可能需要基于 Kubernetes 提供的 API 进行开发，比如开发适合自己的控制台，Kubernetes 官方提供的 API 文档，有两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非常的不直观，这个问题其实还好，自己克服一下也不是大问题&lt;/li&gt;
&lt;li&gt;只有 K8</summary>
      
    
    
    
    <category term="k8s-swagger-ui" scheme="http://lizhewei91.github.io/categories/k8s-swagger-ui/"/>
    
    
    <category term="k8s-swagger-ui" scheme="http://lizhewei91.github.io/tags/k8s-swagger-ui/"/>
    
  </entry>
  
  <entry>
    <title>Gin实战-使用JWT认证</title>
    <link href="http://lizhewei91.github.io/2023/07/25/13/"/>
    <id>http://lizhewei91.github.io/2023/07/25/13/</id>
    <published>2023-07-25T11:18:13.000Z</published>
    <updated>2023-07-25T11:24:08.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-JWT"><a href="#什么是-JWT" class="headerlink" title="什么是 JWT?"></a>什么是 JWT?</h1><p>JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种Token 实现方式，目前多用于前后端分离项目和 OAuth2.0 业务场景下。</p><h1 id="为什么需要JWT？"><a href="#为什么需要JWT？" class="headerlink" title="为什么需要JWT？"></a>为什么需要JWT？</h1><p>在之前的一些web项目中，我们通常使用的是<code>Cookie-Session</code>模式实现用户认证。相关流程大致如下：</p><ol><li>用户在浏览器端填写用户名和密码，并发送给服务端</li><li>服务端对用户名和密码校验通过后会生成一份保存当前用户相关信息的session数据和一个与之对应的标识（通常称为session_id）</li><li>服务端返回响应时将上一步的session_id写入用户浏览器的Cookie</li><li>后续用户来自该浏览器的每次请求都会自动携带包含session_id的Cookie</li><li>服务端通过请求中的session_id就能找到之前保存的该用户那份session数据，从而获取该用户的相关信息。</li></ol><p>这种方案依赖于客户端（浏览器）保存 Cookie，并且需要在服务端存储用户的session数据。</p><p>在移动互联网时代，我们的用户可能使用浏览器也可能使用APP来访问我们的服务，我们的web应用可能是前后端分开部署在不同的端口，有时候我们还需要支持第三方登录，这下<code>Cookie-Session</code>的模式就有些力不从心了。</p><p>JWT就是一种基于Token的轻量级认证模式，服务端认证通过后，会生成一个JSON对象，经过签名后得到一个Token（令牌）再发回给用户，用户后续请求只需要带上这个Token，服务端解密之后就能获取该用户的相关信息了。</p><p>想要了解JWT的原理，推荐大家阅读：<a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">阮一峰的JWT入门教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是-JWT&quot;&gt;&lt;a href=&quot;#什么是-JWT&quot; class=&quot;headerlink&quot; title=&quot;什么是 JWT?&quot;&gt;&lt;/a&gt;什么是 JWT?&lt;/h1&gt;&lt;p&gt;JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种T</summary>
      
    
    
    
    <category term="gin" scheme="http://lizhewei91.github.io/categories/gin/"/>
    
    
    <category term="gin" scheme="http://lizhewei91.github.io/tags/gin/"/>
    
    <category term="jwt" scheme="http://lizhewei91.github.io/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>Gin实战-中间件开发</title>
    <link href="http://lizhewei91.github.io/2023/07/25/55/"/>
    <id>http://lizhewei91.github.io/2023/07/25/55/</id>
    <published>2023-07-25T03:08:55.000Z</published>
    <updated>2023-07-25T10:53:06.475Z</updated>
    
    <content type="html"><![CDATA[<p>在 Gin 的整个实现中，中间件可谓是 Gin 的精髓。一个个中间件组成一条中间件链，对 HTTP Request 请求进行拦截处理，实现了代码的解耦和分离，并且中间件之间相互不用感知到，每个中间件只需要处理自己需要处理的事情即可。今天我们就通过这篇文章，详细的介绍Gin 中间的使用和原理。</p><h1 id="Gin-默认中间件"><a href="#Gin-默认中间件" class="headerlink" title="Gin 默认中间件"></a>Gin 默认中间件</h1><p>在 Gin 中，我们可以通过 Gin 提供的默认函数，来构建一个自带默认中间件的 <code>*Engine</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := gin.Default()</span><br></pre></td></tr></table></figure><p>Default 函数会默认绑定两个已经准备好的中间件，它们就是 <code>Logger</code> 和 <code>Recovery</code>，帮助我们打印日志输出和painc处理。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Default</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line">    debugPrintWARNINGDefault()</span><br><span class="line">    engine := New()</span><br><span class="line">    engine.Use(Logger(), Recovery())</span><br><span class="line">    <span class="keyword">return</span> engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中我们可以看到，Gin 的中间件是通过 <code>Use</code> 方法设置的，它接收一个可变参数，所以我们同时可以设置多个中间件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Use(middleware ...HandlerFunc) IRoutes</span><br></pre></td></tr></table></figure><p>到了这里其实我们应该更加明白了，一个 Gin 的中间件，其实就是 Gin 定义的一个 <code>HandlerFunc</code> ,而它在我们 Gin 中经常使用，比如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;首页&quot;</span>)</span><br><span class="line">        c.JSON(<span class="number">200</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>后面的 <code>func(c *gin.Context)</code> 这部分其实就是一个 <code>HandlerFunc</code>。</p><blockquote><p>如果我们想创建一个没有任何中件的 router 可以通过 New 方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router := gin.New()</span><br></pre></td></tr></table></figure></blockquote><h1 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h1><p>我们已经知道，Gin 的中间件其实就是一个 <code>HandlerFunc</code>,那么只要我们自己实现一个 <code>HandlerFunc</code>，就可以自定义一个自己的中间件。现在我们以统计每次请求的执行时间为例，来演示如何自定义一个中间件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">costTime</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">//请求前获取当前时间</span></span><br><span class="line">        nowTime := time.Now()</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//请求处理</span></span><br><span class="line">        c.Next()</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//处理后获取消耗时间</span></span><br><span class="line">        costTime := time.Since(nowTime)</span><br><span class="line">        url := c.Request.URL.String()</span><br><span class="line">        fmt.Printf(<span class="string">&quot;the request URL %s cost %v\n&quot;</span>, url, costTime)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上我们就实现了一个 Gin 中间件，比较简单，而且有注释加以说明，这里要注意的是 <code>c.Next</code>方法，这个是执行后续中间件请求处理的意思（含没有执行的中间件和我们定义的 GET 方法处理），这样我们才能获取执行的耗时。也就是在 <code>c.Next</code> 方法前后分别记录时间，就可以得出耗时。</p><p>有了自定义的中间件，我们就可以这么使用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.New()</span><br><span class="line"> </span><br><span class="line">    r.Use(costTime())</span><br><span class="line"> </span><br><span class="line">    r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在启动程序，在浏览器里打开就可以看到如下日志信息了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the request URL / cost 27.272µs</span><br></pre></td></tr></table></figure><p>通过自定义中间件,我们可以很方便的拦截请求，来做一些我们需要做的事情，比如日志记录、授权校验、各种过滤等等。</p><h1 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h1><p>在gin框架中，我们可以为每个路由添加任意数量的中间件。</p><h2 id="全局路由注册"><a href="#全局路由注册" class="headerlink" title="全局路由注册"></a>全局路由注册</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个全局中间件</span></span><br><span class="line">r.Use(costTime())</span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单个路由注册"><a href="#单个路由注册" class="headerlink" title="单个路由注册"></a>单个路由注册</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为单个路由注册中间件</span></span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, costTime(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为路由组注册"><a href="#为路由组注册" class="headerlink" title="为路由组注册"></a>为路由组注册</h2><p>路由组注册中间件，有两种写法：</p><p>第1种：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个路由组</span></span><br><span class="line">adminGroup := r.Group(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line"><span class="comment">// 为单个路由注册</span></span><br><span class="line">adminGroup.Use(costTime())</span><br><span class="line"></span><br><span class="line">adminGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第2种：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个路由组, 并注册中间件</span></span><br><span class="line">adminGroup := r.Group(<span class="string">&quot;admin&quot;</span>,costTime())</span><br><span class="line"></span><br><span class="line">adminGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="中间件嵌套"><a href="#中间件嵌套" class="headerlink" title="中间件嵌套"></a>中间件嵌套</h1><h2 id="Next"><a href="#Next" class="headerlink" title="Next()"></a>Next()</h2><p>表示跳过当前中间件剩余内容， 去执行下一个中间件。 当所有操作执行完之后，以出栈的执行顺序返回，执行剩余代码。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 in&quot;</span>)</span><br><span class="line">c.Next()</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m2</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 in&quot;</span>)</span><br><span class="line">c.Next()</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个路由注册</span></span><br><span class="line">r.Use(m1(), m2())</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在启动程序，可以看到如下日志信息了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m1 in</span><br><span class="line">m2 in</span><br><span class="line">index</span><br><span class="line">m2 out</span><br><span class="line">m1 out</span><br></pre></td></tr></table></figure><img src="/2023/07/25/55/1739642-20211130215426762-1421068920.png" class="" title="img"><img src="/2023/07/25/55/1739642-20211130215427700-1850689813.png" class="" title="img"><h2 id="Abort"><a href="#Abort" class="headerlink" title="Abort()"></a>Abort()</h2><p>只执行当前中间件， 操作完成后，以出栈的顺序，依次返回上一级中间件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 in&quot;</span>)</span><br><span class="line">    </span><br><span class="line">c.Next()</span><br><span class="line">    </span><br><span class="line">fmt.Println(<span class="string">&quot;m1 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m2</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 in&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 阻止调用后续处理的函数</span></span><br><span class="line">c.Abort()</span><br><span class="line">    </span><br><span class="line">fmt.Println(<span class="string">&quot;m2 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个路由注册</span></span><br><span class="line">r.Use(m1(), m2())</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/07/25/55/image-20230725150624326.png" class="" title="image-20230725150624326"><img src="/2023/07/25/55/image-20230725150813400.png" class="" title="image-20230725150813400"><img src="/2023/07/25/55/1739642-20211130215430060-1290778100.png" class="" title="img"><h2 id="Return"><a href="#Return" class="headerlink" title="Return"></a>Return</h2><p>终止执行当前中间件剩余内容，执行下一个中间件。 当所有的函数执行结束后，以出栈的顺序执行返回，但，不执行return后的代码。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 in&quot;</span>)</span><br><span class="line">c.Next()</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m2</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 in&quot;</span>)</span><br><span class="line">    c.Abort()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">fmt.Println(<span class="string">&quot;m2 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个路由注册</span></span><br><span class="line">r.Use(m1(), m2())</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/07/25/55/image-20230725152525473.png" class="" title="image-20230725152525473"><img src="/2023/07/25/55/image-20230725152621062.png" class="" title="image-20230725152621062"><img src="/2023/07/25/55/1739642-20211130215431079-414872280.png" class="" title="img"><h1 id="中间件取值"><a href="#中间件取值" class="headerlink" title="中间件取值"></a>中间件取值</h1><p>使用 <code>c.Set() </code>在中间件设定自定义值，<code>c.Get() </code>从中间件获取值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 in&quot;</span>)</span><br><span class="line"><span class="comment">// 在上下文中设置自定义值</span></span><br><span class="line">c.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lzw&quot;</span>)</span><br><span class="line">c.Next()</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m2</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 in&quot;</span>)</span><br><span class="line"><span class="comment">// 在上下文中设置自定义值</span></span><br><span class="line">c.Set(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">c.Next()</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">r := gin.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个路由注册</span></span><br><span class="line">r.Use(m1(), m2())</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 从中间件获取name值</span></span><br><span class="line">name, _ := c.Get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;从m1中获取name值，name: %v\n&quot;</span>, name)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 从中间件获取age值</span></span><br><span class="line">age, _ := c.Get(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;从m2中获取age值，age: %v\n&quot;</span>, age)</span><br><span class="line">    </span><br><span class="line">c.JSON(<span class="number">200</span>, <span class="string">&quot;首页&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/07/25/55/image-20230725153335739.png" class="" title="image-20230725153335739"><img src="/2023/07/25/55/image-20230725153347337.png" class="" title="image-20230725153347337"><h1 id="中间件注意事项"><a href="#中间件注意事项" class="headerlink" title="中间件注意事项"></a>中间件注意事项</h1><h2 id="gin默认中间件"><a href="#gin默认中间件" class="headerlink" title="gin默认中间件"></a>gin默认中间件</h2><p><code>gin.Default()</code>默认使用了<code>Logger</code>和<code>Recovery</code>中间件，其中：</p><ul><li><code>Logger</code>中间件将日志写入<code>gin.DefaultWriter</code>，即使配置了<code>GIN_MODE=release</code>。</li><li><code>Recovery</code>中间件会recover任何<code>panic</code>。如果有panic的话，会写入500响应码。</li></ul><p>如果不想使用上面两个默认的中间件，可以使用<code>gin.New()</code>新建一个没有任何默认中间件的路由。</p><h2 id="gin中间件中使用goroutine"><a href="#gin中间件中使用goroutine" class="headerlink" title="gin中间件中使用goroutine"></a>gin中间件中使用goroutine</h2><p>当在中间件或<code>handler</code>中启动新的<code>goroutine</code>时，<strong>不能使用</strong>原始的上下文（c *gin.Context），必须使用其只读副本（<code>c.Copy()</code>）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Gin 的整个实现中，中间件可谓是 Gin 的精髓。一个个中间件组成一条中间件链，对 HTTP Request 请求进行拦截处理，实现了代码的解耦和分离，并且中间件之间相互不用感知到，每个中间件只需要处理自己需要处理的事情即可。今天我们就通过这篇文章，详细的介绍Gin </summary>
      
    
    
    
    <category term="gin" scheme="http://lizhewei91.github.io/categories/gin/"/>
    
    
    <category term="gin" scheme="http://lizhewei91.github.io/tags/gin/"/>
    
    <category term="中间件" scheme="http://lizhewei91.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>从零到1开发一个operator</title>
    <link href="http://lizhewei91.github.io/2023/07/21/00/"/>
    <id>http://lizhewei91.github.io/2023/07/21/00/</id>
    <published>2023-07-21T07:28:00.000Z</published>
    <updated>2023-09-08T06:15:03.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-operator-？"><a href="#什么是-operator-？" class="headerlink" title="什么是 operator ？"></a>什么是 operator ？</h1><p>operator 是一种 kubernetes 的扩展形式，利用自定义资源对象（Custom Resource）来管理应用和组件，允许用户以 Kubernetes 的声明式 API 风格来管理应用及服务。</p><blockquote><p>Operator = CRD + Controller + Webhook</p></blockquote><h2 id="常见的-operator-工作模式"><a href="#常见的-operator-工作模式" class="headerlink" title="常见的 operator 工作模式"></a><strong>常见的 operator 工作模式</strong></h2><img src="/2023/07/21/00/v2-6230f52f3d85039ca62f72c42314dab9_1440w-20230908141337037.webp" class="" title="img"><p>工作流程：</p><ol><li><p>用户创建一个自定义资源 (CRD)；</p></li><li><p>apiserver 根据自己注册的一个 pass 列表，把该 CRD 的请求转发给 webhook；</p></li><li><p>webhook 一般会完成该 CRD 的缺省值设定和参数检验。webhook 处理完之后，相应的 CR 会被写入数据库，返回给用户；</p></li><li><p>与此同时，controller 会在后台监测该自定义资源，按照业务逻辑，处理与该自定义资源相关联的特殊操作；</p></li><li><p>上述处理一般会引起集群内的状态变化，controller 会监测这些关联的变化，把这些变化记录到 CRD 的状态中。</p></li></ol><p>目前，构架 Operator 框架主要有两个工具 Kubebuilder 和 operator SDK，<strong>本文主要讲述如何不使用脚手架，从零到1开发一个自己的 Operator 应用</strong>。</p><p>先放一张 controller与informer交互的经典图</p><img src="/2023/07/21/00/client-go-controller-interaction.jpeg" class="" title="client-go-controller-interaction"><h1 id="code-generator"><a href="#code-generator" class="headerlink" title="code-generator"></a>code-generator</h1><p><code>k8s.io/client-go</code> 提供了对 k8s 原生资源的 informer 和 clientset 等等，但对于自定义资源的操作则相对低效，需要使用 rest api 和 dynamic client 来操作，并自己实现反序列化等功能。</p><p>code-generator 提供了以下工具用于为 k8s 中的资源生成相关代码，可以更加方便的操作自定义资源：</p><ul><li><p><code>deepcopy-gen</code>: 生成深度拷贝对象方法</p><p>使用方法：</p><ul><li>在文件中<code>pkg/apis/&lt;apigroup&gt;/&lt;version&gt;/doc.go</code>添加注释 <code>// +k8s:deepcopy-gen=package</code>，默认为该包中的每个类型创建deepcopy方法。</li><li>为单个类型添加自动生成<code>// +k8s:deepcopy-gen=true</code></li><li>为单个类型关闭自动生成<code>// +k8s:deepcopy-gen=false</code></li></ul></li><li><p><code>client-gen</code>: 为资源生成标准的操作方法(get;list;watch;create;update;patch;delete)</p><p>使用方法（在<code>pkg/apis/&lt;apigroup&gt;/&lt;version&gt;/types.go</code>中使用）：</p><ul><li><code>// +genclient</code> - 生成默认的客户端动作函数（create, update, delete, get, list, update, patch, watch以及 是否生成updateStatus取决于.Status字段是否存在）</li><li><code>// +genclient:nonNamespaced</code> - 所有动作函数都是在没有名称空间的情况下生成</li><li><code>// +genclient:onlyVerbs=create,get</code> - 指定的动作函数被生成.</li><li><code>// +genclient:skipVerbs=watch</code> - 生成 watch 以外所有的动作函数.</li><li><code>// +genclient:noStatus</code> - 即使<code>.Status</code>字段存在也不生成 updateStatus 动作函数</li></ul></li><li><p><code>informer-gen</code>: 生成 informer，提供事件机制 (AddFunc,UpdateFunc,DeleteFunc) 来响应 kubernetes 的 event</p></li><li><p><code>lister-gen</code>: 为get和list方法提供只读缓存层</p></li><li><p><code>conversion-gen</code>: 是用于自动生成在内部和外部类型之间转换的函数的工具</p><p>一般的转换代码生成任务涉及三套程序包：</p><ul><li>一套包含内部类型的程序包，</li><li>一套包含外部类型的程序包</li><li>单个目标程序包（即，生成的转换函数所在的位置，以及开发人员授权的转换功能所在的位置）。包含内部类型的包在Kubernetes的常规代码生成框架中扮演着称为<code>peer package</code>的角色。</li></ul><p>使用方法：</p><ul><li>标记转换内部软件包 <code>// +k8s:conversion-gen=&lt;import-path-of-internal-package&gt;</code></li><li>标记转换外部软件包<code>// +k8s:conversion-gen-external-types=&lt;import-path-of-external-package&gt;</code></li><li>标记不转换对应注释或结构 <code>// +k8s:conversion-gen=false</code></li></ul></li></ul><ul><li><p><code>defaulter-gen</code> 用于生产 Defaulter 函数</p><ul><li>为包含字段的所有类型创建 defaulters，<code>// +k8s:defaulter-gen=&lt;field-name-to-flag&gt;</code></li><li>所有都生成<code>// +k8s:defaulter-gen=true|false</code></li></ul></li><li><p><code>go-to-protobuf</code> 通过go struct生成pb idl</p></li><li><p><code>import-boss</code> 在给定存储库中强制执行导入限制</p></li><li><p><code>openapi-gen</code> 生成openAPI定义</p><p>使用方法：</p><ul><li><code>+k8s:openapi-gen=true</code> 为指定包或方法开启</li><li><code>+k8s:openapi-gen=false</code> 指定包关闭</li></ul></li><li><p><code>register-gen</code> 生成register</p></li><li><p><code>set-gen</code></p></li></ul><p>code-generator 整合了这些 gen，使用脚本 <code>generate-groups.sh</code> 和 <code>generate-internal-groups.sh</code> 可以为自定义资源生产相关代码。</p><h1 id="项目设计"><a href="#项目设计" class="headerlink" title="项目设计"></a>项目设计</h1><p>有了使用 code-generator 的基础，接下来，我们开始一起开发一个简单的 operator 应用，用来控制 deployment 的 replicas 的数量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: extension.k8s.io/v1</span><br><span class="line">kind: UnitedDeployment</span><br><span class="line">metadata:</span><br><span class="line">  name: example-united-deployment</span><br><span class="line">spec:</span><br><span class="line">  deploymentName: example-deployment</span><br><span class="line">  replicas: 2</span><br></pre></td></tr></table></figure><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><h2 id="创建一个项目（crd-controller）"><a href="#创建一个项目（crd-controller）" class="headerlink" title="创建一个项目（crd-controller）"></a>创建一个项目（crd-controller）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost crd-controller]# tree</span><br><span class="line">.</span><br><span class="line">|-- Dockerfile</span><br><span class="line">|-- README.md</span><br><span class="line">|-- go.mod</span><br><span class="line">|-- go.sum</span><br><span class="line">|-- main.go</span><br><span class="line">`-- pkg</span><br><span class="line">    |-- apis</span><br><span class="line">    |   `-- extension</span><br><span class="line">    |       |-- register.go</span><br><span class="line">    |       `-- v1</span><br><span class="line">    |           |-- doc.go</span><br><span class="line">    |           |-- register.go</span><br><span class="line">    |           `-- types.go</span><br><span class="line">    `-- generated</span><br></pre></td></tr></table></figure><p>在 pkg/apis/extension/v1目录创建 doc.go、register.go、types.go。首先，先在 types.go 文件定义我们要创建的 crd 字段。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">metav1 <span class="string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnitedDeployment is a specification for a UnitedDeployment resource</span></span><br><span class="line"><span class="keyword">type</span> UnitedDeployment <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta   <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line">metav1.ObjectMeta <span class="string">`json:&quot;objectMeta,omitempty&quot;`</span></span><br><span class="line">Spec              UnitedDeploymentSpec   <span class="string">`json:&quot;spec&quot;`</span></span><br><span class="line">Status            UnitedDeploymentStatus <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnitedDeploymentSpec is the spec for a UnitedDeployment resource</span></span><br><span class="line"><span class="keyword">type</span> UnitedDeploymentSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">DeploymentName <span class="type">string</span> <span class="string">`json:&quot;deploymentName&quot;`</span></span><br><span class="line">Replicas       *<span class="type">int32</span> <span class="string">`json:&quot;replicas&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnitedDeploymentStatus is the status for a UnitedDeployment resource</span></span><br><span class="line"><span class="keyword">type</span> UnitedDeploymentStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">AvailableReplicas *<span class="type">int32</span> <span class="string">`json:&quot;availableReplicas&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnitedDeploymentList is a list of UnitedDeployment resources</span></span><br><span class="line"><span class="keyword">type</span> UnitedDeploymentList <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line">metav1.ListMeta <span class="string">`json:&quot;metadata,omitempty&quot;`</span></span><br><span class="line">Items           []UnitedDeployment <span class="string">`json:&quot;items&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在 register.go 文件中，增加以下代码，向全局 Scheme 注册自定义类型<code>UnitedDeployment</code>和<code>UnitedDeploymentList</code></p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">metav1 <span class="string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span></span><br><span class="line"><span class="string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span></span><br><span class="line"><span class="string">&quot;k8s.io/apimachinery/pkg/runtime/schema&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;crd-controller/pkg/apis/extension&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SchemeGroupVersion is group version used to register these objects</span></span><br><span class="line"><span class="keyword">var</span> SchemeGroupVersion = schema.GroupVersion&#123;Group: extension.GroupName, Version: <span class="string">&quot;v1&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kind takes an unqualified kind and returns back a Group qualified GroupKind</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Kind</span><span class="params">(kind <span class="type">string</span>)</span></span> schema.GroupKind &#123;</span><br><span class="line"><span class="keyword">return</span> SchemeGroupVersion.WithKind(kind).GroupKind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resource takes an unqualified resource and returns a Group qualified GroupResource</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Resource</span><span class="params">(resource <span class="type">string</span>)</span></span> schema.GroupResource &#123;</span><br><span class="line"><span class="keyword">return</span> SchemeGroupVersion.WithResource(resource).GroupResource()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// SchemeBuilder initializes a scheme builder</span></span><br><span class="line">SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)</span><br><span class="line"><span class="comment">// AddToScheme is a global function that registers this API group &amp; version to a scheme</span></span><br><span class="line">AddToScheme = SchemeBuilder.AddToScheme</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adds the list of known types to Scheme.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addKnownTypes</span><span class="params">(scheme *runtime.Scheme)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">scheme.AddKnownTypes(SchemeGroupVersion,</span><br><span class="line">&amp;UnitedDeployment&#123;&#125;,</span><br><span class="line">&amp;UnitedDeploymentList&#123;&#125;,</span><br><span class="line">)</span><br><span class="line">metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doc.go 文件，后续code-generator标识全局标记使用，目前为空。</p><p>pkg/apis/extension/register.go 中，GroupName表示group组的名称</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extension</span><br><span class="line"></span><br><span class="line"><span class="comment">// GroupName is the group name used in this package</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">GroupName = <span class="string">&quot;extension.k8s.io&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="使用-code-generator"><a href="#使用-code-generator" class="headerlink" title="使用 code-generator"></a>使用 code-generator</h2><p>创建好项目后，接下来就需要使用 code-generator 为自定义的 crd 资源，生成 deepcopy、clientSet、informer、lister 代码。</p><h3 id="更新依赖版本"><a href="#更新依赖版本" class="headerlink" title="更新依赖版本"></a>更新依赖版本</h3><p>k8s.io/apimachinery库、k8s.io/client-go库、code-generator版本需要保持一致。</p><p>需要将初始化的k8s库更新到要使用的版本，如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost crd-controller# K8S_VERSION=v0.28.0</span><br><span class="line">[root@localhost crd-controller]# go get k8s.io/client-go@$K8S_VERSION</span><br><span class="line">[root@localhost crd-controller]# go get k8s.io/apimachinery@$K8S_VERSION</span><br></pre></td></tr></table></figure><p>更新后的 go.mod</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost crd-controller]# cat go.mod</span><br><span class="line">module crd-controller</span><br><span class="line"></span><br><span class="line">go 1.19</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">k8s.io/apimachinery v0.28.0</span><br><span class="line">k8s.io/client-go v0.28.0</span><br><span class="line">k8s.io/klog/v2 v2.100.1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="安装-code-generator"><a href="#安装-code-generator" class="headerlink" title="安装 code-generator"></a>安装 code-generator</h3><p>拷贝 <a href="https://github.com/kubernetes/sample-controller">sample-controller</a> 项目 ./hack 目录下的文件到项目目录下</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@localhost crd-controller]# tree</span><br><span class="line">.</span><br><span class="line">|-- Dockerfile</span><br><span class="line">|-- README.md</span><br><span class="line">|-- go.mod</span><br><span class="line">|-- go.sum</span><br><span class="line">|-- hack</span><br><span class="line">|   |-- boilerplate.go.txt</span><br><span class="line">|   |-- custom-boilerplate.go.txt</span><br><span class="line">|   |-- tools.go</span><br><span class="line">|   |-- update-codegen.sh</span><br><span class="line">|   `-- verify-codegen.sh</span><br><span class="line">|-- main.go</span><br><span class="line">`-- pkg</span><br><span class="line">    |-- apis</span><br><span class="line">    |   `-- extension</span><br><span class="line">    |       |-- register.go</span><br><span class="line">    |       `-- v1</span><br><span class="line">    |           |-- doc.go</span><br><span class="line">    |           |-- register.go</span><br><span class="line">    |           `-- types.go</span><br><span class="line">    `-- generated</span><br></pre></td></tr></table></figure><p>k8s的版本号与 <code>go.mod</code> 中的 <code>k8s.io/client-go</code> 的版本保持一致即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost crd-controller]# go get k8s.io/code-generator@$K8S_VERSION</span><br><span class="line">[root@localhost crd-controller]# go mod vendor</span><br></pre></td></tr></table></figure><h3 id="增加-code-generator-tag"><a href="#增加-code-generator-tag" class="headerlink" title="增加 code-generator tag"></a>增加 code-generator tag</h3><p>在 pkg/apis/extension/v1/doc.go文件增加 global tag，<code>+k8s:deepcopy-gen=package</code>：这个注释告诉 Kubernetes 的代码生成工具 <code>deepcopy-gen</code>为这个package下的所有types类型生成deepcopy代码，<code>+groupName=extension.k8s.io</code>：这个注释定义了 Kubernetes 扩展 API 的组名（group name)。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +k8s:deepcopy-gen=package</span></span><br><span class="line"><span class="comment">// +groupName=extension.k8s.io</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package v1 is the v1 version of the API.</span></span><br><span class="line"><span class="keyword">package</span> v1</span><br></pre></td></tr></table></figure><p>在 pkg/apis/extension/v1/types.go 文件分别为<code>UnitedDeployment</code>和<code>UnitedDeploymentList</code>增加 tag，<code>+genclient</code>：这个注释告诉 Kubernetes 代码生成工具生成客户端代码，<code>+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</code>：这个注释告诉 Kubernetes 的代码生成工具生成深拷贝（deep copy）相关的代码，以便确保在操作自定义资源对象时不会影响原始对象。<code>k8s.io/apimachinery/pkg/runtime.Object</code> 是 Kubernetes 中用于对象深拷贝的接口。通过这个注释，你告诉生成工具为你的自定义资源对象生成与深拷贝相关的代码。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +genclient</span></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UnitedDeployment is a specification for a UnitedDeployment resource</span></span><br><span class="line"><span class="keyword">type</span> UnitedDeployment <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta   <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line">metav1.ObjectMeta <span class="string">`json:&quot;objectMeta,omitempty&quot;`</span></span><br><span class="line">Spec              UnitedDeploymentSpec   <span class="string">`json:&quot;spec&quot;`</span></span><br><span class="line">Status            UnitedDeploymentStatus <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UnitedDeploymentList is a list of UnitedDeployment resources</span></span><br><span class="line"><span class="keyword">type</span> UnitedDeploymentList <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line">metav1.ListMeta <span class="string">`json:&quot;metadata,omitempty&quot;`</span></span><br><span class="line">Items           []UnitedDeployment <span class="string">`json:&quot;items&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行-update-codegen-sh"><a href="#执行-update-codegen-sh" class="headerlink" title="执行 update-codegen.sh"></a>执行 update-codegen.sh</h3><p>完成以上步骤，就可以执行 <code>./hack/update-codegen.sh</code>生成相关代码</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@localhost crd-controller]# tree</span><br><span class="line">.</span><br><span class="line">|-- Dockerfile</span><br><span class="line">|-- README.md</span><br><span class="line">|-- go.mod</span><br><span class="line">|-- go.sum</span><br><span class="line">|-- hack</span><br><span class="line">|   |-- boilerplate.go.txt</span><br><span class="line">|   |-- custom-boilerplate.go.txt</span><br><span class="line">|   |-- tools.go</span><br><span class="line">|   |-- update-codegen.sh</span><br><span class="line">|   `-- verify-codegen.sh</span><br><span class="line">|-- main.go</span><br><span class="line">`-- pkg</span><br><span class="line">    |-- apis</span><br><span class="line">    |   `-- extension</span><br><span class="line">    |       |-- register.go</span><br><span class="line">    |       `-- v1</span><br><span class="line">    |           |-- doc.go</span><br><span class="line">    |           |-- register.go</span><br><span class="line">    |           |-- types.go</span><br><span class="line">    |           `-- zz_generated.deepcopy.go</span><br><span class="line">    `-- generated</span><br><span class="line">        |-- clientset</span><br><span class="line">        |   `-- versioned</span><br><span class="line">        |       |-- clientset.go</span><br><span class="line">        |       |-- fake</span><br><span class="line">        |       |   |-- clientset_generated.go</span><br><span class="line">        |       |   |-- doc.go</span><br><span class="line">        |       |   `-- register.go</span><br><span class="line">        |       |-- scheme</span><br><span class="line">        |       |   |-- doc.go</span><br><span class="line">        |       |   `-- register.go</span><br><span class="line">        |       `-- typed</span><br><span class="line">        |           `-- extension</span><br><span class="line">        |               `-- v1</span><br><span class="line">        |                   |-- doc.go</span><br><span class="line">        |                   |-- extension_client.go</span><br><span class="line">        |                   |-- fake</span><br><span class="line">        |                   |   |-- doc.go</span><br><span class="line">        |                   |   |-- fake_extension_client.go</span><br><span class="line">        |                   |   `-- fake_uniteddeployment.go</span><br><span class="line">        |                   |-- generated_expansion.go</span><br><span class="line">        |                   `-- uniteddeployment.go</span><br><span class="line">        |-- informers</span><br><span class="line">        |   `-- externalversions</span><br><span class="line">        |       |-- extension</span><br><span class="line">        |       |   |-- interface.go</span><br><span class="line">        |       |   `-- v1</span><br><span class="line">        |       |       |-- interface.go</span><br><span class="line">        |       |       `-- uniteddeployment.go</span><br><span class="line">        |       |-- factory.go</span><br><span class="line">        |       |-- generic.go</span><br><span class="line">        |       `-- internalinterfaces</span><br><span class="line">        |           `-- factory_interfaces.go</span><br><span class="line">        `-- listers</span><br><span class="line">            `-- extension</span><br><span class="line">                `-- v1</span><br><span class="line">                    |-- expansion_generated.go</span><br><span class="line">                    `-- uniteddeployment.go</span><br></pre></td></tr></table></figure><h2 id="开发-controller"><a href="#开发-controller" class="headerlink" title="开发 controller"></a>开发 controller</h2><p>新建controller.go，增加custom_controller相关代码</p><p>定义 Controller 结构体</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 获取原生kind资源kubeclient</span></span><br><span class="line">kubeclientset          kubernetes.Interface</span><br><span class="line"><span class="comment">// 生成的crd客户端</span></span><br><span class="line">crdclientset           clientset.Interface</span><br><span class="line"><span class="comment">// deployment的lister</span></span><br><span class="line">deploymentlister       appslisters.DeploymentLister</span><br><span class="line"><span class="comment">// 判断deploymentInformer是否同步</span></span><br><span class="line">deploymentsynced       cache.InformerSynced</span><br><span class="line"><span class="comment">// unitedDeployment的lister</span></span><br><span class="line">uniteddeploymentlister listers.UnitedDeploymentLister</span><br><span class="line"><span class="comment">// 判断deploymentInformer是否同步</span></span><br><span class="line">uniteddeploymentsynced cache.InformerSynced</span><br><span class="line"><span class="comment">// 限速队列</span></span><br><span class="line">workqueue              workqueue.RateLimitingInterface</span><br><span class="line"><span class="comment">// recoder记录event事件</span></span><br><span class="line">recorder               record.EventRecorder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 controller 实例</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">ctx context.Context,</span></span></span><br><span class="line"><span class="params"><span class="function">kubeClientset kubernetes.Interface,</span></span></span><br><span class="line"><span class="params"><span class="function">crdClientset clientset.Interface,</span></span></span><br><span class="line"><span class="params"><span class="function">deploymentInformer appsinformers.DeploymentInformer,</span></span></span><br><span class="line"><span class="params"><span class="function">unitedDeploymentInformer informers.UnitedDeploymentInformer,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> *Controller &#123;</span><br><span class="line">logger := klog.FromContext(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 向全局scheme注册crd资源</span></span><br><span class="line">utilruntime.Must(crdscheme.AddToScheme(scheme.Scheme))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建recorder，记录event事件</span></span><br><span class="line">logger.V(<span class="number">4</span>).Info(<span class="string">&quot;Creating event broadcaster&quot;</span>)</span><br><span class="line">eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">eventBroadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">eventBroadcaster.StartRecordingToSink(&amp;typedcorev1.EventSinkImpl&#123;Interface: kubeClientset.CoreV1().Events(<span class="string">&quot;&quot;</span>)&#125;)</span><br><span class="line">recorder := eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource&#123;Component: controllerAgentName&#125;)</span><br><span class="line"></span><br><span class="line">controller := &amp;Controller&#123;</span><br><span class="line">kubeclientset:          kubeClientset,</span><br><span class="line">crdclientset:           crdClientset,</span><br><span class="line">deploymentlister:       deploymentInformer.Lister(),</span><br><span class="line">deploymentsynced:       deploymentInformer.Informer().HasSynced,</span><br><span class="line">uniteddeploymentlister: unitedDeploymentInformer.Lister(),</span><br><span class="line">uniteddeploymentsynced: unitedDeploymentInformer.Informer().HasSynced,</span><br><span class="line"><span class="comment">// 3.初始化workqueue</span></span><br><span class="line">workqueue: workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">&quot;unitedDeployment&quot;</span>),</span><br><span class="line">recorder:  recorder,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger.Info(<span class="string">&quot;Setting up event handlers&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 给unitedDeployment的 informer增加回调函数</span></span><br><span class="line">unitedDeploymentInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc: controller.enqueueUnitedDeployment,</span><br><span class="line">UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">controller.enqueueUnitedDeployment(<span class="built_in">new</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 给deployment的 informer增加回调函数</span></span><br><span class="line">deploymentInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc: controller.handleObject,</span><br><span class="line">UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">newDepl := <span class="built_in">new</span>.(*appsv1.Deployment)</span><br><span class="line">oldDepl := old.(*appsv1.Deployment)</span><br><span class="line"><span class="keyword">if</span> newDepl.ResourceVersion == oldDepl.ResourceVersion &#123;</span><br><span class="line"><span class="comment">// Periodic resync will send update events for all known Deployments.</span></span><br><span class="line"><span class="comment">// Two different versions of the same Deployment will always have different RVs.</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">controller.handleObject(<span class="built_in">new</span>)</span><br><span class="line">&#125;,</span><br><span class="line">DeleteFunc: controller.handleObject,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> controller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作队列 workqueue 入队方法</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> enqueueUnitedDeployment(obj <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line"><span class="keyword">var</span> key <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">if</span> key, err = cache.MetaNamespaceKeyFunc(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.workqueue.Add(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于deployment 触发的call back函数，进行逻辑判断，对于被unitedDeployment管理的deployment，进行入队操作，其他deployment忽略。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> handleObject(obj <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line"><span class="keyword">var</span> object metav1.Object</span><br><span class="line"><span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">logger := klog.FromContext(context.Background())</span><br><span class="line"><span class="keyword">if</span> object, ok = obj.(metav1.Object); !ok &#123;</span><br><span class="line">tombstone, ok := obj.(cache.DeletedFinalStateUnknown)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;error decoding object, invalid type&quot;</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">object, ok = tombstone.Obj.(metav1.Object)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;error decoding object tombstone, invalid type&quot;</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">logger.V(<span class="number">4</span>).Info(<span class="string">&quot;Recovered deleted object&quot;</span>, <span class="string">&quot;resourceName&quot;</span>, object.GetName())</span><br><span class="line">&#125;</span><br><span class="line">logger.V(<span class="number">4</span>).Info(<span class="string">&quot;Processing object&quot;</span>, <span class="string">&quot;object&quot;</span>, klog.KObj(object))</span><br><span class="line"><span class="keyword">if</span> ownerRef := metav1.GetControllerOf(object); ownerRef != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// If this object is not owned by a Foo, we should not do anything more</span></span><br><span class="line"><span class="comment">// with it.</span></span><br><span class="line"><span class="keyword">if</span> ownerRef.Kind != <span class="string">&quot;UnitedDeployment&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ud, err := c.uniteddeploymentlister.UnitedDeployments(object.GetNamespace()).Get(ownerRef.Name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.V(<span class="number">4</span>).Info(<span class="string">&quot;Ignore orphaned object&quot;</span>, <span class="string">&quot;object&quot;</span>, klog.KObj(object), <span class="string">&quot;foo&quot;</span>, ownerRef.Name)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.enqueueUnitedDeployment(ud)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 controller</p><p>开始运行 controller，controller 作为 workqueue 的消费者，从 workqueue 取出object.key，然后进行协调操作，直到达到 spec状态 与集群中 status状态 一致。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> Run(ctx context.Context, workers <span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"><span class="keyword">defer</span> c.workqueue.ShutDown()</span><br><span class="line">logger := klog.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">logger.Info(<span class="string">&quot;Starting unitedDeployment controller&quot;</span>)</span><br><span class="line"></span><br><span class="line">logger.Info(<span class="string">&quot;Waiting for informer caches to sync&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok := cache.WaitForCacheSync(ctx.Done(), c.deploymentsynced, c.uniteddeploymentsynced); !ok &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to wait for caches to sync&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger.Info(<span class="string">&quot;Starting workers&quot;</span>, <span class="string">&quot;count&quot;</span>, workers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> wait.UntilWithContext(ctx, c.runWorker, time.Second)</span><br><span class="line">&#125;</span><br><span class="line">logger.Info(<span class="string">&quot;Started workers&quot;</span>)</span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line">logger.Info(<span class="string">&quot;Shutting down workers&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> runWorker(ctx context.Context) &#123;</span><br><span class="line"><span class="keyword">for</span> c.processNextWorkItem(ctx) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span></span> processNextWorkItem(ctx context.Context) <span class="type">bool</span> &#123;</span><br><span class="line">obj, shutdown := c.workqueue.Get()</span><br><span class="line"><span class="keyword">if</span> shutdown &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err := <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO controller logic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>man函数作为项目入口，主要做以下几个内容：</p><p>1、创建 kubeclient 和 crdclient 客户端</p><p>2、创建 kubeInformerFactory、crdInformerFactory</p><p>3、创建controller实例</p><p>4、运行 kubeInformerFactory、crdInformerFactory</p><p>5、选主逻辑，高可用</p><p>6、运行controller</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">klog.InitFlags(<span class="literal">nil</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">ctx := signals.SetupSignalHandler()</span><br><span class="line">logger := klog.FromContext(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若需要，开启 pprof</span></span><br><span class="line"><span class="keyword">if</span> enablePprof &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(pprofAddr, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Error(err, <span class="string">&quot;unable to start pprof&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cfg, err := buildConfig(kubeconfig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err, <span class="string">&quot;Error building kubeconfig&quot;</span>)</span><br><span class="line">klog.FlushAndExit(klog.ExitFlushTimeout, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建kubeClient、crdClient客户端</span></span><br><span class="line">kubeClient, err := kubernetes.NewForConfig(cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err, <span class="string">&quot;Error building kubernetes clientset&quot;</span>)</span><br><span class="line">klog.FlushAndExit(klog.ExitFlushTimeout, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">crdClient, err := clientset.NewForConfig(cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err, <span class="string">&quot;Error building kubernetes clientset&quot;</span>)</span><br><span class="line">klog.FlushAndExit(klog.ExitFlushTimeout, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、创建 kubeInformerFactory、crdInformerFactory</span></span><br><span class="line">kubeInformerFactory := kubeinformers.NewSharedInformerFactory(kubeClient, time.Second*<span class="number">30</span>)</span><br><span class="line">crdInformerFactory := informers.NewSharedInformerFactory(crdClient, time.Second*<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、创建 controller 实例</span></span><br><span class="line">controller := controller.NewController(ctx, kubeClient, crdClient,</span><br><span class="line">kubeInformerFactory.Apps().V1().Deployments(),</span><br><span class="line">crdInformerFactory.Extension().V1().UnitedDeployments())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、运行 kubeInformerFactory、crdInformerFactory</span></span><br><span class="line">kubeInformerFactory.Start(ctx.Done())</span><br><span class="line">crdInformerFactory.Start(ctx.Done())</span><br><span class="line"></span><br><span class="line">lock := &amp;resourcelock.LeaseLock&#123;</span><br><span class="line">LeaseMeta: metav1.ObjectMeta&#123;</span><br><span class="line">Name:      leaseLockName,</span><br><span class="line">Namespace: leaseLockNamespace,</span><br><span class="line">&#125;,</span><br><span class="line">Client: kubeClient.CoordinationV1(),</span><br><span class="line">LockConfig: resourcelock.ResourceLockConfig&#123;</span><br><span class="line">Identity: leaseLockId,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、进行选主逻辑</span></span><br><span class="line">leaderelection.RunOrDie(ctx, leaderelection.LeaderElectionConfig&#123;</span><br><span class="line">Lock: lock,</span><br><span class="line"><span class="comment">// IMPORTANT: you MUST ensure that any code you have that</span></span><br><span class="line"><span class="comment">// is protected by the lease must terminate **before**</span></span><br><span class="line"><span class="comment">// you call cancel. Otherwise, you could have a background</span></span><br><span class="line"><span class="comment">// loop still running and another process could</span></span><br><span class="line"><span class="comment">// get elected before your background loop finished, violating</span></span><br><span class="line"><span class="comment">// the stated goal of the lease.</span></span><br><span class="line">ReleaseOnCancel: <span class="literal">true</span>,</span><br><span class="line">LeaseDuration:   <span class="number">60</span> * time.Second,</span><br><span class="line">RenewDeadline:   <span class="number">15</span> * time.Second,</span><br><span class="line">RetryPeriod:     <span class="number">5</span> * time.Second,</span><br><span class="line">Callbacks: leaderelection.LeaderCallbacks&#123;</span><br><span class="line">OnStartedLeading: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、选主成功，运行 controller 逻辑</span></span><br><span class="line"><span class="keyword">if</span> err = controller.Run(ctx, <span class="number">2</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err, <span class="string">&quot;Error running controller&quot;</span>)</span><br><span class="line">klog.FlushAndExit(klog.ExitFlushTimeout, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">OnStoppedLeading: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// we can do cleanup here</span></span><br><span class="line">klog.Infof(<span class="string">&quot;leader lost: %s&quot;</span>, leaseLockId)</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;,</span><br><span class="line">OnNewLeader: <span class="function"><span class="keyword">func</span><span class="params">(identity <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// we&#x27;re notified when new leader elected</span></span><br><span class="line"><span class="keyword">if</span> identity == leaseLockId &#123;</span><br><span class="line"><span class="comment">// I just got the lock</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">klog.Infof(<span class="string">&quot;new leader elected: %s&quot;</span>, identity)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码示例：<a href="https://github.com/lizhewei91/crd-controller">https://github.com/lizhewei91/crd-controller</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>sample-controller：<a href="https://github.com/kubernetes/sample-controller/tree/v0.28.0">https://github.com/kubernetes/sample-controller/tree/v0.28.0</a></p><p>code-generator：<a href="https://github.com/kubernetes/code-generator/tree/v0.28.0">https://github.com/kubernetes/code-generator/tree/v0.28.0</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是-operator-？&quot;&gt;&lt;a href=&quot;#什么是-operator-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 operator ？&quot;&gt;&lt;/a&gt;什么是 operator ？&lt;/h1&gt;&lt;p&gt;operator 是一种 kubernete</summary>
      
    
    
    
    <category term="operator" scheme="http://lizhewei91.github.io/categories/operator/"/>
    
    
    <category term="operator" scheme="http://lizhewei91.github.io/tags/operator/"/>
    
    <category term="code-generator" scheme="http://lizhewei91.github.io/tags/code-generator/"/>
    
  </entry>
  
  <entry>
    <title>kube-scheduler</title>
    <link href="http://lizhewei91.github.io/2023/07/17/39/"/>
    <id>http://lizhewei91.github.io/2023/07/17/39/</id>
    <published>2023-07-17T08:45:39.000Z</published>
    <updated>2023-07-17T08:45:39.423Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>kubelet 资源配置</title>
    <link href="http://lizhewei91.github.io/2023/03/10/19/"/>
    <id>http://lizhewei91.github.io/2023/03/10/19/</id>
    <published>2023-03-10T07:03:19.000Z</published>
    <updated>2023-06-01T09:04:07.404Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/03/10/19/640.png" class="" title="图片"><p>Kubernetes 的节点可以按照 <code>Capacity</code> 调度。默认情况下 pod 能够使用节点全部可用容量。 这是个问题，因为节点自己通常运行了不少驱动 OS 和 Kubernetes 的系统守护进程。 除非为这些系统守护进程留出资源，否则它们将与 Pod 争夺资源并导致节点资源短缺问题。</p><p><code>kubelet</code> 公开了一个名为 ‘Node Allocatable’ 的特性，有助于为系统守护进程预留计算资源。 Kubernetes 推荐集群管理员按照每个节点上的工作负载密度配置 ‘Node Allocatable’。</p><h2 id="节点可分配资源"><a href="#节点可分配资源" class="headerlink" title="节点可分配资源"></a>节点可分配资源</h2><p>Kubernetes 节点上的 ‘Allocatable’ 被定义为 Pod 可用计算资源量。 调度器不会超额申请 ‘Allocatable’。 目前支持 **‘CPU’、’memory’ 和 ‘ephemeral-storage’ ** 这几个参数。</p><p>我们可以通过 <code>kubectl describe node</code> 命令查看节点可分配资源的数据：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl describe node node-2</span><br><span class="line">...</span><br><span class="line">Capacity:</span><br><span class="line">  cpu:                40</span><br><span class="line">  ephemeral-storage:  276590640Ki</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             131273628Ki</span><br><span class="line">  pods:               255</span><br><span class="line">Allocatable:</span><br><span class="line">  cpu:                38976m</span><br><span class="line">  ephemeral-storage:  254905933402</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             131171228Ki</span><br><span class="line">  pods:               255</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到其中有 <code>Capacity</code> 与 <code>Allocatable</code> 两项内容，其中的 <code>Allocatable</code> 就是节点可被分配的资源，我们这里没有配置资源预留，所以默认情况下 <code>Capacity</code> 与 <code>Allocatable</code> 的值基本上是一致的。下图显示了可分配资源和资源预留之间的关系：</p><img src="/2023/03/10/19/640-20230310155640575.png" class="" title="图片"><ul><li>目前支持 cpu, memory, <code>ephemeral-storage</code> 三种资源预留。</li><li>Node Capacity 是节点的所有硬件资源，<code>kube-reserved</code> 是给 kube 组件预留的资源，<code>system-reserved</code> 是给系统进程预留的资源，<code>eviction-threshold</code> 是 kubelet 驱逐的阈值设定，<code>allocatable</code> 才是真正调度器调度 Pod 时的参考值（保证节点上所有 Pods 的 request 资源不超过 Allocatable）。</li></ul><p>节点可分配资源的计算方式为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Node Allocatable Resource = Node Capacity - Kube-reserved - system-reserved - eviction-threshold</span><br></pre></td></tr></table></figure><h2 id="配置资源预留"><a href="#配置资源预留" class="headerlink" title="配置资源预留"></a><strong>配置资源预留</strong></h2><h3 id="配置-cgroup-驱动"><a href="#配置-cgroup-驱动" class="headerlink" title="配置 cgroup 驱动"></a>配置 cgroup 驱动</h3><p><code>kubelet</code> 支持在主机上使用 cgroup 驱动操作 cgroup 层次结构。 该驱动通过 <code>--cgroup-driver</code> 标志进行配置。</p><p>支持的参数值如下：</p><ul><li><code>cgroupfs</code> 是默认的驱动，在主机上直接操作 cgroup 文件系统以对 cgroup 沙箱进行管理。</li><li><code>systemd</code> 是可选的驱动，使用 init 系统支持的资源的瞬时切片管理 cgroup 沙箱。</li></ul><p>取决于相关容器运行时的配置，操作员可能需要选择一个特定的 cgroup 驱动来保证系统正常运行。</p><p>如果操作员使用 <code>containerd</code> 运行时提供的 <code>systemd</code> cgroup 驱动时， 必须配置 <code>kubelet</code> 使用 <code>systemd</code> cgroup 驱动</p><h3 id="Kube-预留值"><a href="#Kube-预留值" class="headerlink" title="Kube 预留值"></a><strong>Kube 预留值</strong></h3><ul><li><strong>Kubelet 标志</strong>：<code>--kube-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]</code></li><li><strong>Kubelet 标志</strong>：<code>--kube-reserved-cgroup=</code></li></ul><p><code>kube-reserved</code> 用来给诸如 <code>kubelet</code>、容器运行时、节点问题监测器等 Kubernetes 系统守护进程记述其资源预留值。 该配置并非用来给以 Pod 形式运行的系统守护进程预留资源。<code>kube-reserved</code> 通常是节点上 <code>Pod 密度</code> 的函数。</p><p>除了 <code>cpu</code>、<code>内存</code> 和 <code>ephemeral-storage</code> 之外，<code>pid</code> 可用来指定为 Kubernetes 系统守护进程预留指定数量的进程 ID。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2023/03/10/19/640.png&quot; class=&quot;&quot; title=&quot;图片&quot;&gt;

&lt;p&gt;Kubernetes 的节点可以按照 &lt;code&gt;Capacity&lt;/code&gt; 调度。默认情况下 pod 能够使用节点全部可用容量。 这是个问题，因为节点自己通</summary>
      
    
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/categories/kubelet/"/>
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/tags/kubelet/"/>
    
    <category term="node 节点资源分配" scheme="http://lizhewei91.github.io/tags/node-%E8%8A%82%E7%82%B9%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>kubelet 创建 pod 源码分析</title>
    <link href="http://lizhewei91.github.io/2023/03/09/08/"/>
    <id>http://lizhewei91.github.io/2023/03/09/08/</id>
    <published>2023-03-09T02:33:08.000Z</published>
    <updated>2023-06-01T13:31:53.206Z</updated>
    
    <content type="html"><![CDATA[<p>本来基于 kubernetnes : v1.25.4</p><p>之前那篇文章对 kubelet 的工作原理做了简单的介绍，接下来，我们对 pod 创建的流程中，kubelet 创建 pod 进行一个详细的分析。</p><img src="kubelet-create-pod/kubelet-arch.jpg" alt="kubelet-arch"  /><h1 id="SyncLoop"><a href="#SyncLoop" class="headerlink" title="SyncLoop"></a>SyncLoop</h1><p>我们来看下这个主循环 SyncLoop：</p><p><em><u>/pkg/kubelet/kubelet.go#2009</u></em></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> syncLoop(updates &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler) &#123;</span><br><span class="line">klog.InfoS(<span class="string">&quot;Starting kubelet main sync loop&quot;</span>)</span><br><span class="line"><span class="comment">// The syncTicker wakes up kubelet to checks if there are any pod workers</span></span><br><span class="line"><span class="comment">// that need to be sync&#x27;d. A one-second period is sufficient because the</span></span><br><span class="line"><span class="comment">// sync interval is defaulted to 10s.</span></span><br><span class="line">syncTicker := time.NewTicker(time.Second)</span><br><span class="line"><span class="keyword">defer</span> syncTicker.Stop()</span><br><span class="line">housekeepingTicker := time.NewTicker(housekeepingPeriod)</span><br><span class="line"><span class="keyword">defer</span> housekeepingTicker.Stop()</span><br><span class="line">plegCh := kl.pleg.Watch()</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">base   = <span class="number">100</span> * time.Millisecond</span><br><span class="line">max    = <span class="number">5</span> * time.Second</span><br><span class="line">factor = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line">duration := base</span><br><span class="line"><span class="comment">// Responsible for checking limits in resolv.conf</span></span><br><span class="line"><span class="comment">// The limits do not have anything to do with individual pods</span></span><br><span class="line"><span class="comment">// Since this is called in syncLoop, we don&#x27;t need to call it anywhere else</span></span><br><span class="line"><span class="keyword">if</span> kl.dnsConfigurer != <span class="literal">nil</span> &amp;&amp; kl.dnsConfigurer.ResolverConfig != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">kl.dnsConfigurer.CheckLimitsForResolvConf()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := kl.runtimeState.runtimeErrors(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Skipping pod synchronization&quot;</span>)</span><br><span class="line"><span class="comment">// exponential backoff</span></span><br><span class="line">time.Sleep(duration)</span><br><span class="line">duration = time.Duration(math.Min(<span class="type">float64</span>(max), factor*<span class="type">float64</span>(duration)))</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// reset backoff if we have a success</span></span><br><span class="line">duration = base</span><br><span class="line"></span><br><span class="line">kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line"><span class="keyword">if</span> !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">kl.syncLoopMonitor.Store(kl.clock.Now())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SyncLoop 起了一个死循环，循环里只调用了 syncLoopIteration 方法。而 syncLoopIteration 会对传入的所有 channel 遍历，发现任何一个管道有消息就交给 handler 去处理。</p><p>这些 channel 包括：</p><ul><li><strong>configCh：</strong>该 channel 的生产者为 kubeDeps 对象中的 PodConfig 子模块提供，该模块将同时监听来自 file，http，apiserver 的 pod 信息的变化，一旦某个来源的 pod 信息发生了更新，就会向这个 channel 生产相关事件。</li><li><strong>plegCh：</strong>该 channel 的生产者为 pleg 子模块，该模块会周期性地向容器运行时查询当前所有容器的状态，如果状态发生变化，则向这个 channel 生产事件。</li><li><strong>syncCh：</strong>定时同步最新保存的 pod 状态。</li><li><strong>health manager :</strong> livenessManager、readinessManager、startupManager 健康检查发现某个 pod 不可用，Kubelet 将根据 Pod 的 restartPolicy 自动执行正确的操作。</li><li><strong>houseKeepingCh：</strong>housekeeping 事件的管道，做 pod 清理工作。</li></ul><h2 id="syncLoopIteration"><a href="#syncLoopIteration" class="headerlink" title="syncLoopIteration"></a>syncLoopIteration</h2><p><em><u>/pkg/kubelet/kubelet.go#2083</u></em></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> syncLoopIteration(configCh &lt;-<span class="keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span><br><span class="line">syncCh &lt;-<span class="keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="keyword">chan</span> time.Time, plegCh &lt;-<span class="keyword">chan</span> *pleg.PodLifecycleEvent) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">case</span> u, open := &lt;-configCh:</span><br><span class="line"><span class="comment">// Update from a config source; dispatch it to the right handler</span></span><br><span class="line"><span class="comment">// callback.</span></span><br><span class="line"><span class="keyword">if</span> !open &#123;</span><br><span class="line">klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Update channel is closed, exiting the sync loop&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> u.Op &#123;</span><br><span class="line"><span class="keyword">case</span> kubetypes.ADD:</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop ADD&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line"><span class="comment">// After restarting, kubelet will get all existing pods through</span></span><br><span class="line"><span class="comment">// ADD as if they are new pods. These pods will then go through the</span></span><br><span class="line"><span class="comment">// admission process and *may* be rejected. This can be resolved</span></span><br><span class="line"><span class="comment">// once we have checkpointing.</span></span><br><span class="line">handler.HandlePodAdditions(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.UPDATE:</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop UPDATE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">handler.HandlePodUpdates(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.REMOVE:</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop REMOVE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">handler.HandlePodRemoves(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.RECONCILE:</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop RECONCILE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line">handler.HandlePodReconcile(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.DELETE:</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop DELETE&quot;</span>, <span class="string">&quot;source&quot;</span>, u.Source, <span class="string">&quot;pods&quot;</span>, klog.KObjs(u.Pods))</span><br><span class="line"><span class="comment">// DELETE is treated as a UPDATE because of graceful deletion.</span></span><br><span class="line">handler.HandlePodUpdates(u.Pods)</span><br><span class="line"><span class="keyword">case</span> kubetypes.SET:</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Do we want to support this?</span></span><br><span class="line">klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Kubelet does not support snapshot update&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">klog.ErrorS(<span class="literal">nil</span>, <span class="string">&quot;Invalid operation type received&quot;</span>, <span class="string">&quot;operation&quot;</span>, u.Op)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kl.sourcesReady.AddSource(u.Source)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> e := &lt;-plegCh:</span><br><span class="line"><span class="keyword">if</span> e.Type == pleg.ContainerStarted &#123;</span><br><span class="line"><span class="comment">// record the most recent time we observed a container start for this pod.</span></span><br><span class="line"><span class="comment">// this lets us selectively invalidate the runtimeCache when processing a delete for this pod</span></span><br><span class="line"><span class="comment">// to make sure we don&#x27;t miss handling graceful termination for containers we reported as having started.</span></span><br><span class="line">kl.lastContainerStartedTime.Add(e.ID, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> isSyncPodWorthy(e) &#123;</span><br><span class="line"><span class="comment">// PLEG event for a pod; sync it.</span></span><br><span class="line"><span class="keyword">if</span> pod, ok := kl.podManager.GetPodByUID(e.ID); ok &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;SyncLoop (PLEG): event for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;event&quot;</span>, e)</span><br><span class="line">handler.HandlePodSyncs([]*v1.Pod&#123;pod&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// If the pod no longer exists, ignore the event.</span></span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (PLEG): pod does not exist, ignore irrelevant event&quot;</span>, <span class="string">&quot;event&quot;</span>, e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e.Type == pleg.ContainerDied &#123;</span><br><span class="line"><span class="keyword">if</span> containerID, ok := e.Data.(<span class="type">string</span>); ok &#123;</span><br><span class="line">kl.cleanUpContainersInPod(e.ID, containerID)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-syncCh:</span><br><span class="line"><span class="comment">// Sync pods waiting for sync</span></span><br><span class="line">podsToSync := kl.getPodsToSync()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(podsToSync) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (SYNC) pods&quot;</span>, <span class="string">&quot;total&quot;</span>, <span class="built_in">len</span>(podsToSync), <span class="string">&quot;pods&quot;</span>, klog.KObjs(podsToSync))</span><br><span class="line">handler.HandlePodSyncs(podsToSync)</span><br><span class="line"><span class="keyword">case</span> update := &lt;-kl.livenessManager.Updates():</span><br><span class="line"><span class="keyword">if</span> update.Result == proberesults.Failure &#123;</span><br><span class="line">handleProbeSync(kl, update, handler, <span class="string">&quot;liveness&quot;</span>, <span class="string">&quot;unhealthy&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> update := &lt;-kl.readinessManager.Updates():</span><br><span class="line">ready := update.Result == proberesults.Success</span><br><span class="line">kl.statusManager.SetContainerReadiness(update.PodUID, update.ContainerID, ready)</span><br><span class="line"></span><br><span class="line">status := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> ready &#123;</span><br><span class="line">status = <span class="string">&quot;ready&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">handleProbeSync(kl, update, handler, <span class="string">&quot;readiness&quot;</span>, status)</span><br><span class="line"><span class="keyword">case</span> update := &lt;-kl.startupManager.Updates():</span><br><span class="line">started := update.Result == proberesults.Success</span><br><span class="line">kl.statusManager.SetContainerStartup(update.PodUID, update.ContainerID, started)</span><br><span class="line"></span><br><span class="line">status := <span class="string">&quot;unhealthy&quot;</span></span><br><span class="line"><span class="keyword">if</span> started &#123;</span><br><span class="line">status = <span class="string">&quot;started&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">handleProbeSync(kl, update, handler, <span class="string">&quot;startup&quot;</span>, status)</span><br><span class="line"><span class="keyword">case</span> &lt;-housekeepingCh:</span><br><span class="line"><span class="keyword">if</span> !kl.sourcesReady.AllReady() &#123;</span><br><span class="line"><span class="comment">// If the sources aren&#x27;t ready or volume manager has not yet synced the states,</span></span><br><span class="line"><span class="comment">// skip housekeeping, as we may accidentally delete pods from unready sources.</span></span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (housekeeping, skipped): sources aren&#x27;t ready yet&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (housekeeping)&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err := handler.HandlePodCleanups(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Failed cleaning pods&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">duration := time.Since(start)</span><br><span class="line"><span class="keyword">if</span> duration &gt; housekeepingWarningDuration &#123;</span><br><span class="line">klog.ErrorS(fmt.Errorf(<span class="string">&quot;housekeeping took too long&quot;</span>), <span class="string">&quot;Housekeeping took longer than 15s&quot;</span>, <span class="string">&quot;seconds&quot;</span>, duration.Seconds())</span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncLoop (housekeeping) end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建pod过程"><a href="#创建pod过程" class="headerlink" title="创建pod过程"></a>创建pod过程</h3><p>Kubelet 创建 pod 的过程是由 configCh 中的 ADD 事件触发的，那么下面主要看下 Kubelet 接收到 ADD 事件后的主要流程。</p><h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>当 configCh 中出现了 ADD 事件，loop 会触发 SyncHandler 的 HandlePodAdditions 方法。这个方法的流程可以用下面这张流程图描述：</p><img src="/2023/03/09/08/handlePodAdditions.png" class="" title="handlePodAdditions"><ul><li><p>首先 handler 会将所有的 pod 安装创建时间进行排序，然后逐个进行处理。</p></li><li><p>然后将 pod 添加到 podManager 中，以方便后续操作；然后判断其是否为 mirror pod，如果是将作为 mirror pod 处理，否则按照正常 pod 处理。</p><p>这里解释一下 mirror pod： mirror pod 是 static pod 在 kueblet 在 apiserver 创建的一份副本。由于 static pod 是由 Kubelet 直接管理的，apiserver 并不会感知到 static pod 的存在，其生命周期都由 Kubelet 直接托管。为了可以通过 kubectl 命令查看对应的 pod，并且可以通过 kubectl logs 命令直接查看到static pod 的日志信息，Kubelet 通过 apiserver 为每一个 static pod 创建一个对应的 mirror pod。</p></li><li><p>接着判断 pod 是否能再该节点上运行，也就是所谓的 Kubelet 中的 pod 准入控制，准入控制主要包括这几方面：</p></li></ul><ol><li>节点是否满足 pod 的亲和性规则</li><li>节点是否有足够的资源分配给 pod</li><li>节点是否使用 HostNetwork 或者 HostIPC，若使用了，是否在节点的白名单里</li><li>/proc 挂载目录满足要求</li><li>pod 是否配置且是否配置正确的 AppArmor</li></ol><ul><li>当所有的条件都满足后，最后触发 podWorker 同步 pod。</li></ul><p>HandlePodAdditions 对应的代码如下：</p><p><u><em>/pkg/kubelet/kubelet.go#2238</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> HandlePodAdditions(pods []*v1.Pod) &#123;</span><br><span class="line">start := kl.clock.Now()</span><br><span class="line">sort.Sort(sliceutils.PodsByCreationTime(pods))</span><br><span class="line"><span class="keyword">for</span> _, pod := <span class="keyword">range</span> pods &#123;</span><br><span class="line">existingPods := kl.podManager.GetPods()</span><br><span class="line"><span class="comment">// Always add the pod to the pod manager. Kubelet relies on the pod</span></span><br><span class="line"><span class="comment">// manager as the source of truth for the desired state. If a pod does</span></span><br><span class="line"><span class="comment">// not exist in the pod manager, it means that it has been deleted in</span></span><br><span class="line"><span class="comment">// the apiserver and no action (other than cleanup) is required.</span></span><br><span class="line">kl.podManager.AddPod(pod)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> kubetypes.IsMirrorPod(pod) &#123;</span><br><span class="line">kl.handleMirrorPod(pod, start)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only go through the admission process if the pod is not requested</span></span><br><span class="line"><span class="comment">// for termination by another part of the kubelet. If the pod is already</span></span><br><span class="line"><span class="comment">// using resources (previously admitted), the pod worker is going to be</span></span><br><span class="line"><span class="comment">// shutting it down. If the pod hasn&#x27;t started yet, we know that when</span></span><br><span class="line"><span class="comment">// the pod worker is invoked it will also avoid setting up the pod, so</span></span><br><span class="line"><span class="comment">// we simply avoid doing any work.</span></span><br><span class="line"><span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line"><span class="comment">// We failed pods that we rejected, so activePods include all admitted</span></span><br><span class="line"><span class="comment">// pods that are alive.</span></span><br><span class="line">activePods := kl.filterOutInactivePods(existingPods)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if we can admit the pod; if not, reject it.</span></span><br><span class="line"><span class="keyword">if</span> ok, reason, message := kl.canAdmitPod(activePods, pod); !ok &#123;</span><br><span class="line">kl.rejectPod(pod, reason, message)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mirrorPod, _ := kl.podManager.GetMirrorPodByPod(pod)</span><br><span class="line">kl.dispatchWork(pod, kubetypes.SyncPodCreate, mirrorPod, start)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="podWorkers-的工作"><a href="#podWorkers-的工作" class="headerlink" title="podWorkers 的工作"></a>podWorkers 的工作</h4><p>接下来看看 podWorker 的工作。podWorker 维护了一个 map 叫 podUpdates (map[types.UID]chan podWork)，以 pod uid 为 key，为每个 pod 维护一个 channel；当 pod 有事件过来的时候，首先从这个 map 里获取对应的 channel，然后启动一个 goroutine 监听这个 channel，并执行 managePodLoop；另一方面 podWorker 向这个 channel 中传入需要同步的 pod。</p><p>managePodLoop 接收到事件后，会先从 pod cache 中获取该 pod 最新的 status，以确保当前处理的 pod 是最新状态；然后调用 syncPod 方法，将其同步后的结果记录在 workQueue 中，等待下一次定时同步任务处理。</p><p>整个过程如下图所示：</p><img src="/2023/03/09/08/2020-08-02-161428.jpg" class="" title="img"><p>podWorker 中处理 pod 事件的代码：</p><p><u><em>/pkg/kubelet/pod_workers.go#557</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span></span> UpdatePod(options UpdatePodOptions) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// allow testing of delays in the pod update channel</span></span><br><span class="line"><span class="keyword">var</span> outCh &lt;-<span class="keyword">chan</span> podWork</span><br><span class="line"><span class="keyword">if</span> p.workerChannelFn != <span class="literal">nil</span> &#123;</span><br><span class="line">outCh = p.workerChannelFn(uid, podUpdates)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">outCh = podUpdates</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating a new pod worker either means this is a new pod, or that the</span></span><br><span class="line"><span class="comment">// kubelet just restarted. In either case the kubelet is willing to believe</span></span><br><span class="line"><span class="comment">// the status of the pod for the first pod worker sync. See corresponding</span></span><br><span class="line"><span class="comment">// comment in syncPod.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> runtime.HandleCrash()</span><br><span class="line">p.managePodLoop(outCh)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dispatch a request to the pod worker if none are running</span></span><br><span class="line"><span class="keyword">if</span> !status.IsWorking() &#123;</span><br><span class="line">status.working = <span class="literal">true</span></span><br><span class="line">podUpdates &lt;- work</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>managePodLoop 函数，会根据 update.WorkType 类型，去分别执行 syncTerminatedPodFn、syncTerminatingPodFn、syncPodFn方法去调用</p><p><u><em>/pkg/kubelet/pod_worker.go#877</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *podWorkers)</span></span> managePodLoop(podUpdates &lt;-<span class="keyword">chan</span> podWork) &#123;</span><br><span class="line"><span class="keyword">var</span> lastSyncTime time.Time</span><br><span class="line"><span class="keyword">var</span> podStarted <span class="type">bool</span></span><br><span class="line"><span class="keyword">for</span> update := <span class="keyword">range</span> podUpdates &#123;</span><br><span class="line">pod := update.Options.Pod</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Take the appropriate action (illegal phases are prevented by UpdatePod)</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> update.WorkType == TerminatedPodWork:</span><br><span class="line">err = p.syncTerminatedPodFn(ctx, pod, status)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> update.WorkType == TerminatingPodWork:</span><br><span class="line"><span class="keyword">var</span> gracePeriod *<span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> opt := update.Options.KillPodOptions; opt != <span class="literal">nil</span> &#123;</span><br><span class="line">gracePeriod = opt.PodTerminationGracePeriodSecondsOverride</span><br><span class="line">&#125;</span><br><span class="line">podStatusFn := p.acknowledgeTerminating(pod)</span><br><span class="line"></span><br><span class="line">err = p.syncTerminatingPodFn(ctx, pod, status, update.Options.RunningPod, gracePeriod, podStatusFn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">isTerminal, err = p.syncPodFn(ctx, update.Options.UpdateType, pod, update.Options.MirrorPod, status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lastSyncTime = time.Now()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;()</span><br><span class="line">...</span><br><span class="line"><span class="comment">// queue a retry if necessary, then put the next event in the channel if any</span></span><br><span class="line">p.completeWork(pod, phaseTransition, err)</span><br><span class="line"><span class="keyword">if</span> start := update.Options.StartTime; !start.IsZero() &#123;</span><br><span class="line">metrics.PodWorkerDuration.WithLabelValues(update.Options.UpdateType.String()).Observe(metrics.SinceInSeconds(start))</span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Processing pod event done&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID, <span class="string">&quot;updateType&quot;</span>, update.WorkType)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="syncPod"><a href="#syncPod" class="headerlink" title="syncPod"></a>syncPod</h4><p>上述 podWorker 在 managePodLoop 中调用的 syncPodFn 方法，其实是 Kubelet 对象的 SyncPod 方法，在文件 pkg/kubelet/kubelet.go 中。</p><p>这个方法是真正与 container runtime 层交互的。首先，如果正在创建，记录pod worker启动延迟；设置podIP为hostIP；然后判断是否可以在节点上运行，这里就是上面讲到的 Kubelet 的准入控制；再判断 CNI 插件是否 ready，如果不 ready，则只在 pod 使用 host network 的时候创建并更新 pod 的 cgroups；接着再判断是否是静态 pod，如果是就创建相应的 mirror pod；然后创建 pod 需要挂载的目录；最后调用 runtime 的 syncPod。整个流程如下所示：</p><img src="/2023/03/09/08/syncPod-8419730.png" class="" title="syncPod"><p><u><em>/pkg/kubelet/kubelet.go#1522</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> syncPod(ctx context.Context, updateType kubetypes.SyncPodType, pod, mirrorPod *v1.Pod, podStatus *kubecontainer.PodStatus) (isTerminal <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;syncPod enter&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;syncPod exit&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID, <span class="string">&quot;isTerminal&quot;</span>, isTerminal)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Latency measurements for the main workflow are relative to the</span></span><br><span class="line"><span class="comment">// first time the pod was seen by kubelet.</span></span><br><span class="line"><span class="keyword">var</span> firstSeenTime time.Time</span><br><span class="line"><span class="keyword">if</span> firstSeenTimeStr, ok := pod.Annotations[kubetypes.ConfigFirstSeenAnnotationKey]; ok &#123;</span><br><span class="line">firstSeenTime = kubetypes.ConvertToTimestamp(firstSeenTimeStr).Get()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record pod worker start latency if being created</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> make pod workers record their own latencies</span></span><br><span class="line"><span class="keyword">if</span> updateType == kubetypes.SyncPodCreate &#123;</span><br><span class="line"><span class="keyword">if</span> !firstSeenTime.IsZero() &#123;</span><br><span class="line"><span class="comment">// This is the first time we are syncing the pod. Record the latency</span></span><br><span class="line"><span class="comment">// since kubelet first saw the pod if firstSeenTime is set.</span></span><br><span class="line">metrics.PodWorkerStartDuration.Observe(metrics.SinceInSeconds(firstSeenTime))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;First seen time not recorded for pod&quot;</span>,</span><br><span class="line"><span class="string">&quot;podUID&quot;</span>, pod.UID,</span><br><span class="line"><span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate final API pod status with pod and status manager status</span></span><br><span class="line">apiPodStatus := kl.generateAPIPodStatus(pod, podStatus)</span><br><span class="line"><span class="comment">// The pod IP may be changed in generateAPIPodStatus if the pod is using host network. (See #24576)</span></span><br><span class="line"><span class="comment">// TODO(random-liu): After writing pod spec into container labels, check whether pod is using host network, and</span></span><br><span class="line"><span class="comment">// set pod IP to hostIP directly in runtime.GetPodStatus</span></span><br><span class="line">podStatus.IPs = <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(apiPodStatus.PodIPs))</span><br><span class="line"><span class="keyword">for</span> _, ipInfo := <span class="keyword">range</span> apiPodStatus.PodIPs &#123;</span><br><span class="line">podStatus.IPs = <span class="built_in">append</span>(podStatus.IPs, ipInfo.IP)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(podStatus.IPs) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(apiPodStatus.PodIP) &gt; <span class="number">0</span> &#123;</span><br><span class="line">podStatus.IPs = []<span class="type">string</span>&#123;apiPodStatus.PodIP&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the pod is terminal, we don&#x27;t need to continue to setup the pod</span></span><br><span class="line"><span class="keyword">if</span> apiPodStatus.Phase == v1.PodSucceeded || apiPodStatus.Phase == v1.PodFailed &#123;</span><br><span class="line">kl.statusManager.SetPodStatus(pod, apiPodStatus)</span><br><span class="line">isTerminal = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> isTerminal, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the pod should not be running, we request the pod&#x27;s containers be stopped. This is not the same</span></span><br><span class="line"><span class="comment">// as termination (we want to stop the pod, but potentially restart it later if soft admission allows</span></span><br><span class="line"><span class="comment">// it later). Set the status and phase appropriately</span></span><br><span class="line">runnable := kl.canRunPod(pod)</span><br><span class="line"><span class="keyword">if</span> !runnable.Admit &#123;</span><br><span class="line"><span class="comment">// Pod is not runnable; and update the Pod and Container statuses to why.</span></span><br><span class="line"><span class="keyword">if</span> apiPodStatus.Phase != v1.PodFailed &amp;&amp; apiPodStatus.Phase != v1.PodSucceeded &#123;</span><br><span class="line">apiPodStatus.Phase = v1.PodPending</span><br><span class="line">&#125;</span><br><span class="line">apiPodStatus.Reason = runnable.Reason</span><br><span class="line">apiPodStatus.Message = runnable.Message</span><br><span class="line"><span class="comment">// Waiting containers are not creating.</span></span><br><span class="line"><span class="keyword">const</span> waitingReason = <span class="string">&quot;Blocked&quot;</span></span><br><span class="line"><span class="keyword">for</span> _, cs := <span class="keyword">range</span> apiPodStatus.InitContainerStatuses &#123;</span><br><span class="line"><span class="keyword">if</span> cs.State.Waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">cs.State.Waiting.Reason = waitingReason</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, cs := <span class="keyword">range</span> apiPodStatus.ContainerStatuses &#123;</span><br><span class="line"><span class="keyword">if</span> cs.State.Waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">cs.State.Waiting.Reason = waitingReason</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record the time it takes for the pod to become running</span></span><br><span class="line"><span class="comment">// since kubelet first saw the pod if firstSeenTime is set.</span></span><br><span class="line">existingStatus, ok := kl.statusManager.GetPodStatus(pod.UID)</span><br><span class="line"><span class="keyword">if</span> !ok || existingStatus.Phase == v1.PodPending &amp;&amp; apiPodStatus.Phase == v1.PodRunning &amp;&amp;</span><br><span class="line">!firstSeenTime.IsZero() &#123;</span><br><span class="line">metrics.PodStartDuration.Observe(metrics.SinceInSeconds(firstSeenTime))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kl.statusManager.SetPodStatus(pod, apiPodStatus)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pods that are not runnable must be stopped - return a typed error to the pod worker</span></span><br><span class="line"><span class="keyword">if</span> !runnable.Admit &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;Pod is not runnable and must have running containers stopped&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID, <span class="string">&quot;message&quot;</span>, runnable.Message)</span><br><span class="line"><span class="keyword">var</span> syncErr <span class="type">error</span></span><br><span class="line">p := kubecontainer.ConvertPodStatusToRunningPod(kl.getRuntime().Type(), podStatus)</span><br><span class="line"><span class="keyword">if</span> err := kl.killPod(pod, p, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToKillPod, <span class="string">&quot;error killing pod: %v&quot;</span>, err)</span><br><span class="line">syncErr = fmt.Errorf(<span class="string">&quot;error killing pod: %v&quot;</span>, err)</span><br><span class="line">utilruntime.HandleError(syncErr)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// There was no error killing the pod, but the pod cannot be run.</span></span><br><span class="line"><span class="comment">// Return an error to signal that the sync loop should back off.</span></span><br><span class="line">syncErr = fmt.Errorf(<span class="string">&quot;pod cannot be run: %s&quot;</span>, runnable.Message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, syncErr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the network plugin is not ready, only start the pod if it uses the host network</span></span><br><span class="line"><span class="keyword">if</span> err := kl.runtimeState.networkErrors(); err != <span class="literal">nil</span> &amp;&amp; !kubecontainer.IsHostNetworkPod(pod) &#123;</span><br><span class="line">kl.recorder.Eventf(pod, v1.EventTypeWarning, events.NetworkNotReady, <span class="string">&quot;%s: %v&quot;</span>, NetworkNotReadyErrorMsg, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;%s: %v&quot;</span>, NetworkNotReadyErrorMsg, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ensure the kubelet knows about referenced secrets or configmaps used by the pod</span></span><br><span class="line"><span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line"><span class="keyword">if</span> kl.secretManager != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.secretManager.RegisterPod(pod)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> kl.configMapManager != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.configMapManager.RegisterPod(pod)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Cgroups for the pod and apply resource parameters</span></span><br><span class="line"><span class="comment">// to them if cgroups-per-qos flag is enabled.</span></span><br><span class="line">pcm := kl.containerManager.NewPodContainerManager()</span><br><span class="line"><span class="comment">// If pod has already been terminated then we need not create</span></span><br><span class="line"><span class="comment">// or update the pod&#x27;s cgroup</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> once context cancellation is added this check can be removed</span></span><br><span class="line"><span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line"><span class="comment">// When the kubelet is restarted with the cgroups-per-qos</span></span><br><span class="line"><span class="comment">// flag enabled, all the pod&#x27;s running containers</span></span><br><span class="line"><span class="comment">// should be killed intermittently and brought back up</span></span><br><span class="line"><span class="comment">// under the qos cgroup hierarchy.</span></span><br><span class="line"><span class="comment">// Check if this is the pod&#x27;s first sync</span></span><br><span class="line">firstSync := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> _, containerStatus := <span class="keyword">range</span> apiPodStatus.ContainerStatuses &#123;</span><br><span class="line"><span class="keyword">if</span> containerStatus.State.Running != <span class="literal">nil</span> &#123;</span><br><span class="line">firstSync = <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Don&#x27;t kill containers in pod if pod&#x27;s cgroups already</span></span><br><span class="line"><span class="comment">// exists or the pod is running for the first time</span></span><br><span class="line">podKilled := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> !pcm.Exists(pod) &amp;&amp; !firstSync &#123;</span><br><span class="line">p := kubecontainer.ConvertPodStatusToRunningPod(kl.getRuntime().Type(), podStatus)</span><br><span class="line"><span class="keyword">if</span> err := kl.killPod(pod, p, <span class="literal">nil</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">podKilled = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;KillPod failed&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podStatus&quot;</span>, podStatus)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Create and Update pod&#x27;s Cgroups</span></span><br><span class="line"><span class="comment">// Don&#x27;t create cgroups for run once pod if it was killed above</span></span><br><span class="line"><span class="comment">// The current policy is not to restart the run once pods when</span></span><br><span class="line"><span class="comment">// the kubelet is restarted with the new flag as run once pods are</span></span><br><span class="line"><span class="comment">// expected to run only once and if the kubelet is restarted then</span></span><br><span class="line"><span class="comment">// they are not expected to run again.</span></span><br><span class="line"><span class="comment">// We don&#x27;t create and apply updates to cgroup if its a run once pod and was killed above</span></span><br><span class="line"><span class="keyword">if</span> !(podKilled &amp;&amp; pod.Spec.RestartPolicy == v1.RestartPolicyNever) &#123;</span><br><span class="line"><span class="keyword">if</span> !pcm.Exists(pod) &#123;</span><br><span class="line"><span class="keyword">if</span> err := kl.containerManager.UpdateQOSCgroups(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.V(<span class="number">2</span>).InfoS(<span class="string">&quot;Failed to update QoS cgroups while syncing pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := pcm.EnsureExists(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToCreatePodContainer, <span class="string">&quot;unable to ensure pod container exists: %v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(<span class="string">&quot;failed to ensure that the pod: %v cgroups exist and are correctly applied: %v&quot;</span>, pod.UID, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Mirror Pod for Static Pod if it doesn&#x27;t already exist</span></span><br><span class="line"><span class="keyword">if</span> kubetypes.IsStaticPod(pod) &#123;</span><br><span class="line">deleted := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> mirrorPod != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> mirrorPod.DeletionTimestamp != <span class="literal">nil</span> || !kl.podManager.IsMirrorPodOf(mirrorPod, pod) &#123;</span><br><span class="line"><span class="comment">// The mirror pod is semantically different from the static pod. Remove</span></span><br><span class="line"><span class="comment">// it. The mirror pod will get recreated later.</span></span><br><span class="line">klog.InfoS(<span class="string">&quot;Trying to delete pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, mirrorPod.ObjectMeta.UID)</span><br><span class="line">podFullName := kubecontainer.GetPodFullName(pod)</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">deleted, err = kl.podManager.DeleteMirrorPod(podFullName, &amp;mirrorPod.ObjectMeta.UID)</span><br><span class="line"><span class="keyword">if</span> deleted &#123;</span><br><span class="line">klog.InfoS(<span class="string">&quot;Deleted mirror pod because it is outdated&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(mirrorPod))</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Failed deleting mirror pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(mirrorPod))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mirrorPod == <span class="literal">nil</span> || deleted &#123;</span><br><span class="line">node, err := kl.GetNode()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || node.DeletionTimestamp != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;No need to create a mirror pod, since node has been removed from the cluster&quot;</span>, <span class="string">&quot;node&quot;</span>, klog.KRef(<span class="string">&quot;&quot;</span>, <span class="type">string</span>(kl.nodeName)))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Creating a mirror pod for static pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="keyword">if</span> err := kl.podManager.CreateMirrorPod(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Failed creating a mirror pod for&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make data directories for the pod</span></span><br><span class="line"><span class="keyword">if</span> err := kl.makePodDataDirs(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedToMakePodDataDirectories, <span class="string">&quot;error making pod data directories: %v&quot;</span>, err)</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Unable to make pod data directories for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Volume manager will not mount volumes for terminating pods</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> once context cancellation is added this check can be removed</span></span><br><span class="line"><span class="keyword">if</span> !kl.podWorkers.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line"><span class="comment">// Wait for volumes to attach/mount</span></span><br><span class="line"><span class="keyword">if</span> err := kl.volumeManager.WaitForAttachAndMount(pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">kl.recorder.Eventf(pod, v1.EventTypeWarning, events.FailedMountVolume, <span class="string">&quot;Unable to attach or mount volumes: %v&quot;</span>, err)</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Unable to attach or mount volumes for pod; skipping pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the pull secrets for the pod</span></span><br><span class="line">pullSecrets := kl.getPullSecretsForPod(pod)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure the pod is being probed</span></span><br><span class="line">kl.probeManager.AddPod(pod)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the container runtime&#x27;s SyncPod callback</span></span><br><span class="line">result := kl.containerRuntime.SyncPod(pod, podStatus, pullSecrets, kl.backOff)</span><br><span class="line">kl.reasonCache.Update(pod.UID, result)</span><br><span class="line"><span class="keyword">if</span> err := result.Error(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Do not return error if the only failures were pods in backoff</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> result.SyncResults &#123;</span><br><span class="line"><span class="keyword">if</span> r.Error != kubecontainer.ErrCrashLoopBackOff &amp;&amp; r.Error != images.ErrImagePullBackOff &#123;</span><br><span class="line"><span class="comment">// Do not record an event here, as we keep all event logging for sync pod failures</span></span><br><span class="line"><span class="comment">// local to container runtime, so we get better errors.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><p>containerRuntime（pkg/kubelet/kuberuntime）子模块的 SyncPod 函数才是真正完成 pod 内容器实体的创建。</p><p><u><em>/pkg/kubelet/kuberuntime/kuberuntime_manager.go#668</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span></span> SyncPod(pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) &#123;</span><br><span class="line"><span class="comment">// Step 1: Compute sandbox and container changes.</span></span><br><span class="line">podContainerChanges := m.computePodActions(pod, podStatus)</span><br><span class="line">klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;computePodActions got for pod&quot;</span>, <span class="string">&quot;podActions&quot;</span>, podContainerChanges, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">ref, err := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Couldn&#x27;t make a ref to pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.SandboxID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">m.recorder.Eventf(ref, v1.EventTypeNormal, events.SandboxChanged, <span class="string">&quot;Pod sandbox changed, it will be killed and re-created.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;SyncPod received new pod, will create a sandbox for it&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: Kill the pod if the sandbox has changed.</span></span><br><span class="line"><span class="keyword">if</span> podContainerChanges.KillPod &#123;</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Stopping PodSandbox for pod, will start new one&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Stopping PodSandbox for pod, because all other containers are dead&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">killResult := m.killPodWithSyncResult(pod, kubecontainer.ConvertPodStatusToRunningPod(m.runtimeName, podStatus), <span class="literal">nil</span>)</span><br><span class="line">result.AddPodSyncResult(killResult)</span><br><span class="line"><span class="keyword">if</span> killResult.Error() != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(killResult.Error(), <span class="string">&quot;killPodWithSyncResult failed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">m.purgeInitContainers(pod, podStatus)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Step 3: kill any running containers in this pod which are not to keep.</span></span><br><span class="line"><span class="keyword">for</span> containerID, containerInfo := <span class="keyword">range</span> podContainerChanges.ContainersToKill &#123;</span><br><span class="line">klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;Killing unwanted container for pod&quot;</span>, <span class="string">&quot;containerName&quot;</span>, containerInfo.name, <span class="string">&quot;containerID&quot;</span>, containerID, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">killContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, containerInfo.name)</span><br><span class="line">result.AddSyncResult(killContainerResult)</span><br><span class="line"><span class="keyword">if</span> err := m.killContainer(pod, containerID, containerInfo.name, containerInfo.message, containerInfo.reason, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">killContainerResult.Fail(kubecontainer.ErrKillContainer, err.Error())</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;killContainer for pod failed&quot;</span>, <span class="string">&quot;containerName&quot;</span>, containerInfo.name, <span class="string">&quot;containerID&quot;</span>, containerID, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep terminated init containers fairly aggressively controlled</span></span><br><span class="line"><span class="comment">// This is an optimization because container removals are typically handled</span></span><br><span class="line"><span class="comment">// by container garbage collector.</span></span><br><span class="line">m.pruneInitContainersBeforeStart(pod, podStatus)</span><br><span class="line"></span><br><span class="line"><span class="comment">// We pass the value of the PRIMARY podIP and list of podIPs down to</span></span><br><span class="line"><span class="comment">// generatePodSandboxConfig and generateContainerConfig, which in turn</span></span><br><span class="line"><span class="comment">// passes it to various other functions, in order to facilitate functionality</span></span><br><span class="line"><span class="comment">// that requires this value (hosts file and downward API) and avoid races determining</span></span><br><span class="line"><span class="comment">// the pod IP in cases where a container requires restart but the</span></span><br><span class="line"><span class="comment">// podIP isn&#x27;t in the status manager yet. The list of podIPs is used to</span></span><br><span class="line"><span class="comment">// generate the hosts file.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We default to the IPs in the passed-in pod status, and overwrite them if the</span></span><br><span class="line"><span class="comment">// sandbox needs to be (re)started.</span></span><br><span class="line"><span class="keyword">var</span> podIPs []<span class="type">string</span></span><br><span class="line"><span class="keyword">if</span> podStatus != <span class="literal">nil</span> &#123;</span><br><span class="line">podIPs = podStatus.IPs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: Create a sandbox for the pod if necessary.</span></span><br><span class="line">podSandboxID := podContainerChanges.SandboxID</span><br><span class="line"><span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line"><span class="keyword">var</span> msg <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Creating PodSandbox for pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">metrics.StartedPodsTotal.Inc()</span><br><span class="line">createSandboxResult := kubecontainer.NewSyncResult(kubecontainer.CreatePodSandbox, format.Pod(pod))</span><br><span class="line">result.AddSyncResult(createSandboxResult)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConvertPodSysctlsVariableToDotsSeparator converts sysctl variable</span></span><br><span class="line"><span class="comment">// in the Pod.Spec.SecurityContext.Sysctls slice into a dot as a separator.</span></span><br><span class="line"><span class="comment">// runc uses the dot as the separator to verify whether the sysctl variable</span></span><br><span class="line"><span class="comment">// is correct in a separate namespace, so when using the slash as the sysctl</span></span><br><span class="line"><span class="comment">// variable separator, runc returns an error: &quot;sysctl is not in a separate kernel namespace&quot;</span></span><br><span class="line"><span class="comment">// and the podSandBox cannot be successfully created. Therefore, before calling runc,</span></span><br><span class="line"><span class="comment">// we need to convert the sysctl variable, the dot is used as a separator to separate the kernel namespace.</span></span><br><span class="line"><span class="comment">// When runc supports slash as sysctl separator, this function can no longer be used.</span></span><br><span class="line">sysctl.ConvertPodSysctlsVariableToDotsSeparator(pod.Spec.SecurityContext)</span><br><span class="line"></span><br><span class="line">podSandboxID, msg, err = m.createPodSandbox(pod, podContainerChanges.Attempt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// createPodSandbox can return an error from CNI, CSI,</span></span><br><span class="line"><span class="comment">// or CRI if the Pod has been deleted while the POD is</span></span><br><span class="line"><span class="comment">// being created. If the pod has been deleted then it&#x27;s</span></span><br><span class="line"><span class="comment">// not a real error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SyncPod can still be running when we get here, which</span></span><br><span class="line"><span class="comment">// means the PodWorker has not acked the deletion.</span></span><br><span class="line"><span class="keyword">if</span> m.podStateProvider.IsPodTerminationRequested(pod.UID) &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Pod was deleted and sandbox failed to be created&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;podUID&quot;</span>, pod.UID)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">metrics.StartedPodsErrorsTotal.Inc()</span><br><span class="line">createSandboxResult.Fail(kubecontainer.ErrCreatePodSandbox, msg)</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;CreatePodSandbox for pod failed&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">ref, referr := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line"><span class="keyword">if</span> referr != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(referr, <span class="string">&quot;Couldn&#x27;t make a ref to pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line">m.recorder.Eventf(ref, v1.EventTypeWarning, events.FailedCreatePodSandBox, <span class="string">&quot;Failed to create pod sandbox: %v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Created PodSandbox for pod&quot;</span>, <span class="string">&quot;podSandboxID&quot;</span>, podSandboxID, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"></span><br><span class="line">resp, err := m.runtimeService.PodSandboxStatus(podSandboxID, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ref, referr := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line"><span class="keyword">if</span> referr != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.ErrorS(referr, <span class="string">&quot;Couldn&#x27;t make a ref to pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line">m.recorder.Eventf(ref, v1.EventTypeWarning, events.FailedStatusPodSandBox, <span class="string">&quot;Unable to get pod sandbox status: %v&quot;</span>, err)</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;Failed to get pod sandbox status; Skipping pod&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">result.Fail(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> resp.GetStatus() == <span class="literal">nil</span> &#123;</span><br><span class="line">result.Fail(errors.New(<span class="string">&quot;pod sandbox status is nil&quot;</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we ever allow updating a pod from non-host-network to</span></span><br><span class="line"><span class="comment">// host-network, we may use a stale IP.</span></span><br><span class="line"><span class="keyword">if</span> !kubecontainer.IsHostNetworkPod(pod) &#123;</span><br><span class="line"><span class="comment">// Overwrite the podIPs passed in the pod status, since we just started the pod sandbox.</span></span><br><span class="line">podIPs = m.determinePodSandboxIPs(pod.Namespace, pod.Name, resp.GetStatus())</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Determined the ip for pod after sandbox changed&quot;</span>, <span class="string">&quot;IPs&quot;</span>, podIPs, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the start containers routines depend on pod ip(as in primary pod ip)</span></span><br><span class="line"><span class="comment">// instead of trying to figure out if we have 0 &lt; len(podIPs)</span></span><br><span class="line"><span class="comment">// everytime, we short circuit it here</span></span><br><span class="line">podIP := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(podIPs) != <span class="number">0</span> &#123;</span><br><span class="line">podIP = podIPs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get podSandboxConfig for containers to start.</span></span><br><span class="line">configPodSandboxResult := kubecontainer.NewSyncResult(kubecontainer.ConfigPodSandbox, podSandboxID)</span><br><span class="line">result.AddSyncResult(configPodSandboxResult)</span><br><span class="line">podSandboxConfig, err := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">message := fmt.Sprintf(<span class="string">&quot;GeneratePodSandboxConfig for pod %q failed: %v&quot;</span>, format.Pod(pod), err)</span><br><span class="line">klog.ErrorS(err, <span class="string">&quot;GeneratePodSandboxConfig for pod failed&quot;</span>, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">configPodSandboxResult.Fail(kubecontainer.ErrConfigPodSandbox, message)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper containing boilerplate common to starting all types of containers.</span></span><br><span class="line"><span class="comment">// typeName is a description used to describe this type of container in log messages,</span></span><br><span class="line"><span class="comment">// currently: &quot;container&quot;, &quot;init container&quot; or &quot;ephemeral container&quot;</span></span><br><span class="line"><span class="comment">// metricLabel is the label used to describe this type of container in monitoring metrics.</span></span><br><span class="line"><span class="comment">// currently: &quot;container&quot;, &quot;init_container&quot; or &quot;ephemeral_container&quot;</span></span><br><span class="line">start := <span class="function"><span class="keyword">func</span><span class="params">(typeName, metricLabel <span class="type">string</span>, spec *startSpec)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">startContainerResult := kubecontainer.NewSyncResult(kubecontainer.StartContainer, spec.container.Name)</span><br><span class="line">result.AddSyncResult(startContainerResult)</span><br><span class="line"></span><br><span class="line">isInBackOff, msg, err := m.doBackOff(pod, spec.container, podStatus, backOff)</span><br><span class="line"><span class="keyword">if</span> isInBackOff &#123;</span><br><span class="line">startContainerResult.Fail(err, msg)</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Backing Off restarting container in pod&quot;</span>, <span class="string">&quot;containerType&quot;</span>, typeName, <span class="string">&quot;container&quot;</span>, spec.container, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">metrics.StartedContainersTotal.WithLabelValues(metricLabel).Inc()</span><br><span class="line"><span class="keyword">if</span> sc.HasWindowsHostProcessRequest(pod, spec.container) &#123;</span><br><span class="line">metrics.StartedHostProcessContainersTotal.WithLabelValues(metricLabel).Inc()</span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Creating container in pod&quot;</span>, <span class="string">&quot;containerType&quot;</span>, typeName, <span class="string">&quot;container&quot;</span>, spec.container, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line"><span class="comment">// NOTE (aramase) podIPs are populated for single stack and dual stack clusters. Send only podIPs.</span></span><br><span class="line"><span class="keyword">if</span> msg, err := m.startContainer(podSandboxID, podSandboxConfig, spec, pod, podStatus, pullSecrets, podIP, podIPs); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// startContainer() returns well-defined error codes that have reasonable cardinality for metrics and are</span></span><br><span class="line"><span class="comment">// useful to cluster administrators to distinguish &quot;server errors&quot; from &quot;user errors&quot;.</span></span><br><span class="line">metrics.StartedContainersErrorsTotal.WithLabelValues(metricLabel, err.Error()).Inc()</span><br><span class="line"><span class="keyword">if</span> sc.HasWindowsHostProcessRequest(pod, spec.container) &#123;</span><br><span class="line">metrics.StartedHostProcessContainersErrorsTotal.WithLabelValues(metricLabel, err.Error()).Inc()</span><br><span class="line">&#125;</span><br><span class="line">startContainerResult.Fail(err, msg)</span><br><span class="line"><span class="comment">// known errors that are logged in other places are logged at higher levels here to avoid</span></span><br><span class="line"><span class="comment">// repetitive log spam</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> err == images.ErrImagePullBackOff:</span><br><span class="line">klog.V(<span class="number">3</span>).InfoS(<span class="string">&quot;Container start failed in pod&quot;</span>, <span class="string">&quot;containerType&quot;</span>, typeName, <span class="string">&quot;container&quot;</span>, spec.container, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod), <span class="string">&quot;containerMessage&quot;</span>, msg, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;%v %+v start failed in pod %v: %v: %s&quot;</span>, typeName, spec.container, format.Pod(pod), err, msg))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 5: start ephemeral containers</span></span><br><span class="line"><span class="comment">// These are started &quot;prior&quot; to init containers to allow running ephemeral containers even when there</span></span><br><span class="line"><span class="comment">// are errors starting an init container. In practice init containers will start first since ephemeral</span></span><br><span class="line"><span class="comment">// containers cannot be specified on pod creation.</span></span><br><span class="line"><span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.EphemeralContainersToStart &#123;</span><br><span class="line">start(<span class="string">&quot;ephemeral container&quot;</span>, metrics.EphemeralContainer, ephemeralContainerStartSpec(&amp;pod.Spec.EphemeralContainers[idx]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 6: start the init container.</span></span><br><span class="line"><span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Start the next init container.</span></span><br><span class="line"><span class="keyword">if</span> err := start(<span class="string">&quot;init container&quot;</span>, metrics.InitContainer, containerStartSpec(container)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Successfully started the container; clear the entry in the failure</span></span><br><span class="line">klog.V(<span class="number">4</span>).InfoS(<span class="string">&quot;Completed init container for pod&quot;</span>, <span class="string">&quot;containerName&quot;</span>, container.Name, <span class="string">&quot;pod&quot;</span>, klog.KObj(pod))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 7: start containers in podContainerChanges.ContainersToStart.</span></span><br><span class="line"><span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123;</span><br><span class="line">start(<span class="string">&quot;container&quot;</span>, metrics.Container, containerStartSpec(&amp;pod.Spec.Containers[idx]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本来基于 kubernetnes : v1.25.4&lt;/p&gt;
&lt;p&gt;之前那篇文章对 kubelet 的工作原理做了简单的介绍，接下来，我们对 pod 创建的流程中，kubelet 创建 pod 进行一个详细的分析。&lt;/p&gt;
&lt;img src=&quot;kubelet-create-</summary>
      
    
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/categories/kubelet/"/>
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/tags/kubelet/"/>
    
    <category term="创建pod流程" scheme="http://lizhewei91.github.io/tags/%E5%88%9B%E5%BB%BApod%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何构建多CPU架构容器镜像</title>
    <link href="http://lizhewei91.github.io/2023/02/27/09/"/>
    <id>http://lizhewei91.github.io/2023/02/27/09/</id>
    <published>2023-02-27T04:47:09.000Z</published>
    <updated>2023-06-01T09:06:03.160Z</updated>
    
    <content type="html"><![CDATA[<p>构建多架构镜像的方法有两种：</p><ul><li>manifest</li><li>docker buildx</li></ul><h1 id="buildx"><a href="#buildx" class="headerlink" title="buildx"></a>buildx</h1><p>首先 docker 版本要在 19.03 以上（含），启动 docker buildx，<code>export DOCKER_CLI_EXPERIMENTAL=enabled</code></p><p>build-demo示例链接：<a href="https://github.com/lizhewei91/buildx-demo">https://github.com/lizhewei91/buildx-demo</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@build-cloud-product-clone-4 buildx-demo]# tree</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── buildx-demo</span><br><span class="line">├── Dockfile.buildx</span><br><span class="line">├── go.mod</span><br><span class="line">├── main.go</span><br><span class="line">└── Makefile</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-buildx-示例"><a href="#Dockerfile-buildx-示例" class="headerlink" title="Dockerfile.buildx 示例"></a>Dockerfile.buildx 示例</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> BASE_IMAGE</span><br><span class="line"><span class="keyword">ARG</span> BASE_IMAGE_VERSION</span><br><span class="line"><span class="keyword">FROM</span> --platform=$&#123;TARGETPLATFORM&#125; $&#123;BASE_IMAGE&#125;:$&#123;BASE_IMAGE_VERSION&#125; AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/buildx-demo</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> --platform=$&#123;TARGETPLATFORM&#125; alpine:<span class="number">3.17</span>.<span class="number">2</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /go/src/buildx-demo/bin/buildx-demo /usr/bin/buildx-demo</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/bin/buildx-demo&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="Makefile示例"><a href="#Makefile示例" class="headerlink" title="Makefile示例"></a>Makefile示例</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGET_PLATFORMS ?= linux/amd64,linux/arm64</span><br><span class="line">BASE_IMAGE ?= golang</span><br><span class="line">BASE_IMAGE_VERSION ?= alpine3.17</span><br><span class="line">IMAGE_REPO ?= hub.easystack.cn/multi/buildx-demo</span><br><span class="line">IMAGE_VERSION ?= v0.0.1</span><br><span class="line">DOCKER_HUB_REPO ?= hub.easystack.cn</span><br><span class="line">DOCKER_HUB_USERNAME ?= xxx</span><br><span class="line">DOCKER_HUB_PASSWORD ?= xxx</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="section">all: docker-hub-login build images</span></span><br><span class="line"></span><br><span class="line"><span class="section">docker-hub-login:</span></span><br><span class="line">        docker logout</span><br><span class="line">        docker login $&#123;DOCKER_HUB_REPO&#125; -u $&#123;DOCKER_HUB_USERNAME&#125; -p $&#123;DOCKER_HUB_PASSWORD&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">build:</span></span><br><span class="line">        go build -o /go/src/buildx-demo/bin/buildx-demo main.go</span><br><span class="line"></span><br><span class="line"><span class="section">images:</span></span><br><span class="line">        docker buildx build \</span><br><span class="line">                --build-arg BASE_IMAGE=<span class="variable">$(BASE_IMAGE)</span> \</span><br><span class="line">                --build-arg BASE_IMAGE_VERSION=<span class="variable">$(BASE_IMAGE_VERSION)</span> \</span><br><span class="line">                --platform <span class="variable">$(TARGET_PLATFORMS)</span> \</span><br><span class="line">                -t <span class="variable">$(IMAGE_REPO)</span>:<span class="variable">$(IMAGE_VERSION)</span> \</span><br><span class="line">                -f ./Dockfile.buildx --push .</span><br></pre></td></tr></table></figure><h2 id="验证镜像"><a href="#验证镜像" class="headerlink" title="验证镜像"></a>验证镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 拉去镜像到本地</span><br><span class="line">$ docker pull hub.easystack.cn/multi/buildx-demo:v0.0.1</span><br><span class="line"></span><br><span class="line">// 查看镜像信息</span><br><span class="line">$ docker manifest inspect hub.easystack.cn/multi/buildx-demo:v0.0.1</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;schemaVersion&quot;</span>: 2,</span><br><span class="line">   <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.list.v2+json&quot;</span>,</span><br><span class="line">   <span class="string">&quot;manifests&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: 701,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:7d95c40e65abaa83c9d1a2e462026070f43f7ceaacba57f3c6a70fb840bcd196&quot;</span>,</span><br><span class="line">         <span class="string">&quot;platform&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;architecture&quot;</span>: <span class="string">&quot;amd64&quot;</span>,</span><br><span class="line">            <span class="string">&quot;os&quot;</span>: <span class="string">&quot;linux&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: 701,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:ff6b7d6df4241220f9c1f665864e7f009620a8c39edecf3b8463a62d01c6f228&quot;</span>,</span><br><span class="line">         <span class="string">&quot;platform&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;architecture&quot;</span>: <span class="string">&quot;arm64&quot;</span>,</span><br><span class="line">            <span class="string">&quot;os&quot;</span>: <span class="string">&quot;linux&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h1><h2 id="manifest是什么，干什么用？"><a href="#manifest是什么，干什么用？" class="headerlink" title="manifest是什么，干什么用？"></a>manifest是什么，干什么用？</h2><p>manifest是一个文件，这个文件包含了有关于镜像信息，如层、大小和摘要。docker manifest命令还向用户提供附加信息，比如构建镜像的操作系统和体系结构。而manifest list是一个镜像清单列表，用于存放多个不同os/arch的镜像信息。我们可以创建一个manifest list来指向两个镜像(一个linux 64位和一个指向arm64位的镜像)，然后对用户提供一个唯一的镜像名称。<strong>从Docker registry v2.3和Docker 1.10 开始，Docker hub就可以pull multi architecture Docker镜像了。</strong></p><p><strong>一个镜像的manifest文件信息如下：</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker manifest inspect java</span><br><span class="line">&#123;</span><br><span class="line">        <span class="string">&quot;schemaVersion&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;config&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.container.image.v1+json&quot;</span>,</span><br><span class="line">                <span class="string">&quot;size&quot;</span>: <span class="number">4733</span>,</span><br><span class="line">                <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:d23bdf5b1b1b1afce5f1d0fd33e7ed8afbc084b594b9ccf742a5b27080d8a4a8&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;layers&quot;</span>: [ #---镜像层的摘要信息</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;size&quot;</span>: <span class="number">51361210</span>,</span><br><span class="line">                        <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:5040bd2983909aa8896b9932438c3f1479d25ae837a5f6220242a264d0221f2d&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">...................</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个manifest list的例子如下：</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;schemaVersion&quot;</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.list.v2+json&quot;</span>,</span><br><span class="line">   <span class="string">&quot;manifests&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: <span class="number">1357</span>,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:9b47044b1e79b965a8e1653e7f9c04b5f63e00b9161bedd5baef69bb8b4c4834&quot;</span>,</span><br><span class="line">         <span class="string">&quot;platform&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;architecture&quot;</span>: <span class="string">&quot;amd64&quot;</span>,</span><br><span class="line">            <span class="string">&quot;os&quot;</span>: <span class="string">&quot;linux&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">&quot;mediaType&quot;</span>: <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,</span><br><span class="line">         <span class="string">&quot;size&quot;</span>: <span class="number">1357</span>,</span><br><span class="line">         <span class="string">&quot;digest&quot;</span>: <span class="string">&quot;sha256:8aecae775e1f81d3889929ef15647187b414c833b0798d060bfd778bee668ced&quot;</span>,</span><br><span class="line">         <span class="string">&quot;platform&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;architecture&quot;</span>: <span class="string">&quot;arm64&quot;</span>,</span><br><span class="line">            <span class="string">&quot;os&quot;</span>: <span class="string">&quot;linux&quot;</span>,</span><br><span class="line">            <span class="string">&quot;variant&quot;</span>: <span class="string">&quot;v8&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：manifest的功能目前仅仅作用于docker 官方的镜像仓库。</strong></p><p>总结：简单的说manifest list就是多个manifest的一个集合，通过列表方式来管理。</p><h2 id="manifest-list处理流程："><a href="#manifest-list处理流程：" class="headerlink" title="manifest list处理流程："></a>manifest list处理流程：</h2><img src="/2023/02/27/09/1676966412440-973b407a-131f-48d2-a414-1d2e0efec236.png" class="" title="img"><img src="/2023/02/27/09/1676966412789-274aaf7c-7f07-43c8-9479-171a5fc0a048.png" class="" title="img"><h2 id="开启docker子命令manifest功能："><a href="#开启docker子命令manifest功能：" class="headerlink" title="开启docker子命令manifest功能："></a>开启docker子命令manifest功能：</h2><p>manifest是做为docker客户端的子命令存在，不过这个子命令目前处在实验性中一般没有开启。我们需要手动开始这个子命令的功能。开启过程如下：</p><h3 id="编辑config-json"><a href="#编辑config-json" class="headerlink" title="编辑config.json"></a>编辑config.json</h3><p>docker 的默认配置文件config.json是在$HOME目录下的.docker目录下。编辑config.json文件，若目录和文件不存在手动创建。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim ~/.docker/config.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;experimental&quot;</span>: <span class="string">&quot;enabled&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编辑daemon-json"><a href="#编辑daemon-json" class="headerlink" title="编辑daemon.json"></a>编辑daemon.json</h3><p>编辑daemon.json，若目录和文件不存在手动创建</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;experimental&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br><span class="line">$ docker manifest --<span class="built_in">help</span>    <span class="comment">#----查看manifest帮助信息</span></span><br></pre></td></tr></table></figure><p>开启docker的实验性功能后docker pull可以拉取指定平台镜像如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull --platform arm64  镜像 --platform：该参数是用于拉取指定平台的镜像，也是实验性功能，在上面步骤中开启后就会出现。通 过该参数可以手动指定需要的CPU平台镜像，而不用自动去识别。</span><br></pre></td></tr></table></figure><h2 id="使用manifest创建多CPU架构的镜像："><a href="#使用manifest创建多CPU架构的镜像：" class="headerlink" title="使用manifest创建多CPU架构的镜像："></a>使用manifest创建多CPU架构的镜像：</h2><p>查看一个镜像的manifest文件信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest inspect nginx</span><br></pre></td></tr></table></figure><p>查看一个镜像的manifest文件的详细信息，包括cpu平台架构等信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest inspect --verbose nginx</span><br></pre></td></tr></table></figure><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>这里准备好了两个不同CPU架构的镜像如下：<br>这里的镜像是自己在docker hub上创建的仓库<br>xxx/public_docker:nginx-arm64<br>xxx/public_docker:nginx-x86<br><strong>必须将上面两个镜像推到docker hub上面</strong></p><h3 id="创建一个manifest-list列表："><a href="#创建一个manifest-list列表：" class="headerlink" title="创建一个manifest list列表："></a>创建一个manifest list列表：</h3><p>创建一个自定义命名的镜像名的manifest list，然后用该列表关联仓库里面的两个不同架构的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest create xxx/public_docker:nginx-v1 xxx/public_docker:nginx-arm64 xxx/public_docker:nginx-x86</span><br></pre></td></tr></table></figure><h3 id="docker-manifest-annotate-注释manifest-list"><a href="#docker-manifest-annotate-注释manifest-list" class="headerlink" title="docker manifest annotate 注释manifest list"></a>docker manifest annotate 注释manifest list</h3><p>我们按照上述方法创建出来的 manifest list 中并没有说明其中的 manifest 是什么操作系统和平台的，<code>docker manifest annotate</code> 命令用于注释创建出来的 manifest list。例如注释某个 manifest 是 <code>linxu</code>系统 <code>arm64</code> 平台的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest annotate xxx/public_docker:nginx-v1 xxx/public_docker:nginx-x86 –os linux –<span class="built_in">arch</span> amd64</span><br><span class="line">$ docker manifest annotate xxx/public_docker:nginx-v1 xxx/public_docker:nginx-arm64 –os linux –<span class="built_in">arch</span> arm64</span><br></pre></td></tr></table></figure><h3 id="将创建好的manifest-list-推到仓库中："><a href="#将创建好的manifest-list-推到仓库中：" class="headerlink" title="将创建好的manifest list 推到仓库中："></a>将创建好的manifest list 推到仓库中：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest push xxx/public_docker:nginx-v1</span><br></pre></td></tr></table></figure><h3 id="查看仓库中创建好的manifest-list："><a href="#查看仓库中创建好的manifest-list：" class="headerlink" title="查看仓库中创建好的manifest list："></a>查看仓库中创建好的manifest list：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker manifest inspect xxx/public_docker:nginx-v1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;构建多架构镜像的方法有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;manifest&lt;/li&gt;
&lt;li&gt;docker buildx&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;buildx&quot;&gt;&lt;a href=&quot;#buildx&quot; class=&quot;headerlink&quot; title=&quot;buildx</summary>
      
    
    
    
    <category term="镜像" scheme="http://lizhewei91.github.io/categories/%E9%95%9C%E5%83%8F/"/>
    
    
    <category term="buildx" scheme="http://lizhewei91.github.io/tags/buildx/"/>
    
    <category term="manifest" scheme="http://lizhewei91.github.io/tags/manifest/"/>
    
  </entry>
  
  <entry>
    <title>在k8s中，实现应用配置文件热更新</title>
    <link href="http://lizhewei91.github.io/2023/02/10/44/"/>
    <id>http://lizhewei91.github.io/2023/02/10/44/</id>
    <published>2023-02-10T08:32:44.000Z</published>
    <updated>2023-06-01T09:02:14.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前，在k8s部署的工作负载使用 <code>ConfigMap</code> 或 <code>Secret</code>时，通过两种方式：</p><ul><li>环境变量 Env 方式挂载</li><li>文件方式挂载</li></ul><p>当更新 <code>ConfigMap </code>或 <code>Secret</code> 时，挂载到Pod中的数据存在两种情况：</p><ul><li>Env 方式挂载的环境变量不会同步更新</li><li>文件方式挂载的数据会同步更新（存在秒级延时）</li></ul><p>大部分场景下，在更新了 <code>ConfigMap</code> 或 <code>Secret</code> 中的信息后，都希望Pod内业务能读取到最新的值。通常都会手动去滚动更新一下Pod，重新读取环境变量或文件内容。当前社区已经有对应的开源工具 <a href="https://github.com/stakater/Reloader">Reloader</a> 实现了 <code>ConfigMap</code>/<code>Secret</code> 更新时自动触发Pod的滚动更新。</p><h1 id="Reloader介绍"><a href="#Reloader介绍" class="headerlink" title="Reloader介绍"></a>Reloader介绍</h1><p>Reloader 通过 watch <code>ConfigMap</code> 和 <code>Secret</code> 中的变化，对 <code>Deployment</code>、 <code>DaemonSet</code> 和 <code>StatefulSet</code> 等负载的 <code>Pod</code> 进行滚动升级。</p><p>官方文档：<a href="https://github.com/stakater/Reloader">Reloader</a></p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>Reloader 兼容的 K8s 版本为 &gt;=1.9。</p><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><p>以下使用Deployment举例：</p><ul><li>Deployment 中使用的所有 ConfigMap 和 Secret 变动都会触发 Pod 滚动更新</li></ul><p>在Deployment 的 <code>metadata.annotations</code> 中添加 <code>reloader.stakater.com/auto: &quot;true&quot;</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    reloader.stakater.com/<span class="keyword">auto</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="keyword">template</span>:</span><br></pre></td></tr></table></figure><ul><li>Deployment 中的部分 ConfigMap 和 Secret 变动会触发 Pod 滚动更新</li></ul><p>在 Deployment 的 <code>metadata.annotations</code>中添加<code>reloader.stakater.com/search: &quot;true&quot;</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    reloader.stakater.com/search: <span class="string">&quot;true&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="keyword">template</span>:</span><br></pre></td></tr></table></figure><p>同时在需要触发 Pod 更新的 ConfigMap 或 Secret 中的 <code>metadata.annotations</code>中添加 <code>reloader.stakater.com/match: &quot;true&quot;</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    reloader.stakater.com/match: <span class="string">&quot;true&quot;</span></span><br><span class="line">data:</span><br><span class="line">  key: <span class="keyword">value</span></span><br></pre></td></tr></table></figure><ul><li>Deployment 中指定 ConfigMap 或 Secret 的变动触发 Pod 滚动更新</li></ul><p>在Deployment 的 <code>metadata.annotations</code>中添加 <code>configmap.reloader.stakater.com/reload: &quot;foo-configmap,bar-configmap,baz-configmap&quot;</code>，指定这些 ConfigMap 才会触发 Pod 的更新。多个 ConfigMap 使用逗号分隔</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    configmap.reloader.stakater.com/reload: <span class="string">&quot;foo-configmap,bar-configmap,baz-configmap&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="keyword">template</span>: </span><br><span class="line">    metadata:</span><br></pre></td></tr></table></figure><p>在Deployment 的 <code>metadata.annotations</code> 中添加 <code>secret.reloader.stakater.com/reload: &quot;foo-secret,bar-secret,baz-secret&quot;</code>，指定这些 Secret 才会触发 Pod 的更新。多个 Secret 使用逗号分隔</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    secret.reloader.stakater.com/reload: <span class="string">&quot;foo-secret,bar-secret,baz-secret&quot;</span></span><br><span class="line">spec:</span><br><span class="line">  <span class="keyword">template</span>: </span><br><span class="line">    metadata:</span><br></pre></td></tr></table></figure><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><ul><li>忽略 ConfigMap 或 Secret 变动（<strong>全局</strong>）</li></ul><p>在 Reloader deployment的 <code>spec.template.spec.container.args</code> 中添加参数：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>–resources-to-ignore=configMaps</td><td>忽略 configMaps 变动</td></tr><tr><td>–resources-to-ignore=secrets</td><td>忽略 secrets 变动</td></tr></tbody></table><p><code>--resources-to-ignore</code>参数只支持忽略一种资源，若要同时忽略 configMaps 和 secrets 的变动，则只需要把 Reloader 副本数降为0。</p><ul><li>通过使用 <code>--namespace-selector</code> 参数，Reloader可以配置为只监视带有(一个或多个)标签的命名空间，例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--namespace-selector=reloder:enabled,test:true</span><br></pre></td></tr></table></figure><p>只有标记为如下命名空间 YAML 的命名空间才会被监视：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kind: Namespace</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  ...</span><br><span class="line">  labels:</span><br><span class="line">    reloder: enabled</span><br><span class="line">    test: true</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>如果您只想通过标签的键选择命名空间，请使用 <code>&quot;*&quot;</code> 作为值。例如，对于 <code>--namespace-selector=select-this:*</code> 所有标签键为<code>&quot;select-this&quot;</code>的命名空间将被选中，而不管标签的值是多少。</p><h1 id="实战验证"><a href="#实战验证" class="headerlink" title="实战验证"></a>实战验证</h1><h2 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h2><ol><li>创建一个测试 namespace</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create ns ns1</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 reloader</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/stakater/Reloader/master/deployments/kubernetes/reloader.yaml</span><br></pre></td></tr></table></figure><ol start="3"><li>创建configmap</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-config-file</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ns1</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line"><span class="comment">#    reloader.stakater.com/match: &quot;true&quot;</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">info.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    user=lzw</span></span><br><span class="line"><span class="string">    age=30</span></span><br><span class="line"><span class="string"></span><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-config-env</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ns1</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line"><span class="comment">#    reloader.stakater.com/match: &quot;true&quot;</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">COUNTRY:</span> <span class="string">china</span></span><br><span class="line">  <span class="attr">CITY:</span> <span class="string">beijing</span></span><br></pre></td></tr></table></figure><ol start="4"><li>创建 deployment</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ns1</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line"><span class="comment">#    configmap.reloader.stakater.com/reload: &quot;test-config-file&quot;</span></span><br><span class="line"><span class="comment">#    reloader.stakater.com/search: &quot;true&quot;</span></span><br><span class="line">     <span class="attr">reloader.stakater.com/auto:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="comment"># Define the environment variable</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">COUNTRY</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">test-config-env</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">COUNTRY</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CITY</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">configMapKeyRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">test-config-env</span></span><br><span class="line">                <span class="attr">key:</span> <span class="string">CITY</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">&quot;/etc/foo&quot;</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">test-config-file</span></span><br></pre></td></tr></table></figure><h2 id="Reloader功能验证"><a href="#Reloader功能验证" class="headerlink" title="Reloader功能验证"></a>Reloader功能验证</h2><ol><li>更新 configmap（以文件方式挂载）</li></ol><p>使用命令 <code>kubectl -nns1 edit cm test-config-file</code> 编辑configmap，设置 <code>user</code> 的值为 <code>ted</code>。查看pod已经滚动更新。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ kubectl edit cm -n ns1 test-config-file</span><br><span class="line">configmap/test-config-file edited</span><br><span class="line">➜ kubectl get pods -n ns1</span><br><span class="line">NAME                     READY   STATUS              RESTARTS   AGE</span><br><span class="line">nginx-5dff48f5dd-m528h   0/1     ContainerCreating   0          6s</span><br><span class="line">nginx-6f455f8cd5-9h7pp   1/1     Running             0          34m</span><br></pre></td></tr></table></figure><p>查看新启动 pod 中 configmap 所挂载的文件内容，发现 <code>user</code> 的值已经变为 <code>lzw-test</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ kubectl <span class="built_in">exec</span> -it nginx-5dff48f5dd-m528h  -nns1 -- <span class="built_in">cat</span> /etc/foo/info.yaml</span><br><span class="line">user=lzw-test</span><br><span class="line">age=30</span><br></pre></td></tr></table></figure><ol start="2"><li>更新 configmap（以环境变量方式注入）</li></ol><p>使用命令 <code>kubectl -nns1edit cm test-config-env</code> 编辑 configmap，设置 <code>CITY</code> 的值为 <code>shenzhen</code>。查看 pod 已经滚动更新。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ kubectl edit cm -n ns1 test-config-env</span><br><span class="line">configmap/test-config-env edited</span><br><span class="line">➜ kubectl get pods -n ns1</span><br><span class="line">NAME                     READY   STATUS              RESTARTS   AGE</span><br><span class="line">nginx-5b4cb86669-9cv6k   0/1     ContainerCreating   0          6s</span><br><span class="line">nginx-5dff48f5dd-m528h   1/1     Running             0          9m35s</span><br></pre></td></tr></table></figure><p>查看新启动 pod 中 configmap 所注入的环境变量，发现 <code>CITY</code> 的值已经变为 <code>shenzhen</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ kubectl <span class="built_in">exec</span> -it nginx-5b4cb86669-9cv6k -nns1 -- <span class="built_in">env</span>|grep CITY</span><br><span class="line">CITY=shenzhen</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>Reloader 自动触发滚动更新，可能会导致业务中断。使用该功能时需要评估 pod 滚动更新对业务带来的影响。</p></li><li><p><code>reloader.stakater.com/auto</code>的优先级高于 <code>reloader.stakater.com/search</code>。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;目前，在k8s部署的工作负载使用 &lt;code&gt;ConfigMap&lt;/code&gt; 或 &lt;code&gt;Secret&lt;/code&gt;时，通过两种方式：</summary>
      
    
    
    
    <category term="reloader" scheme="http://lizhewei91.github.io/categories/reloader/"/>
    
    
    <category term="reloader" scheme="http://lizhewei91.github.io/tags/reloader/"/>
    
    <category term="configMap" scheme="http://lizhewei91.github.io/tags/configMap/"/>
    
    <category term="secret" scheme="http://lizhewei91.github.io/tags/secret/"/>
    
  </entry>
  
  <entry>
    <title>用插件扩展 kubectl</title>
    <link href="http://lizhewei91.github.io/2023/02/10/25/"/>
    <id>http://lizhewei91.github.io/2023/02/10/25/</id>
    <published>2023-02-10T06:48:25.000Z</published>
    <updated>2023-06-01T09:10:18.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="krew"><a href="#krew" class="headerlink" title="krew"></a>krew</h1><h2 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h2><ol><li>你需要安装一个可用的 <code>kubectl</code> 可执行文件。</li></ol><h2 id="安装-krew"><a href="#安装-krew" class="headerlink" title="安装 krew"></a>安装 krew</h2><p>官方文档：<a href="https://krew.sigs.k8s.io/docs/user-guide/">https://krew.sigs.k8s.io/docs/user-guide/</a></p><p>安装 krew 插件管理器。Krew 是一个由 Kubernetes SIG CLI 社区维护的插件管理器。</p><ol><li><p>Make sure that <code>git</code> is installed.</p></li><li><p>Run this command to download and install <code>krew</code>:</p></li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(</span><br><span class="line">  <span class="built_in">set</span> -x; <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(mktemp -d)</span>&quot;</span> &amp;&amp;</span><br><span class="line">  OS=<span class="string">&quot;<span class="subst">$(uname | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)</span>&quot;</span> &amp;&amp;</span><br><span class="line">  ARCH=<span class="string">&quot;<span class="subst">$(uname -m | sed -e &#x27;s/x86_64/amd64/&#x27; -e &#x27;s/\(arm\)\(64\)\?.*/\1\2/&#x27; -e &#x27;s/aarch64$/arm64/&#x27;)</span>&quot;</span> &amp;&amp;</span><br><span class="line">  KREW=<span class="string">&quot;krew-<span class="variable">$&#123;OS&#125;</span>_<span class="variable">$&#123;ARCH&#125;</span>&quot;</span> &amp;&amp;</span><br><span class="line">  curl -fsSLO <span class="string">&quot;https://github.com/kubernetes-sigs/krew/releases/latest/download/<span class="variable">$&#123;KREW&#125;</span>.tar.gz&quot;</span> &amp;&amp;</span><br><span class="line">  tar zxvf <span class="string">&quot;<span class="variable">$&#123;KREW&#125;</span>.tar.gz&quot;</span> &amp;&amp;</span><br><span class="line">  ./<span class="string">&quot;<span class="variable">$&#123;KREW&#125;</span>&quot;</span> install krew</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="3"><li>Add the <code>$HOME/.krew/bin</code> directory to your PATH environment variable. To do this, update your <code>.bashrc</code> or <code>.zshrc</code> file and append the following line:</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$&#123;KREW_ROOT:-<span class="variable">$HOME</span>/.krew&#125;</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure><p>and restart your shell.</p><ol start="4"><li>Run <code>kubectl krew</code> to check the installation.</li></ol><h2 id="编写-kubectl-插件"><a href="#编写-kubectl-插件" class="headerlink" title="编写 kubectl 插件"></a>编写 kubectl 插件</h2><p>你可以用任何编程语言或脚本编写插件，允许你编写命令行命令。</p><p>不需要安装插件或预加载，插件可执行程序从 <code>kubectl</code> 二进制文件接收继承的环境， 插件根据其名称确定它希望实现的命令路径。 例如，名为 <code>kubectl-foo</code> 的插件提供了命令 <code>kubectl foo</code>。 必须将插件的可执行文件安装在 <code>PATH</code> 中的某个位置。</p><h3 id="示例插件"><a href="#示例插件" class="headerlink" title="示例插件"></a>示例插件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的参数处理</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;version&quot;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的参数处理</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;config&quot;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$KUBECONFIG</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I am a plugin named kubectl-foo&quot;</span></span><br></pre></td></tr></table></figure><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>要使用某插件，先要使其可执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">chmod</span> +x ./kubectl-foo</span><br></pre></td></tr></table></figure><p>并将它放在你的 <code>PATH</code> 中的任何地方：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">mv</span> ./kubectl-foo /usr/local/bin</span><br></pre></td></tr></table></figure><p>你现在可以调用你的插件作为 <code>kubectl</code> 命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl foo</span><br><span class="line"></span><br><span class="line">I am a plugin named kubectl-foo</span><br></pre></td></tr></table></figure><p>所有参数和标记按原样传递给可执行文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl foo version</span><br><span class="line"></span><br><span class="line">1.0.0</span><br></pre></td></tr></table></figure><p>所有环境变量也按原样传递给可执行文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ KUBECONFIG=/etc/kube/config kubectl foo config</span><br><span class="line"></span><br><span class="line">/etc/kube/config</span><br></pre></td></tr></table></figure><p>此外，传递给插件的第一个参数总是调用它的位置的绝对路径（在上面的例子中，<code>$0</code> 将等于 <code>/usr/local/bin/kubectl-foo</code>）。</p><h3 id="查看插件列表"><a href="#查看插件列表" class="headerlink" title="查看插件列表"></a>查看插件列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl plugin list</span><br><span class="line"></span><br><span class="line">The following compatible plugins are available:</span><br><span class="line"></span><br><span class="line">/root/.krew/bin/kubectl-krew</span><br><span class="line">/usr/local/bin/kubectl-foo           // kubectl-foo 为新添加的插件</span><br></pre></td></tr></table></figure><h2 id="分发-kubectl-插件"><a href="#分发-kubectl-插件" class="headerlink" title="分发 kubectl 插件"></a>分发 kubectl 插件</h2><p>参考：<a href="https://kubernetes.io/zh-cn/docs/tasks/extend-kubectl/kubectl-plugins/#%E5%88%86%E5%8F%91-kubectl-%E6%8F%92%E4%BB%B6">分发kubectl插件</a></p><h2 id="krew-相关命令"><a href="#krew-相关命令" class="headerlink" title="krew 相关命令"></a>krew 相关命令</h2><ol><li>升级</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl krew update</span><br></pre></td></tr></table></figure><ol start="2"><li>查看可用插件列表</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl krew search</span><br><span class="line"></span><br><span class="line">NAME             DESCRIPTION                                         INSTALLED</span><br><span class="line">access-matrix    Show an RBAC access matrix <span class="keyword">for</span> server resources     no</span><br><span class="line">advise-psp       Suggests PodSecurityPolicies <span class="keyword">for</span> cluster.           no</span><br><span class="line">auth-proxy       Authentication proxy to a pod or service            no</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="3"><li>关键字搜索</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl krew search pod</span><br><span class="line"></span><br><span class="line">NAME                DESCRIPTION                                         INSTALLED</span><br><span class="line">evict-pod           Evicts the given pod                                no</span><br><span class="line">pod-dive            Shows a pod<span class="string">&#x27;s workload tree and info inside a node  no</span></span><br><span class="line"><span class="string">pod-logs            Display a list of pods to get logs from             no</span></span><br><span class="line"><span class="string">pod-shell           Display a list of pods to execute a shell in        no</span></span><br></pre></td></tr></table></figure><ol start="4"><li>查看插件详情</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl krew info tree</span><br><span class="line"></span><br><span class="line">NAME: tree</span><br><span class="line">VERSION: v0.4.0</span><br><span class="line">DESCRIPTION:</span><br><span class="line">  This plugin shows sub-resources of a specified Kubernetes API object <span class="keyword">in</span> a</span><br><span class="line">  tree view <span class="keyword">in</span> the command-line. The parent-child relationship is discovered</span><br><span class="line">  using ownerReferences on the child object.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;krew&quot;&gt;&lt;a href=&quot;#krew&quot; class=&quot;headerlink&quot; title=&quot;krew&quot;&gt;&lt;/a&gt;krew&lt;/h1&gt;&lt;h2 id=&quot;准备开始&quot;&gt;&lt;a href=&quot;#准备开始&quot; class=&quot;headerlink&quot; title=&quot;准备开始&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="kubectl 插件" scheme="http://lizhewei91.github.io/categories/kubectl-%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="kubectl-plugins" scheme="http://lizhewei91.github.io/tags/kubectl-plugins/"/>
    
    <category term="krew" scheme="http://lizhewei91.github.io/tags/krew/"/>
    
  </entry>
  
  <entry>
    <title>kubelet-device-manager 源码分析</title>
    <link href="http://lizhewei91.github.io/2023/01/16/19/"/>
    <id>http://lizhewei91.github.io/2023/01/16/19/</id>
    <published>2023-01-16T06:24:19.000Z</published>
    <updated>2023-06-01T09:02:31.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建-DeviceManager"><a href="#创建-DeviceManager" class="headerlink" title="创建 DeviceManager"></a>创建 DeviceManager</h1><p>Device Manager 和 cgroup Manager、QoS Container Manager 等一样，都属于 kubelet 管理的众多 Manager 之一。Device Manager在 kubelet 启动时的 NewContainerManager 中创建。</p><p><u><em>kubernetes/pkg/kubelet/cm/container_manager_linux.go#198</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContainerManager</span><span class="params">(mountUtil mount.Interface, cadvisorInterface cadvisor.Interface, nodeConfig NodeConfig, failSwapOn <span class="type">bool</span>, devicePluginEnabled <span class="type">bool</span>, recorder record.EventRecorder)</span></span> (ContainerManager, <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">cm := &amp;containerManagerImpl&#123;</span><br><span class="line">cadvisorInterface:   cadvisorInterface,</span><br><span class="line">mountUtil:           mountUtil,</span><br><span class="line">NodeConfig:          nodeConfig,</span><br><span class="line">subsystems:          subsystems,</span><br><span class="line">cgroupManager:       cgroupManager,</span><br><span class="line">capacity:            capacity,</span><br><span class="line">internalCapacity:    internalCapacity,</span><br><span class="line">cgroupRoot:          cgroupRoot,</span><br><span class="line">recorder:            recorder,</span><br><span class="line">qosContainerManager: qosContainerManager,</span><br><span class="line">&#125;</span><br><span class="line">... </span><br><span class="line">klog.InfoS(<span class="string">&quot;Creating device plugin manager&quot;</span>, <span class="string">&quot;devicePluginEnabled&quot;</span>, devicePluginEnabled)</span><br><span class="line"><span class="keyword">if</span> devicePluginEnabled &#123;</span><br><span class="line">cm.deviceManager, err = devicemanager.NewManagerImpl(machineInfo.Topology, cm.topologyManager)</span><br><span class="line">cm.topologyManager.AddHintProvider(cm.deviceManager)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cm.deviceManager, err = devicemanager.NewManagerStub()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">return</span> cm, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ManagerImpl结构体"><a href="#ManagerImpl结构体" class="headerlink" title="ManagerImpl结构体"></a>ManagerImpl结构体</h2><p>我们有必要先了解 Device Manager 的结构体：</p><p><u><em>kubernetes/pkg/kubelet/cm/devicemanager/manager.go#57</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ManagerImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">checkpointdir <span class="type">string</span></span><br><span class="line"></span><br><span class="line">endpoints <span class="keyword">map</span>[<span class="type">string</span>]endpointInfo <span class="comment">// Key is ResourceName</span></span><br><span class="line">mutex     sync.Mutex</span><br><span class="line"></span><br><span class="line">server plugin.Server</span><br><span class="line"></span><br><span class="line"><span class="comment">// activePods is a method for listing active pods on the node</span></span><br><span class="line"><span class="comment">// so the amount of pluginResources requested by existing pods</span></span><br><span class="line"><span class="comment">// could be counted when updating allocated devices</span></span><br><span class="line">activePods ActivePodsFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// sourcesReady provides the readiness of kubelet configuration sources such as apiserver update readiness.</span></span><br><span class="line"><span class="comment">// We use it to determine when we can purge inactive pods from checkpointed state.</span></span><br><span class="line">sourcesReady config.SourcesReady</span><br><span class="line"></span><br><span class="line"><span class="comment">// allDevices holds all the devices currently registered to the device manager</span></span><br><span class="line">allDevices ResourceDeviceInstances</span><br><span class="line"></span><br><span class="line"><span class="comment">// healthyDevices contains all of the registered healthy resourceNames and their exported device IDs.</span></span><br><span class="line">healthyDevices <span class="keyword">map</span>[<span class="type">string</span>]sets.String</span><br><span class="line"></span><br><span class="line"><span class="comment">// unhealthyDevices contains all of the unhealthy devices and their exported device IDs.</span></span><br><span class="line">unhealthyDevices <span class="keyword">map</span>[<span class="type">string</span>]sets.String</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocatedDevices contains allocated deviceIds, keyed by resourceName.</span></span><br><span class="line">allocatedDevices <span class="keyword">map</span>[<span class="type">string</span>]sets.String</span><br><span class="line"></span><br><span class="line"><span class="comment">// podDevices contains pod to allocated device mapping.</span></span><br><span class="line">podDevices        *podDevices</span><br><span class="line">checkpointManager checkpointmanager.CheckpointManager</span><br><span class="line"></span><br><span class="line"><span class="comment">// List of NUMA Nodes available on the underlying machine</span></span><br><span class="line">numaNodes []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Store of Topology Affinties that the Device Manager can query.</span></span><br><span class="line">topologyAffinityStore topologymanager.Store</span><br><span class="line"></span><br><span class="line"><span class="comment">// devicesToReuse contains devices that can be reused as they have been allocated to</span></span><br><span class="line"><span class="comment">// init containers.</span></span><br><span class="line">devicesToReuse PodReusableDevices</span><br><span class="line"></span><br><span class="line"><span class="comment">// pendingAdmissionPod contain the pod during the admission phase</span></span><br><span class="line">pendingAdmissionPod *v1.Pod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是核心字段 的说明：</p><ul><li><p><strong>checkpointdir：</strong>kubelet对外暴露的socket文件，/var/lib/kubelet/device-plugins/kubelet.sock</p></li><li><p><strong>endpoints：</strong>map对象，key 为 Resource Name，value 为 endpoint 接口( 包括 getPreferredAllocation、allocate、preStartContainer、setStopTime、isStopped、stopGracePeriodExpired )，每个 endpoint 接口对应一个已注册的 device plugin，负责与 device plugin 的 gRPC 通信及缓存 device plugin 反馈的 device states。</p></li><li><p><strong>server：</strong>暴漏一个 gRPC 服务。</p></li><li><p><strong>activePods：</strong>用来获取该节点上所有 active pods，即 non-Terminated 状态的 Pods。在 kubelet 的initializeRuntimeDependentModules 时会注册 activePods Func 为如下函数</p></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> GetActivePods() []*v1.Pod &#123;</span><br><span class="line">allPods := kl.podManager.GetPods()</span><br><span class="line">activePods := kl.filterOutInactivePods(allPods)</span><br><span class="line"><span class="keyword">return</span> activePods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>allDevices：</strong>保存当前注册到设备管理器的所有设备</p></li><li><p> <strong>healthyDevices:</strong> map对象，key为 Resource Name，value为对应的健康的 device IDs。 </p></li><li><p> **unhealthyDevices: **map对象，key为 Resource Name，value为对应的不健康的 device IDs。</p></li><li><p><strong>allocatedDevices:</strong>  map对象，key为Resource Name，value为已经分配出去的device IDs。</p></li><li><p><strong>podDevices：</strong>记录每一个pod中每个容器的设备分配情况</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建-DeviceManager&quot;&gt;&lt;a href=&quot;#创建-DeviceManager&quot; class=&quot;headerlink&quot; title=&quot;创建 DeviceManager&quot;&gt;&lt;/a&gt;创建 DeviceManager&lt;/h1&gt;&lt;p&gt;Device Manager</summary>
      
    
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/categories/kubelet/"/>
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/tags/kubelet/"/>
    
    <category term="device-manager" scheme="http://lizhewei91.github.io/tags/device-manager/"/>
    
  </entry>
  
  <entry>
    <title>kubelet 工作原理分析</title>
    <link href="http://lizhewei91.github.io/2023/01/11/14/"/>
    <id>http://lizhewei91.github.io/2023/01/11/14/</id>
    <published>2023-01-11T11:32:14.000Z</published>
    <updated>2023-06-01T09:01:31.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。</p><h1 id="kubelet-主要功能"><a href="#kubelet-主要功能" class="headerlink" title="kubelet 主要功能"></a>kubelet 主要功能</h1><p>kubelet 默认监听四个端口，分别为 10250 、10255、10248、4194。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LISTEN     0      128          *:10250           *:*                   users ((&quot;kubelet&quot;,pid=48500,fd=28))</span><br><span class="line">LISTEN     0      128          *:10255           *:*                   users:((&quot;kubelet&quot;,pid=48500,fd=26))</span><br><span class="line">LISTEN     0      128          *:4194            *:*                   users:((&quot;kubelet&quot;,pid=48500,fd=13))</span><br><span class="line">LISTEN     0      128    127.0.0.1:10248         *:*                   users:((&quot;kubelet&quot;,pid=48500,fd=23))</span><br></pre></td></tr></table></figure><ul><li><p><strong>10250（kubelet API）</strong>：kubelet server 与 apiserver 通信的端口，定期请求 apiserver 获取自己所应当处理的任务，通过该端口可以访问获取 node 资源以及状态。</p></li><li><p><strong>10248（健康检查端口）</strong>：通过访问该端口可以判断 kubelet 是否正常工作, 通过 kubelet 的启动参数 <code>--healthz-port</code> 和 <code>--healthz-bind-address</code> 来指定监听的地址和端口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:10248/healthz </span><br><span class="line">ok</span><br></pre></td></tr></table></figure></li><li><p><strong>4194（cAdvisor 监听）</strong>：kublet 通过该端口可以获取到该节点的环境信息以及 node 上运行的容器状态等内容，访问 <a href="http://localhost:4194/">http://localhost:4194</a> 可以看到 cAdvisor 的管理界面,通过 kubelet 的启动参数 <code>--cadvisor-port</code> 可以指定启动的端口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl  http://127.0.0.1:4194/metrics</span><br></pre></td></tr></table></figure></li><li><p><strong>10255 （readonly API</strong>）：提供了 pod 和 node 的信息，接口以只读形式暴露出去，访问该端口不需要认证和鉴权。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  获取 pod 的接口，与 apiserver 的 </span><br><span class="line">// http://127.0.0.1:8080/api/v1/pods?fieldSelector=spec.nodeName=  接口类似</span><br><span class="line">$ curl  http://127.0.0.1:10255/pods</span><br><span class="line"></span><br><span class="line">// 节点信息接口,提供磁盘、网络、CPU、内存等信息</span><br><span class="line">$ curl http://127.0.0.1:10255/spec/</span><br></pre></td></tr></table></figure></li></ul><h2 id="pod管理"><a href="#pod管理" class="headerlink" title="pod管理"></a>pod管理</h2><p>Kubelet 以 PodSpec 的方式工作。PodSpec 是描述一个 Pod 的 YAML 或 JSON 对象。 kubelet 采用一组通过各种机制提供的 PodSpecs（主要通过 apiserver），并确保这些 PodSpecs 中描述的 Pod 正常健康运行。</p><p>官方提供了3种方式来获取容器信息：</p><ul><li>apiserver：通过 API Server 监听 etcd 目录获取数据；</li><li>File：启动参数 –config 指定的配置目录下的文件；</li><li>通过 url 从网络上某个地址来获取信息</li></ul><p>拿apiserver来说，如果Kubelet 监听到etcd中有新的绑定到本节点的 Pod，则按照 Pod 清单的要求创建该 Pod；如果发现本地的 Pod 被修改，则 Kubelet 会做出相应的修改。</p><h2 id="容器健康检查"><a href="#容器健康检查" class="headerlink" title="容器健康检查"></a>容器健康检查</h2><p>容器健康检查这个我们在前面已经聊过，主要是通过LivenessProbe 与ReadinessProbe来判断容器是否健康。</p><ul><li>LivenessProbe ：用于判断容器是否健康，告诉 Kubelet 一个容器什么时候处于不健康的状态。如果 LivenessProbe 探针探测到容器不健康，则 Kubelet 将删除该容器，并根据容器的重启策略做相应的处理。如果一个容器不包含 LivenessProbe 探针，那么 Kubelet 认为该容器的 LivenessProbe 探针返回的值永远是 “Success”；</li><li>ReadinessProbe：用于判断容器是否启动完成且准备接收请求。如果 ReadinessProbe 探针探测到失败，则 Pod 的状态将被修改。Endpoint Controller 将从 Service 的 Endpoint 中删除包含该容器所在 Pod 的 IP 地址的 Endpoint 条目。</li></ul><h2 id="容器监控"><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h2><p>Kubelet 通过 cAdvisor 获取其所在节点及容器的数据。cAdvisor 是一个开源的分析容器资源使用率和性能特性的代理工具，集成到 Kubelet中，当Kubelet启动时会同时启动cAdvisor，且一个cAdvisor只监控一个Node节点的信息。cAdvisor 自动查找所有在其所在节点上的容器，自动采集 CPU、内存、文件系统和网络使用的统计信息。cAdvisor 通过它所在节点机的 Root 容器，采集并分析该节点机的全面使用情况。</p><h1 id="kubelet组件中的模块"><a href="#kubelet组件中的模块" class="headerlink" title="kubelet组件中的模块"></a>kubelet组件中的模块</h1><img src="/2023/01/11/14/kubelet-8175571.png" class=""><h1 id="kubelet-工作原理"><a href="#kubelet-工作原理" class="headerlink" title="kubelet 工作原理"></a>kubelet 工作原理</h1><p>其实，kubelet也是按照“控制器”的模式来工作的，它的实际工作原理，可以用如下的一张图表示：</p><img src="/2023/01/11/14/1620.png" class="" title="img"><p>可以看到，kubelet的工作核心，就是一个控制循环，即: SyncLoop ( 图中的大圆圈 )。而驱动这个控制循环的事件，包括四种：</p><ol><li>Pod 更新事件</li><li>Pod 生命周期变化</li><li>kubelet 本身设置的执行周期</li><li>定时的清理事件</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器</summary>
      
    
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/categories/kubelet/"/>
    
    
    <category term="kubelet" scheme="http://lizhewei91.github.io/tags/kubelet/"/>
    
  </entry>
  
  <entry>
    <title>NVIDIA/kubevirt-gpu-device-plugin源码分析</title>
    <link href="http://lizhewei91.github.io/2023/01/10/32/"/>
    <id>http://lizhewei91.github.io/2023/01/10/32/</id>
    <published>2023-01-10T08:38:32.000Z</published>
    <updated>2023-06-01T09:01:56.564Z</updated>
    
    <content type="html"><![CDATA[<p>NVIDIA K8s Device Plugin为Kubevirt虚拟机分配gpu和vgpu，该篇文章基于NVIDIA/kubevirt-gpu-device-plugin:v1.2.1，<a href="https://github.com/NVIDIA/kubevirt-gpu-device-plugin/tree/v1.2.1">https://github.com/NVIDIA/kubevirt-gpu-device-plugin/tree/v1.2.1</a></p><h1 id="kubevirt-gpu-device-plugin启动"><a href="#kubevirt-gpu-device-plugin启动" class="headerlink" title="kubevirt-gpu-device-plugin启动"></a>kubevirt-gpu-device-plugin启动</h1><p>还是一样的套路，一切从main.go开始</p><p><u><em>Kubevirt-gpu-device-plugin/cmd/main.go#33</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">device_plugin.InitiateDevicePlugin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数调用 InitiateDevicePlugin 函数，直接看 InitiateDevicePlugin</p><p><u><em>Kubevirt-gpu-device-plugin/pkg/device_plugin/device_plugin.go#73</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitiateDevicePlugin</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Identifies GPUs and represents it in appropriate structures</span></span><br><span class="line">createIommuDeviceMap()</span><br><span class="line"><span class="comment">//Identifies vGPUs and represents it in appropriate structures</span></span><br><span class="line">createVgpuIDMap()</span><br><span class="line"><span class="comment">//Creates and starts device plugin</span></span><br><span class="line">createDevicePlugins()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InitiateDevicePlugin 函数主要做三件事：</p><ol><li>发现所有加载了 VFIO-PCI 驱动程序的 Nvidia gpu，并创建相应的映射</li><li>发现节点上配置的所有 Nvidia vgpu，并创建相应的映射</li><li>创建并启动 device-plugin</li></ol><h2 id="CreateIommuDeviceMap"><a href="#CreateIommuDeviceMap" class="headerlink" title="CreateIommuDeviceMap"></a>CreateIommuDeviceMap</h2><p><u><em>Kubevirt-gpu-device-plugin/pkg/device-plugin/device-plugin.go#155</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discovers all Nvidia GPUs which are loaded with VFIO-PCI driver and creates corresponding maps</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createIommuDeviceMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">iommuMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]NvidiaGpuDevice)</span><br><span class="line">deviceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line"><span class="comment">//Walk directory to discover pci devices</span></span><br><span class="line">filepath.Walk(basePath, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error accessing file path %q: %v\n&quot;</span>, path, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Not a device, continuing&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Retrieve vendor for the device</span></span><br><span class="line">vendorID, err := readIDFromFile(basePath, info.Name(), <span class="string">&quot;vendor&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get vendor ID for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Nvidia vendor id is &quot;10de&quot;. Proceed if vendor id is 10de</span></span><br><span class="line"><span class="keyword">if</span> vendorID == <span class="string">&quot;10de&quot;</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Nvidia device &quot;</span>, info.Name())</span><br><span class="line"><span class="comment">//Retrieve iommu group for the device</span></span><br><span class="line">driver, err := readLink(basePath, info.Name(), <span class="string">&quot;driver&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get driver for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> driver == <span class="string">&quot;vfio-pci&quot;</span> &#123;</span><br><span class="line">iommuGroup, err := readLink(basePath, info.Name(), <span class="string">&quot;iommu_group&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get IOMMU Group for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;Iommu Group &quot;</span> + iommuGroup)</span><br><span class="line">_, exists := iommuMap[iommuGroup]</span><br><span class="line"><span class="keyword">if</span> !exists &#123;</span><br><span class="line">deviceID, err := readIDFromFile(basePath, info.Name(), <span class="string">&quot;device&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could get deviceID for PCI address &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Device Id %s&quot;</span>, deviceID)</span><br><span class="line">deviceMap[deviceID] = <span class="built_in">append</span>(deviceMap[deviceID], iommuGroup)</span><br><span class="line">&#125;</span><br><span class="line">iommuMap[iommuGroup] = <span class="built_in">append</span>(iommuMap[iommuGroup], NvidiaGpuDevice&#123;info.Name()&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createIommuDeviceMap的主要流程如下图：</p><img src="/2023/01/10/32/createIommuDeviceMap.png" class="" title="createIommuDeviceMap"><h2 id="CreateVgpuIDMap"><a href="#CreateVgpuIDMap" class="headerlink" title="CreateVgpuIDMap"></a>CreateVgpuIDMap</h2><p><u><em>Kubevirt-gpu-device-plugin/pkg/device-plugin/device-plugin.go#208</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discovers all Nvidia vGPUs configured on a node and creates corresponding maps</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createVgpuIDMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">vGpuMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]NvidiaGpuDevice)</span><br><span class="line">gpuVgpuMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line"><span class="comment">//Walk directory to discover vGPU devices</span></span><br><span class="line">filepath.Walk(vGpuBasePath, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error accessing file path %q: %v\n&quot;</span>, path, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Not a device, continuing&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Read vGPU type name</span></span><br><span class="line">vGpuID, err := readVgpuIDFromFile(vGpuBasePath, info.Name(), <span class="string">&quot;mdev_type/name&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get vGPU type identifier for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Retrieve the gpu ID for this vGPU</span></span><br><span class="line">gpuID, err := readGpuIDForVgpu(vGpuBasePath, info.Name())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Could not get vGPU type identifier for device &quot;</span>, info.Name())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Gpu id is %s&quot;</span>, gpuID)</span><br><span class="line">log.Printf(<span class="string">&quot;Vgpu id is %s&quot;</span>, vGpuID)</span><br><span class="line">gpuVgpuMap[gpuID] = <span class="built_in">append</span>(gpuVgpuMap[gpuID], info.Name())</span><br><span class="line">vGpuMap[vGpuID] = <span class="built_in">append</span>(vGpuMap[vGpuID], NvidiaGpuDevice&#123;info.Name()&#125;)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/01/10/32/createVgpuIDMap.png" class="" title="createVgpuIDMap"><ol><li>通过filePath.Walk遍历“/sys/bus/mdev/devices”目录下的所有文件，得到所有 vgpu 相应设备文件</li><li>读取readVgpuIDFromFile(“/sys/bus/mdev/devices”,info.Name(),”mdev_type/name”)，获得vgpu的vGpuID</li><li>读取readGpuIDFromVgpu(“/sys/bus/mdev/devices”,info.Name())，获取vgpu对应的gpuID</li><li>最后，通过 gpuVgpuMap=map[ <gpuID> ] []string{ <vgpu-id1>,<vgpu-id2>…} 和 vGpuMap=map[ <vGpuID> ] []NvidiaGpuDevice{ {addr:<addr1>},{addr:<addr2>}} 存储映射关系。</li></ol><h2 id="CreateDevicePlugins"><a href="#CreateDevicePlugins" class="headerlink" title="CreateDevicePlugins"></a>CreateDevicePlugins</h2><p><u><em>Kubevirt-gpu-device-plugin/pkg/device-plugin/device-plugin.go#82</em></u></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Starts gpu pass through and vGPU device plugin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createDevicePlugins</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> devicePlugins []*GenericDevicePlugin</span><br><span class="line"><span class="keyword">var</span> vGpuDevicePlugins []*GenericVGpuDevicePlugin</span><br><span class="line"><span class="keyword">var</span> devs []*pluginapi.Device</span><br><span class="line">log.Printf(<span class="string">&quot;Iommu Map %s&quot;</span>, iommuMap)</span><br><span class="line">log.Printf(<span class="string">&quot;Device Map %s&quot;</span>, deviceMap)</span><br><span class="line">log.Println(<span class="string">&quot;vGPU Map &quot;</span>, vGpuMap)</span><br><span class="line">log.Println(<span class="string">&quot;GPU vGPU Map &quot;</span>, gpuVgpuMap)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Iterate over deivceMap to create device plugin for each type of GPU on the host</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> deviceMap &#123;</span><br><span class="line">devs = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> v &#123;</span><br><span class="line">devs = <span class="built_in">append</span>(devs, &amp;pluginapi.Device&#123;</span><br><span class="line">ID:     dev,</span><br><span class="line">Health: pluginapi.Healthy,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">deviceName := getDeviceName(k)</span><br><span class="line"><span class="keyword">if</span> deviceName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error: Could not find device name for device id: %s&quot;</span>, k)</span><br><span class="line">deviceName = k</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;DP Name %s&quot;</span>, deviceName)</span><br><span class="line">dp := NewGenericDevicePlugin(deviceName, <span class="string">&quot;/sys/kernel/iommu_groups/&quot;</span>, devs)</span><br><span class="line">err := startDevicePlugin(dp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error starting %s device plugin: %v&quot;</span>, dp.deviceName, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">devicePlugins = <span class="built_in">append</span>(devicePlugins, dp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Iterate over vGpuMap to create device plugin for each type of vGPU on the host</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> vGpuMap &#123;</span><br><span class="line">devs = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> _, dev := <span class="keyword">range</span> v &#123;</span><br><span class="line">devs = <span class="built_in">append</span>(devs, &amp;pluginapi.Device&#123;</span><br><span class="line">ID:     dev.addr,</span><br><span class="line">Health: pluginapi.Healthy,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">deviceName := getDeviceName(k)</span><br><span class="line"><span class="keyword">if</span> deviceName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">deviceName = k</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;DP Name %s&quot;</span>, deviceName)</span><br><span class="line">dp := NewGenericVGpuDevicePlugin(deviceName, vGpuBasePath, devs)</span><br><span class="line">err := startVgpuDevicePlugin(dp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error starting %s device plugin: %v&quot;</span>, dp.deviceName, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">vGpuDevicePlugins = <span class="built_in">append</span>(vGpuDevicePlugins, dp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-stop</span><br><span class="line">log.Printf(<span class="string">&quot;Shutting down device plugin controller&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> devicePlugins &#123;</span><br><span class="line">v.Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createDevicePlugin的流程图如下：</p><img src="/2023/01/10/32/kubevirt-device-plugin.png" class="" title="kubevirt-device-plugin"><p>启动kubevirt-gpu-device-plugin步骤主要有以下几点：</p><ol><li>遍历 deviveMap 将所有 device 设备类型下的所有 gpu 标记为 healthy </li><li>remove 并重建 socket 文件（”/var/lib/kubelet/device-plugins”+”kubevirt-<deviceName>.sock”）</li><li>启动 devicePlugin 的 grpc server，对外提供服务</li><li>请求kubelet socket链接，进行Regster</li><li>启动一个协程对设备进行healthCheck，并监听device-plguin自身socket文件</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>kubevirt-gpu-device-plugin使用前提，是用户使用 vfio-pci 将设备透传至 vm 内，然后，通过读取 vm 内的 pci 设备文件，获取设备的相关信息。iommu,vfio-pci等相关的内容，后续有时间会再补充。</p><h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><p><a href="https://rtoax.blog.csdn.net/article/details/110843839#t11">https://rtoax.blog.csdn.net/article/details/110843839#t11</a></p><p><a href="https://cloud.tencent.com/developer/article/1816469">https://cloud.tencent.com/developer/article/1816469</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;NVIDIA K8s Device Plugin为Kubevirt虚拟机分配gpu和vgpu，该篇文章基于NVIDIA/kubevirt-gpu-device-plugin:v1.2.1，&lt;a href=&quot;https://github.com/NVIDIA/kubevirt</summary>
      
    
    
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/categories/device-plugins/"/>
    
    
    <category term="device-plugins" scheme="http://lizhewei91.github.io/tags/device-plugins/"/>
    
    <category term="gpu" scheme="http://lizhewei91.github.io/tags/gpu/"/>
    
    <category term="kubevirt-gpu-device-plugin" scheme="http://lizhewei91.github.io/tags/kubevirt-gpu-device-plugin/"/>
    
  </entry>
  
</feed>
