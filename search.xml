<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浅谈k8s中device-plugins机制</title>
    <url>/2022/11/29/16/</url>
    <content><![CDATA[<h1 id="Extended-Resource"><a href="#Extended-Resource" class="headerlink" title="Extended Resource"></a>Extended Resource</h1><p>官方链接：<a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/extended-resource-node/">extended-resource-node</a></p>
<p><strong>特性状态</strong>： <code>Kubernetes v1.9 [stable]</code></p>
<p>可以用一句话来概括这个特性：通过向apiserver发送一个 patch node 的请求，为这个node增加一个自定义的资源类型，用于以该资源的配额统计和相应的QoS的配置。</p>
<h2 id="为节点增加扩展资源"><a href="#为节点增加扩展资源" class="headerlink" title="为节点增加扩展资源"></a>为节点增加扩展资源</h2><p>为在一个节点上发布一种新的扩展资源，需要发送一个 HTTP PATCH 请求到 Kubernetes API server。 例如：假设你的一个节点上带有四个 dongle 资源。 下面是一个 PATCH 请求的示例，该请求为你的节点发布四个 dongle 资源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/json-patch+json</span><br><span class="line">Host: k8s-master:8080</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;op&quot;: &quot;add&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;4&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Kubernetes 不需要了解 dongle 资源的含义和用途。 前面的 PATCH 请求告诉 Kubernetes 你的节点拥有四个你称之为 dongle 的东西。</p>
</blockquote>
<p>启动一个代理（proxy），以便你可以很容易地向 Kubernetes API server 发送请求：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure>

<p>在另一个命令窗口中，发送 HTTP PATCH 请求。 用你的节点名称替换 <code>&lt;your-node-name&gt;</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --header &quot;Content-Type: application/json-patch+json&quot; \</span><br><span class="line">  --request PATCH \</span><br><span class="line">  --data &#x27;[&#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;, &quot;value&quot;: &quot;4&quot;&#125;]&#x27; \</span><br><span class="line">  http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong> 在前面的请求中，<code>~1</code> 为 patch 路径中 “/” 符号的编码。 JSON-Patch 中的操作路径值被解析为 JSON 指针。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl describe node &lt;your-node-name&gt;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/29/16/image-20221129110411083.png" class="" title="image-20221129110411083">

<h2 id="清理扩展资源"><a href="#清理扩展资源" class="headerlink" title="清理扩展资源"></a>清理扩展资源</h2><p>这里是一个从节点移除 dongle 资源发布的 PATCH 请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PATCH /api/v1/nodes/&lt;your-node-name&gt;/status HTTP/1.1</span><br><span class="line">Accept: application/json</span><br><span class="line">Content-Type: application/json-patch+json</span><br><span class="line">Host: k8s-master:8080</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;op&quot;: &quot;remove&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>启动一个代理，以便你可以很容易地向 Kubernetes API 服务器发送请求：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure>

<p>在另一个命令窗口中，发送 HTTP PATCH 请求。用你的节点名称替换 <code>&lt;your-node-name&gt;</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --header &quot;Content-Type: application/json-patch+json&quot; \</span><br><span class="line">--request PATCH \</span><br><span class="line">--data &#x27;[&#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;&#125;]&#x27; \</span><br><span class="line">http://localhost:8001/api/v1/nodes/&lt;your-node-name&gt;/status</span><br></pre></td></tr></table></figure>

<p>验证 dongle 资源的发布已经被移除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl describe node &lt;your-node-name&gt; | grep dongle</span><br></pre></td></tr></table></figure>

<p>(你应该看不到任何输出)</p>
<blockquote>
<p>扩展资源是 <code>kubernetes.io</code> 域名之外的标准资源名称。 它们使得集群管理员能够颁布非 Kubernetes 内置资源，而用户可以使用他们。</p>
<p>使用扩展资源需要两个步骤。首先，集群管理员必须颁布扩展资源。 其次，用户必须在 Pod 中请求扩展资源。</p>
</blockquote>
<h1 id="Device-Plugins"><a href="#Device-Plugins" class="headerlink" title="Device Plugins"></a>Device Plugins</h1><p>官方链接：<a href="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/">device-plugins</a></p>
<p><strong>特性状态：</strong> <code>Kubernetes v1.26 [stable]</code></p>
<p>Kubernetes 提供了一个 <a href="https://git.k8s.io/design-proposals-archive/resource-management/device-plugin.md">设备插件框架</a>， 你可以用它来将系统硬件资源发布到 <a href="https://kubernetes.io/docs/reference/generated/kubelet">Kubelet</a>。</p>
<p>供应商可以实现设备插件，由你手动部署或作为 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a> 来部署，而不必定制 Kubernetes 本身的代码。目标设备包括 GPU、高性能 NIC、FPGA、 InfiniBand 适配器以及其他类似的、可能需要特定于供应商的初始化和设置的计算资源。</p>
<h2 id="设备插件框架"><a href="#设备插件框架" class="headerlink" title="设备插件框架"></a>设备插件框架</h2><img src="/2022/11/29/16/device-plugin-overview.png" class="" title="Process">

<p>设备插件的常规工作流程包括以下几个步骤：</p>
<ul>
<li>初始化。在这个阶段，设备插件将执行供应商特定的初始化和设置， 以确保设备处于就绪状态。</li>
<li>插件使用主机路径 <code>/var/lib/kubelet/device-plugins/</code> 下的 Unix 套接字启动一个 gRPC 服务，如：<code>/var/lib/kubelet/device-plugins/nvidia-gpu.sock</code>，该服务实现以下接口：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service DevicePlugin &#123;</span><br><span class="line">    // GetDevicePluginOptions 返回与设备管理器沟通的选项。</span><br><span class="line">    rpc GetDevicePluginOptions(Empty) returns (DevicePluginOptions) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // ListAndWatch 返回 Device 列表构成的数据流。</span><br><span class="line">    // 当 Device 状态发生变化或者 Device 消失时，ListAndWatch</span><br><span class="line">    // 会返回新的列表。</span><br><span class="line">    rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // Allocate 在容器创建期间调用，这样设备插件可以运行一些特定于设备的操作，</span><br><span class="line">    // 并告诉 kubelet 如何令 Device 可在容器中访问的所需执行的具体步骤</span><br><span class="line">    rpc Allocate(AllocateRequest) returns (AllocateResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // GetPreferredAllocation 从一组可用的设备中返回一些优选的设备用来分配，</span><br><span class="line">    // 所返回的优选分配结果不一定会是设备管理器的最终分配方案。</span><br><span class="line">    // 此接口的设计仅是为了让设备管理器能够在可能的情况下做出更有意义的决定。</span><br><span class="line">    rpc GetPreferredAllocation(PreferredAllocationRequest) returns (PreferredAllocationResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // PreStartContainer 在设备插件注册阶段根据需要被调用，调用发生在容器启动之前。</span><br><span class="line">    // 在将设备提供给容器使用之前，设备插件可以运行一些诸如重置设备之类的特定于</span><br><span class="line">    // 具体设备的操作，</span><br><span class="line">    rpc PreStartContainer(PreStartContainerRequest) returns (PreStartContainerResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>插件通过 Unix socket 在主机路径 <code>/var/lib/kubelet/device-plugins/kubelet.sock</code> 处向 kubelet 注册自身。</p>
</li>
<li><p>成功注册自身后，设备插件将以服务模式运行，在此期间，它将持续监控设备运行状况， 并在设备状态发生任何变化时向 kubelet 报告。它还负责响应 <code>Allocate</code> gRPC 请求。 在 <code>Allocate</code> 期间，设备插件可能还会做一些设备特定的准备；例如 GPU 清理或 QRNG 初始化。 如果操作成功，则设备插件将返回 <code>AllocateResponse</code>，其中包含用于访问被分配的设备容器运行时的配置。 kubelet 将此信息传递到容器运行时。</p>
</li>
</ul>
<h3 id="处理-kubelet-重启"><a href="#处理-kubelet-重启" class="headerlink" title="处理 kubelet 重启"></a>处理 kubelet 重启</h3><ul>
<li>设备插件应能监测到 kubelet 重启，并且向新的 kubelet 实例来重新注册自己。 新的 kubelet 实例启动时会删除 <code>/var/lib/kubelet/device-plugins</code> 下所有已经存在的 Unix 套接字。 </li>
<li>设备插件需要能够监控到它的 Unix 套接字被删除，并且当发生此类事件时重新注册自己。</li>
</ul>
]]></content>
      <categories>
        <category>device-plugins</category>
      </categories>
      <tags>
        <tag>kubernetnes</tag>
        <tag>device-plugins</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+typora图片插入</title>
    <url>/2022/11/28/29/</url>
    <content><![CDATA[<ol>
<li><strong>Typora设置</strong>。点击文件-&gt;偏好设置-&gt;图像，配置插入图片问复制到指定路径，底下三个勾都选，如下图所示。</li>
</ol>
<img src="/2022/11/28/29/image-20220611231725568.png" class="" title="img">
<ol start="2">
<li><p><strong>Hexo配置</strong>。在根目录下，进入bash命令框，输入<code>npm install hexo-image-link --save</code>安装插件。</p>
</li>
<li><p><strong>更改根目录下_config.yml配置</strong>，找到<code>post_asset_folder</code>，改为true。</p>
</li>
<li><p>写文章前，在根目录bash命令框中输入<code>hexo new 文章题目</code>，可以自动在post文件夹中生成<code>文章题目.md</code>与<code>文章题目</code>图片存储目录了。</p>
</li>
<li><p>这样就<strong>配置成功</strong>了。写文章之前，现在你可以把图片像word编辑一样<strong>拖动</strong>到typora直接预览，该过程不需要输入什么图片插入指令呀存储路径呀啥的，也不需要专门去对图片进行转存；直接网页端预览，图片可以正常显示。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>性能剖析大杀器 pprof</title>
    <url>/2022/11/28/56/</url>
    <content><![CDATA[<h1 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h1><p>在 Go 语言中，PProf 是用于可视化和分析性能分析数据的工具，pprof 以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）。</p>
<p>而刚刚提到的 profile.proto 是一个 Protobuf v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式。</p>
<h2 id="可以做什么"><a href="#可以做什么" class="headerlink" title="可以做什么"></a>可以做什么</h2><ul>
<li><strong>CPU Profiling</strong>：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。</li>
<li><strong>Memory Profiling</strong>：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。</li>
<li><strong>Block Profiling</strong>：阻塞分析，记录Goroutine阻塞等待同步（包括定时器通道）的位置，默认不开启，需要调用 <code>runtime.SetBlockProfileRate</code>进行设置。</li>
<li><strong>Mutex Profiling</strong>：互斥锁分析，报告互斥锁的竞争情况，默认不开启，需要调用 <code>runtime.SetMutexProfileFraction </code>进行设置。</li>
<li><strong>Goroutine Profiling</strong>：Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。</li>
</ul>
<p>其中像是 Goroutine Profiling 这项功能会在实际排查中会经常用到。因为很多问题出现时的表象就是 Goroutine 暴增，而这时候我们要做的事情之一就是查看应用程序中的 Goroutine 正在做什么事情，因为什么阻塞了，然后再进行下一步。</p>
<h2 id="采样方式"><a href="#采样方式" class="headerlink" title="采样方式"></a>采样方式</h2><ul>
<li><strong>runtime/pprof</strong>：采集程序（非 Server）的指定区块的运行数据进行分析。</li>
<li><strong>net/http/pprof</strong>：基于HTTP Server运行，并且可以采集运行时数据进行分析。</li>
<li><strong>go test</strong>：通过运行测试用例，并指定所需标识来进行采集。</li>
</ul>
<h2 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h2><ul>
<li>Report generation：报告生成。</li>
<li>Interactive terminal use：交互式终端使用。</li>
<li>Web interface：Web 界面。</li>
</ul>
<h1 id="服务型应用"><a href="#服务型应用" class="headerlink" title="服务型应用"></a>服务型应用</h1><p>如果你的应用程序是一直运行的，比如 web 应用，那么可以使用<code>net/http/pprof</code>库，它能够在提供 HTTP 服务进行分析。</p>
<p>如果使用了默认的 <code>http.DefaultServeMux</code>（通常是代码直接使用 <code>http.ListenAndServe(“0.0.0.0:8080”, nil)</code>），只需要在你的web server端代码中按如下方式导入<code>net/http/pprof</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span> </span><br></pre></td></tr></table></figure>

<h2 id="为什么要初始化net-http-pprof"><a href="#为什么要初始化net-http-pprof" class="headerlink" title="为什么要初始化net/http/pprof"></a>为什么要初始化net/http/pprof</h2><p>在我们的例子中，你会发现我们在引用上对 <code>net/http/pprof</code>包进行了默认的初始化（也就是 _），如果你曾经漏了，或者没加，你会发现压根调用不了 pprof 的相关接口，这是为什么呢，我们一起看看下面该包的初始化方法，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/&quot;</span>, Index)</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/cmdline&quot;</span>, Cmdline)</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/profile&quot;</span>, Profile)</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/symbol&quot;</span>, Symbol)</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/debug/pprof/trace&quot;</span>, Trace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上 <code>net/http/pprof</code>会在初始化函数中对标准库中<code>net/http</code>所默认提供的 <code>DefaultServeMux</code> 进行路由注册，源码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="type">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span></span>) &#123;</span><br><span class="line"> DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我们在例子中使用的 HTTP Server，也是使用的标准库中默认提供的，因此便完美的结合在了一起，这也恰好也是最小示例的模式。</p>
<p>这时候你可能会注意到另外一个问题，那就是我们的实际项目中，都是有相对独立的 ServeMux 的，这时候我们只要仿照着将 pprof 对应的路由注册进去就好了，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/&quot;</span>, pprof.Index)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/cmdline&quot;</span>, pprof.Cmdline)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/profile&quot;</span>, pprof.Profile)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/symbol&quot;</span>, pprof.Symbol)</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/debug/pprof/trace&quot;</span>, pprof.Trace)</span><br></pre></td></tr></table></figure>

<p>如果你使用的是gin框架，那么推荐使用 <a href="https://github.com/gin-contrib/pprof">github.com/gin-contrib/pprof</a>，在代码中通过以下命令注册 pprof 相关路由。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.Register(router)</span><br></pre></td></tr></table></figure>

<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> datas []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;hello,world&quot;</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;len:%d\n&quot;</span>, Add(str))</span><br><span class="line">			time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	_ = http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	datas = <span class="built_in">append</span>(datas, str)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(datas)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们运行这个程序，访问 <code>http://127.0.0.1:8080/debug/pprof/</code> 地址，检查是否正常响应。</p>
<h3 id="通过浏览器访问"><a href="#通过浏览器访问" class="headerlink" title="通过浏览器访问"></a>通过浏览器访问</h3><p>第一种方式，我们可以直接通过浏览器，进行查看，那么在第一步我们可以先查看总览页面，也就是访问 <code>http://127.0.0.1:8080/debug/pprof/</code>，如下：    </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/debug/pprof/</span><br><span class="line"></span><br><span class="line">Types of profiles available:</span><br><span class="line">Count	Profile</span><br><span class="line"><span class="number">3</span>	allocs</span><br><span class="line"><span class="number">0</span>	block</span><br><span class="line"><span class="number">0</span>	cmdline</span><br><span class="line"><span class="number">5</span>	goroutine</span><br><span class="line"><span class="number">3</span>	heap</span><br><span class="line"><span class="number">0</span>	mutex</span><br><span class="line"><span class="number">0</span>	profile</span><br><span class="line"><span class="number">8</span>	threadcreate</span><br><span class="line"><span class="number">0</span>	trace</span><br><span class="line">full goroutine stack dump</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>allocs</strong>：查看过去所有内存分配的样本，访问路径为<code>$HOST/debug/pprof/allocs</code>。</li>
<li><strong>block</strong>：查看导致阻塞同步的堆栈跟踪，访问路径为<code>$HOST/debug/pprof/block</code>。</li>
<li><strong>cmdline</strong>：当前程序的命令行的完整调用路径，访问路径为<code>$HOST/debug/pprof/cmdline</code>。</li>
<li><strong>goroutine</strong>：查看当前所有运行的 goroutines 堆栈跟踪，访问路径为<code>$HOST/debug/pprof/goroutine</code>。</li>
<li><strong>heap</strong>：查看活动对象的内存分配情况， 访问路径为<code>$HOST/debug/pprof/heap</code>。</li>
<li><strong>mutex</strong>：查看导致互斥锁的竞争持有者的堆栈跟踪，访问路径为<code>$HOST/debug/pprof/mutex</code>。</li>
<li><strong>profile</strong>：默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件，访问路径为<code>$HOST/debug/pprof/profile</code>。</li>
<li><strong>threadcreate</strong>：查看创建新OS线程的堆栈跟踪，访问路径为<code>$HOST/debug/pprof/threadcreate</code>。</li>
</ul>
<p>如果在相应的路径上加“<code>?debug=1</code>”，则可以直接在浏览器中访问，如图所示：</p>
<img src="/2022/11/28/56/1639809085480-2c7d9448-375f-4b98-913e-81020195a0c6-20221128222049403.png" class="" title="image.png">

<blockquote>
<p>若不新增debug参数，则会直接下载对应的profile文件。</p>
<p><strong>注意：</strong>debug的访问方式具有时效性，在实际场景中，我们通常将profile文件保存下来，便于二次分析。</p>
</blockquote>
<h3 id="通过交互式终端使用"><a href="#通过交互式终端使用" class="headerlink" title="通过交互式终端使用"></a>通过交互式终端使用</h3><h4 id="CPU-Profiling"><a href="#CPU-Profiling" class="headerlink" title="CPU Profiling"></a>CPU Profiling</h4><p>第二种方式，我们可以直接通过命令行，来完成对正在运行的应用程序 pprof 的抓取和分析。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/profile?seconds=60</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:6060/debug/pprof/profile?seconds=60</span></span><br><span class="line">Saved profile in /Users/eddycjy/pprof/pprof.samples.cpu<span class="number">.002</span>.pb.gz</span><br><span class="line">Type: cpu</span><br><span class="line">Duration: <span class="number">1</span>mins, Total samples = <span class="number">37.25</span>s (<span class="number">61.97</span>%)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure>

<p>执行该命令后，需等待 60 秒（可调整 seconds 的值），pprof 会进行 CPU Profiling，结束后将默认进入 pprof 的命令行交互式模式，可以对分析的结果进行查看或导出。另外如果你所启动的 HTTP Server 是 TLS 的方式，那么在调用<code>go tool pprof</code> 时，需要将调用路径改为：<code>go tool pprof https+insecure://localhost:8080/debug/pprof/profile\?seconds\=60</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) top10</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">1.38</span>s, <span class="number">100</span>% of <span class="number">1.38</span>s total</span><br><span class="line">Showing top <span class="number">10</span> nodes out of <span class="number">50</span></span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     <span class="number">0.60</span>s <span class="number">43.48</span>% <span class="number">43.48</span>%      <span class="number">0.80</span>s <span class="number">57.97</span>%  runtime.kevent</span><br><span class="line">     <span class="number">0.31</span>s <span class="number">22.46</span>% <span class="number">65.94</span>%      <span class="number">0.31</span>s <span class="number">22.46</span>%  runtime.libcCall</span><br><span class="line">     <span class="number">0.21</span>s <span class="number">15.22</span>% <span class="number">81.16</span>%      <span class="number">0.22</span>s <span class="number">15.94</span>%  syscall.syscall</span><br><span class="line">     <span class="number">0.15</span>s <span class="number">10.87</span>% <span class="number">92.03</span>%      <span class="number">0.26</span>s <span class="number">18.84</span>%  runtime.pthread_cond_wait</span><br><span class="line">     <span class="number">0.04</span>s  <span class="number">2.90</span>% <span class="number">94.93</span>%      <span class="number">0.04</span>s  <span class="number">2.90</span>%  runtime.pthread_cond_signal</span><br><span class="line">     <span class="number">0.02</span>s  <span class="number">1.45</span>% <span class="number">96.38</span>%      <span class="number">0.02</span>s  <span class="number">1.45</span>%  runtime.walltime</span><br><span class="line">     <span class="number">0.02</span>s  <span class="number">1.45</span>% <span class="number">97.83</span>%      <span class="number">0.02</span>s  <span class="number">1.45</span>%  runtime.write1</span><br><span class="line">     <span class="number">0.01</span>s  <span class="number">0.72</span>% <span class="number">98.55</span>%      <span class="number">0.01</span>s  <span class="number">0.72</span>%  log.itoa</span><br><span class="line">     <span class="number">0.01</span>s  <span class="number">0.72</span>% <span class="number">99.28</span>%      <span class="number">0.01</span>s  <span class="number">0.72</span>%  runtime.(*mcache).prepareForSweep</span><br><span class="line">     <span class="number">0.01</span>s  <span class="number">0.72</span>%   <span class="number">100</span>%      <span class="number">0.01</span>s  <span class="number">0.72</span>%  runtime.memmove</span><br></pre></td></tr></table></figure>

<ul>
<li>flat：函数自身的运行耗时。</li>
<li>flat%：函数自身在 CPU 运行耗时总比例。</li>
<li>sum%：函数自身累积使用 CPU 总比例。</li>
<li>cum：函数自身及其调用函数的运行总耗时。</li>
<li>cum%：函数自身及其调用函数的运行耗时总比例。</li>
<li>Name：函数名。</li>
</ul>
<p>在大多数的情况下，我们可以通过这五列得出一个应用程序的运行情况，知道当前是什么函数，正在做什么事情，占用了多少资源，谁又是占用资源的大头，以此来得到一个初步的分析方向。</p>
<blockquote>
<p>另外在交互命令行中，pprof 还支持了大量的其它命令，具体可执行 pprof help 查看帮助说明。</p>
</blockquote>
<h4 id="Heap-Profiling"><a href="#Heap-Profiling" class="headerlink" title="Heap Profiling"></a>Heap Profiling</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.001</span>.pb.gz</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">4</span>:<span class="number">56</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) </span><br></pre></td></tr></table></figure>

<p>执行该命令后，能够很快的拉取到其结果，因为它不需要像 CPU Profiling 做采样等待，这里需要注意的一点是 <code>Type</code> 这一个选项，你可以看到它默认显示的是 <code>inuse_space</code>，实际上可以针对多种内存概况进行分析，常用的类别如下：</p>
<p>一共有四种类型：</p>
<ol>
<li><strong>inuse_space</strong>：分析应用程序的常驻内存占用情况。</li>
<li><strong>alloc_objects</strong>：分析应用程序的内存临时分配情况。</li>
<li><strong>inuse_objects</strong>：查看每个函数所分别的对象数量。</li>
<li><strong>alloc_space</strong>：查看分配的内存空间大小。</li>
</ol>
<ul>
<li>inuse_space：分析应用程序的常驻内存占用情况。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$  <span class="keyword">go</span> tool pprof -inuse_space http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.002</span>.pb.gz</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">4</span>:<span class="number">59</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">4130.49</span>kB, <span class="number">100</span>% of <span class="number">4130.49</span>kB total</span><br><span class="line">Showing top <span class="number">10</span> nodes out of <span class="number">20</span></span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line"> <span class="number">1567.04</span>kB <span class="number">37.94</span>% <span class="number">37.94</span>%  <span class="number">1567.04</span>kB <span class="number">37.94</span>%  main.Add (inline)</span><br><span class="line"> <span class="number">1537.69</span>kB <span class="number">37.23</span>% <span class="number">75.17</span>%  <span class="number">1537.69</span>kB <span class="number">37.23</span>%  runtime.allocm</span><br><span class="line">  <span class="number">513.56</span>kB <span class="number">12.43</span>% <span class="number">87.60</span>%   <span class="number">513.56</span>kB <span class="number">12.43</span>%  regexp/syntax.init</span><br><span class="line">  <span class="number">512.20</span>kB <span class="number">12.40</span>%   <span class="number">100</span>%   <span class="number">512.20</span>kB <span class="number">12.40</span>%  runtime.malg</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%  <span class="number">1567.04</span>kB <span class="number">37.94</span>%  main.main.func1</span><br></pre></td></tr></table></figure>

<ul>
<li>alloc_objects：分析应用程序的内存临时分配情况。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof -alloc_objects http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.003</span>.pb.gz</span><br><span class="line">Type: alloc_objects</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">5</span>:<span class="number">01</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">311313</span>, <span class="number">99.07</span>% of <span class="number">314251</span> total</span><br><span class="line">Dropped <span class="number">39</span> nodes (cum &lt;= <span class="number">1571</span>)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    <span class="number">163842</span> <span class="number">52.14</span>% <span class="number">52.14</span>%     <span class="number">311313</span> <span class="number">99.07</span>%  main.main.func1</span><br><span class="line">    <span class="number">131074</span> <span class="number">41.71</span>% <span class="number">93.85</span>%     <span class="number">131074</span> <span class="number">41.71</span>%  fmt.Sprintf</span><br><span class="line">     <span class="number">16397</span>  <span class="number">5.22</span>% <span class="number">99.07</span>%      <span class="number">16397</span>  <span class="number">5.22</span>%  main.Add (inline)</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>% <span class="number">99.07</span>%     <span class="number">131074</span> <span class="number">41.71</span>%  log.Printf</span><br></pre></td></tr></table></figure>

<p>另外还有 inuse_objects 和 alloc_space 类别，分别对应查看每个函数所分别的对象数量和查看分配的内存空间大小，具体可根据情况选用。</p>
<h4 id="Goroutine-Profiling"><a href="#Goroutine-Profiling" class="headerlink" title="Goroutine Profiling"></a>Goroutine Profiling</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/goroutine</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8080/debug/pprof/goroutine</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.goroutine<span class="number">.001</span>.pb.gz</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">5</span>:<span class="number">04</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) </span><br></pre></td></tr></table></figure>

<p>在查看 goroutine 时，我们可以使用 traces 命令，这个命令会打印出对应的所有调用栈，以及指标信息，可以让我们很便捷的查看到整个调用链路有什么，分别在哪里使用了多少个 goroutine，并且能够通过分析查看到谁才是真正的调用方，输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) traces</span><br><span class="line">Type: goroutine</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">         <span class="number">2</span>   runtime.gopark</span><br><span class="line">             runtime.netpollblock</span><br><span class="line">             internal/poll.runtime_pollWait</span><br><span class="line">             ...</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">         <span class="number">1</span>   runtime.gopark</span><br><span class="line">             runtime.netpollblock</span><br><span class="line">             ...</span><br><span class="line">             net/http.ListenAndServe</span><br><span class="line">             main.main</span><br><span class="line">             runtime.main</span><br></pre></td></tr></table></figure>

<p>在调用栈上来讲，其展示顺序是<strong>自下而上</strong>的，也就是 <code>runtime.main</code> 方法调用了 <code>main.main</code> 方法，<code>main.main</code> 方法又调用了 <code>net/http.ListenAndServe</code> 方法，这里对应的也就是我们所使用的示例代码了，排查起来会非常方便。</p>
<p>每个调用堆栈信息用 <code>-----------</code> 分割，函数方法前的就是指标数据，像 Goroutine Profiling 展示是就是该方法占用的 goroutine 的数量。而 Heap Profiling 展示的就是占用的内存大小，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/heap</span></span><br><span class="line">...</span><br><span class="line">Type: inuse_space</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) traces</span><br><span class="line">Type: inuse_space</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  <span class="number">13.55</span>MB</span><br><span class="line">   <span class="number">13.55</span>MB   main.Add</span><br><span class="line">             main.main.func1</span><br><span class="line">-----------+-------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h4 id="Mutex-Profiling"><a href="#Mutex-Profiling" class="headerlink" title="Mutex Profiling"></a>Mutex Profiling</h4><p>怎么样的情况下会造成阻塞呢，一般有如下方式：调用 chan（通道）、调用 <code>sync.Mutex</code> （同步锁）、调用 <code>time.Sleep()</code> 等等。那么为了验证互斥锁的竞争持有者的堆栈跟踪，我们可以根据以上的 <code>sync.Mutex</code> 方式，来调整先前的示例代码，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"> runtime.SetMutexProfileFraction(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> m sync.Mutex</span><br><span class="line"> <span class="keyword">var</span> datas = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">999</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   m.Lock()</span><br><span class="line">   <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">   datas[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">  &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> _ = http.ListenAndServe(<span class="string">&quot;:6061&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是 <code>runtime.SetMutexProfileFraction</code> 语句，如果未来希望进行互斥锁的采集，那么需要通过调用该方法来设置采集频率，若不设置或没有设置大于 0 的数值，默认是不进行采集的。</p>
<p>接下来我们进行调用 <code>go tool pprof</code> 进行分析，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8081/debug/pprof/mutex</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8081/debug/pprof/mutex</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.contentions.delay<span class="number">.002</span>.pb.gz</span><br><span class="line">Type: delay</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">5</span>:<span class="number">18</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) </span><br></pre></td></tr></table></figure>

<p>我们查看调用 top 命令，查看互斥量的排名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">1.77</span>ms, <span class="number">100</span>% of <span class="number">1.77</span>ms total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    <span class="number">1.77</span>ms   <span class="number">100</span>%   <span class="number">100</span>%     <span class="number">1.77</span>ms   <span class="number">100</span>%  sync.(*Mutex).Unlock</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%     <span class="number">1.77</span>ms   <span class="number">100</span>%  main.main.func1</span><br></pre></td></tr></table></figure>

<p>接下来我们可以调用 list 命令，看到指定函数的代码情况（包含特定的指标信息，例如：耗时），若函数名不明确，默认会对函数名进行模糊匹配，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) list main</span><br><span class="line">Total: <span class="number">1.77</span>ms</span><br><span class="line">ROUTINE ======================== main.main.func1 in /Volumes/D/<span class="keyword">go</span>/src/github.com/lizw91/pprof/main.<span class="keyword">go</span></span><br><span class="line">         <span class="number">0</span>     <span class="number">1.77</span>ms (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">17</span>:   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">         .          .     <span class="number">18</span>:           <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">         .          .     <span class="number">19</span>:                   m.Lock()</span><br><span class="line">         .          .     <span class="number">20</span>:                   <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">         .          .     <span class="number">21</span>:                   datas[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">         .     <span class="number">1.77</span>ms     <span class="number">22</span>:           &#125;(i)</span><br><span class="line">         .          .     <span class="number">23</span>:   &#125;</span><br><span class="line">         .          .     <span class="number">24</span>:</span><br><span class="line">         .          .     <span class="number">25</span>:   _ = http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">         .          .     <span class="number">26</span>:&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在输出的分析中比较准确的看到引起互斥锁的函数在哪里，锁开销在哪里，在本例中是第 22 行。</p>
<h4 id="Block-Profiling"><a href="#Block-Profiling" class="headerlink" title="Block Profiling"></a>Block Profiling</h4><p>与 Mutex 的 <code>runtime.SetMutexProfileFraction</code> 相似，Block 也需要调用 <code>runtime.SetBlockProfileRate()</code> 进行采集量的设置，否则默认关闭，若设置的值小于等于 0 也会认为是关闭。</p>
<p>与上小节 Mutex 相比，主体代码不变，仅是新增 <code>runtime.SetBlockProfileRate()</code>的调用，如下：</p>
<p><strong>示例代码</strong> </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.SetBlockProfileRate(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m sync.Mutex</span><br><span class="line">	<span class="keyword">var</span> datas = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			m.Lock()</span><br><span class="line">			<span class="keyword">defer</span> m.Unlock()</span><br><span class="line">			datas[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_ = http.ListenAndServe(<span class="string">&quot;:8081&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查看调用 top 命令，查看阻塞情况的排名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8081/debug/pprof/block</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:8081/debug/pprof/block</span></span><br><span class="line">Saved profile in /Users/lizhewei/pprof/pprof.contentions.delay<span class="number">.003</span>.pb.gz</span><br><span class="line">Type: delay</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">5</span>:<span class="number">21</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">48.97</span>ms, <span class="number">100</span>% of <span class="number">48.97</span>ms total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">   <span class="number">48.97</span>ms   <span class="number">100</span>%   <span class="number">100</span>%    <span class="number">48.97</span>ms   <span class="number">100</span>%  sync.(*Mutex).Lock (inline)</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%    <span class="number">48.97</span>ms   <span class="number">100</span>%  main.main.func1</span><br></pre></td></tr></table></figure>

<p>同样的，我们也可以调用 list 命令查看具体的阻塞情况，执行方式和排查模式与先前概述的一致。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(pprof) list main</span><br><span class="line">Total: <span class="number">48.97</span>ms</span><br><span class="line">ROUTINE ======================== main.main.func1 in /Volumes/D/<span class="keyword">go</span>/src/github.com/lizw91/pprof/main.<span class="keyword">go</span></span><br><span class="line">         <span class="number">0</span>    <span class="number">48.97</span>ms (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">14</span>:<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">         .          .     <span class="number">15</span>:   <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">         .          .     <span class="number">16</span>:   <span class="keyword">var</span> datas = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">         .          .     <span class="number">17</span>:   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">         .          .     <span class="number">18</span>:           <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">         .    <span class="number">48.97</span>ms     <span class="number">19</span>:                   m.Lock()</span><br><span class="line">         .          .     <span class="number">20</span>:                   <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">         .          .     <span class="number">21</span>:                   datas[i] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">         .          .     <span class="number">22</span>:           &#125;(i)</span><br><span class="line">         .          .     <span class="number">23</span>:   &#125;</span><br><span class="line">         .          .     <span class="number">24</span>:</span><br></pre></td></tr></table></figure>

<h3 id="查看可视化界面"><a href="#查看可视化界面" class="headerlink" title="查看可视化界面"></a>查看可视化界面</h3><p>接下来我们继续使用前面的示例程序，将其重新运行起来，然后在其它窗口执行下述命令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 cpu 指标</span></span><br><span class="line">$ wget -O cpu.profile http:<span class="comment">//127.0.0.1:8080/debug/pprof/profile?seconds=30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 heap 指标 </span></span><br><span class="line">$ wget -O mem.profile http:<span class="comment">//127.0.0.1:8080/debug/pprof/profile?seconds=30</span></span><br></pre></td></tr></table></figure>

<p>默认需要等待 30 秒，执行完毕后可在当前目录下发现采集的文件 cpu.profile，针对可视化界面我们有两种方式可进行下一步分析：</p>
<ol>
<li>方法一<strong>（推荐）</strong>：该命令将在所指定的端口号运行一个 pprof 的分析用的站点</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof -http=:<span class="number">8081</span> cpu.profile  </span><br></pre></td></tr></table></figure>

<ol>
<li>方法二：通过 web 命令将以 svg 的文件格式写入图形，然后在 Web 浏览器中将其打开。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof cpu.profile</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Feb <span class="number">1</span>, <span class="number">2020</span> at <span class="number">12</span>:<span class="number">09</span>pm (CST)</span><br><span class="line">Duration: <span class="number">30</span>s, Total samples = <span class="number">60</span>ms (  <span class="number">0.2</span>%)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) web</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果出现错误提示 Could not execute dot; may need to install graphviz.，那么意味着你需要安装 graphviz组件。</p>
<p>另外方法一所运行的站点，实际上包含了方法二的内容（svg图片），并且更灵活，因此非特殊情况，我们会直接使用方法一的方式运行站点来做观察和分析。</p>
</blockquote>
<p>通过 pprof 所提供的可视化界面，我们能够更方便、更直观的看到 Go 应用程序的调用链、使用情况等。</p>
<p>另外在 View 菜单栏中，PProf 还支持多种分析方式的切换，如下：</p>
<img src="/2022/11/28/56/1639561832030-18ced959-237a-4a72-9121-a05850d0e4b9.png" class="" title="img">

<p>view 菜单栏</p>
<p>接下来我们将基于 CPU Profiling 所抓取的 Profile 进行一一介绍，而其它 Profile 类型的分析模式也是互通的，只要我们了解了一种，其余的也就会了。</p>
<h4 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h4><img src="/2022/11/28/56/1639561878713-40879f4c-8c9b-429d-bff5-bcfdffc32fc1.png" class="" title="img">

<ul>
<li>flat：函数自身的运行耗时。</li>
<li>flat%：函数自身在 CPU 运行耗时总比例。</li>
<li>sum%：函数自身累积使用 CPU 总比例。</li>
<li>cum：函数自身及其调用函数的运行总耗时。</li>
<li>cum%：函数自身及其调用函数的运行耗时总比例。</li>
<li>Name：函数名。</li>
</ul>
<h4 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h4><img src="/2022/11/28/56/1639561986430-2a11499e-5106-4273-8ce7-85caacd60ac0.png" class="" title="img">





<p>该视图展示的为整体的函数调用流程，框越大、线越粗、框颜色越鲜艳（红色）就代表它占用的时间越久，开销越大。相反若框颜色越淡，越小则代表在整体的函数调用流程中，它的开销是相对较小的。因此我们可以用此视图去分析谁才是开销大头，它又是因为什么调用流程而被调用的。</p>
<h4 id="Peek"><a href="#Peek" class="headerlink" title="Peek"></a>Peek</h4><img src="/2022/11/28/56/1639562053535-d85c624d-78ca-4460-93a2-d46fdb060ca1.png" class="" title="img">



<p>peek 栏目，此视图相较于 Top 视图，增加了所属的上下文信息的展示，也就是函数的输出调用者/被调用者。</p>
<h4 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h4><img src="/2022/11/28/56/1639562087329-46ed34bf-0b80-4510-bc2c-9dbf5b34a0da.png" class="" title="img">

<p>source 栏目，该视图主要是增加了面向源代码的追踪和分析，可以看到其开销主要消耗在哪里。</p>
<h4 id="flame-graph"><a href="#flame-graph" class="headerlink" title="flame graph"></a>flame graph</h4><img src="/2022/11/28/56/1639568828478-ad6f5933-8572-4dbd-b73d-f637ba70a610-20221128223022437.png" class="" title="image.png">

<p>Flame Graph（火焰图）它是可动态的，调用顺序由上到下（A -&gt; B -&gt; C -&gt; D），每一块代表一个函数、颜色越鲜艳（红）、区块越大代表占用 CPU 的时间更长。同时它也支持点击块深入进行分析。</p>
<p>我们选择页面上的 main.main.func1 区块，将会进入到其属下的下一层级，如下：</p>
<img src="/2022/11/28/56/1639568868468-031d2b33-b044-4827-a283-5bd689ab07d3-20221128223104007.png" class="" title="image.png">

<p>进一步查看 flame graph，这样子我们就可以根据不同函数的多维度层级进行分析，能够更好的观察其流转并发现问题。</p>
<h1 id="工具型应用"><a href="#工具型应用" class="headerlink" title="工具型应用"></a>工具型应用</h1><p>如果你的应用程序是运行一段时间就结束退出类型。那么最好的办法是在应用退出的时候把 profiling 的报告保存到文件中，进行分析。对于这种情况，可以使用<code>runtime/pprof</code>库。 首先在代码中导入<code>runtime/pprof</code>工具：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;runtime/pprof&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="CPU性能分析"><a href="#CPU性能分析" class="headerlink" title="CPU性能分析"></a>CPU性能分析</h2><p>开启CPU性能分析：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.StartCPUProfile(w io.Writer) </span><br></pre></td></tr></table></figure>

<p>停止CPU性能分析：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.StopCPUProfile() </span><br></pre></td></tr></table></figure>

<p>应用执行结束后，就会生成一个文件，保存了我们的 CPU profiling 数据。得到采样数据之后，使用 <code>go tool pprof</code>工具进行 CPU 性能分析。</p>
<h2 id="内存性能优化"><a href="#内存性能优化" class="headerlink" title="内存性能优化"></a>内存性能优化</h2><p>记录程序的堆栈信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pprof.WriteHeapProfile(w io.Writer)</span><br></pre></td></tr></table></figure>

<p><code>go tool pprof</code>默认是使用<code>-inuse_space</code> 进行统计，还可以使用 <code>-inuse-objects</code> 查看分配对象的数量。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime_pprof/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime/pprof&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段有问题的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logicCode</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> v := &lt;-c:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;recv from chan, value:%v\n&quot;</span>, v)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> isCPUPprof <span class="type">bool</span></span><br><span class="line">	<span class="keyword">var</span> isMemPprof <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	flag.BoolVar(&amp;isCPUPprof, <span class="string">&quot;cpu&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;turn cpu pprof on&quot;</span>)</span><br><span class="line">	flag.BoolVar(&amp;isMemPprof, <span class="string">&quot;mem&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;turn mem pprof on&quot;</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> isCPUPprof &#123;</span><br><span class="line">		file, err := os.Create(<span class="string">&quot;./cpu.pprof&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;create cpu pprof failed, err:%v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		pprof.StartCPUProfile(file)</span><br><span class="line">		<span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> logicCode()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">20</span> * time.Second)</span><br><span class="line">	<span class="keyword">if</span> isMemPprof &#123;</span><br><span class="line">		file, err := os.Create(<span class="string">&quot;./mem.pprof&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;create mem pprof failed, err:%v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		pprof.WriteHeapProfile(file)</span><br><span class="line">		file.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过flag我们可以在命令行控制是否开启 CPU和  Mem 的性能分析。 将上面的代码保存并编译成runtime_pprof 可执行文件，执行时加上 -cpu 命令行参数如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span> -cpu</span><br></pre></td></tr></table></figure>

<p>等待30秒后会在当前目录下生成一个 cpu.pprof 文件。然后，执行<code>go tool pprof</code>命令就可以查看</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof cpu.pprof</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Dec <span class="number">15</span>, <span class="number">2021</span> at <span class="number">8</span>:<span class="number">25</span>pm (CST)</span><br><span class="line">Duration: <span class="number">20.19</span>s, Total samples = <span class="number">119.64</span>s (<span class="number">592.65</span>%)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">119.62</span>s, <span class="number">100</span>% of <span class="number">119.64</span>s total</span><br><span class="line">Dropped <span class="number">2</span> nodes (cum &lt;= <span class="number">0.60</span>s)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    <span class="number">52.65</span>s <span class="number">44.01</span>% <span class="number">44.01</span>%     <span class="number">52.65</span>s <span class="number">44.01</span>%  runtime.chanrecv</span><br><span class="line">    <span class="number">51.04</span>s <span class="number">42.66</span>% <span class="number">86.67</span>%    <span class="number">103.69</span>s <span class="number">86.67</span>%  runtime.selectnbrecv</span><br><span class="line">    <span class="number">15.93</span>s <span class="number">13.31</span>%   <span class="number">100</span>%    <span class="number">119.63</span>s   <span class="number">100</span>%  main.logicCode</span><br></pre></td></tr></table></figure>

<h1 id="压测工具wrk"><a href="#压测工具wrk" class="headerlink" title="压测工具wrk"></a>压测工具wrk</h1><p>推荐使用：</p>
<p><a href="https://github.com/wg/wrk">https://github.com/wg/wrk</a> </p>
<p><a href="https://github.com/adjust/go-wrk">https://github.com/adjust/go-wrk</a></p>
<p>使用wrk进行压测:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span>-wrk -n <span class="number">50000</span> http:<span class="comment">//127.0.0.1:8080/book/list</span></span><br></pre></td></tr></table></figure>

<p>在上面压测进行的同时，打开另一个终端执行:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:8080/debug/pprof/profile?seconds=60</span></span><br></pre></td></tr></table></figure>

<h1 id="pprof与性能测试结合"><a href="#pprof与性能测试结合" class="headerlink" title="pprof与性能测试结合"></a>pprof与性能测试结合</h1><p><code>go test</code> 命令有两个参数和 pprof 相关，它们分别指定生成的 CPU 和 Memory profiling 保存的文件：</p>
<ul>
<li>-cpuprofile：cpu profiling 数据要保存的文件地址</li>
<li>-memprofile：memory profiling 数据要报文的文件地址</li>
</ul>
<p>我们还可以选择将pprof与性能测试相结合，比如：</p>
<p>比如下面执行测试的同时，也会执行 CPU profiling，并把结果保存在 cpu.prof 文件中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test -bench . -cpuprofile=cpu.profile</span><br></pre></td></tr></table></figure>

<p>比如下面执行测试的同时，也会执行 Mem profiling，并把结果保存在 cpu.prof 文件中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test -bench . -memprofile=./mem.profile</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong> 获取的 Profiling 数据是动态的，要想获得有效的数据，请保证应用处于较大的负载（比如正在生成中运行的服务，或者通过其他工具模拟访问压力）。否则如果应用处于空闲状态，得到的结果可能没有任何意义。所以，<strong>Profiling 一般和性能测试一起使用</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>pprof</category>
      </categories>
      <tags>
        <tag>pprof</tag>
        <tag>性能分析</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA/k8s-device-plugin源码分析</title>
    <url>/2023/01/06/46/</url>
    <content><![CDATA[<h1 id="device-plugin启动"><a href="#device-plugin启动" class="headerlink" title="device-plugin启动"></a>device-plugin启动</h1><p>该篇文章基于NVIDIA/k8s-device-plugin: v0.13.0，<a href="https://github.com/NVIDIA/k8s-device-plugin/tree/v0.13.0">https://github.com/NVIDIA/k8s-device-plugin/tree/v0.13.0</a></p>
<p>一切从 main 函数开始作为入口：</p>
<p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/main.go#35</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> configFile <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	c := cli.NewApp()</span><br><span class="line">	c.Name = <span class="string">&quot;NVIDIA Device Plugin&quot;</span></span><br><span class="line">	c.Usage = <span class="string">&quot;NVIDIA device plugin for Kubernetes&quot;</span></span><br><span class="line">	c.Version = info.GetVersionString()</span><br><span class="line">	c.Action = <span class="function"><span class="keyword">func</span><span class="params">(ctx *cli.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> start(ctx, c.Flags)</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p> 接下来，调用 start 函数</p>
<p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/main.go#133</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">(c *cli.Context, flags []cli.Flag)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;Starting FS watcher.&quot;</span>)</span><br><span class="line">	watcher, err := newFSWatcher(pluginapi.DevicePluginPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create FS watcher: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> watcher.Close()</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;Starting OS watcher.&quot;</span>)</span><br><span class="line">	sigs := newOSWatcher(syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> restarting <span class="type">bool</span></span><br><span class="line">	<span class="keyword">var</span> restartTimeout &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">	<span class="keyword">var</span> plugins []*NvidiaDevicePlugin</span><br><span class="line">restart:</span><br><span class="line">	<span class="comment">// If we are restarting, stop plugins from previous run.</span></span><br><span class="line">	<span class="keyword">if</span> restarting &#123;</span><br><span class="line">		err := stopPlugins(plugins)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error stopping plugins from previous run: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;Starting Plugins.&quot;</span>)</span><br><span class="line">	plugins, restartPlugins, err := startPlugins(c, flags, restarting)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error starting plugins: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> restartPlugins &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;Failed to start one or more plugins. Retrying in 30s...&quot;</span>)</span><br><span class="line">		restartTimeout = time.After(<span class="number">30</span> * time.Second)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	restarting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start an infinite loop, waiting for several indicators to either log</span></span><br><span class="line">	<span class="comment">// some messages, trigger a restart of the plugins, or exit the program.</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// If the restart timout has expired, then restart the plugins</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-restartTimeout:</span><br><span class="line">			<span class="keyword">goto</span> restart</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Detect a kubelet restart by watching for a newly created</span></span><br><span class="line">		<span class="comment">// &#x27;pluginapi.KubeletSocket&#x27; file. When this occurs, restart this loop,</span></span><br><span class="line">		<span class="comment">// restarting all of the plugins in the process.</span></span><br><span class="line">		<span class="keyword">case</span> event := &lt;-watcher.Events:</span><br><span class="line">			<span class="keyword">if</span> event.Name == pluginapi.KubeletSocket &amp;&amp; event.Op&amp;fsnotify.Create == fsnotify.Create &#123;</span><br><span class="line">				log.Printf(<span class="string">&quot;inotify: %s created, restarting.&quot;</span>, pluginapi.KubeletSocket)</span><br><span class="line">				<span class="keyword">goto</span> restart</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Watch for any other fs errors and log them.</span></span><br><span class="line">		<span class="keyword">case</span> err := &lt;-watcher.Errors:</span><br><span class="line">			log.Printf(<span class="string">&quot;inotify: %s&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Watch for any signals from the OS. On SIGHUP, restart this loop,</span></span><br><span class="line">		<span class="comment">// restarting all of the plugins in the process. On all other</span></span><br><span class="line">		<span class="comment">// signals, exit the loop and exit the program.</span></span><br><span class="line">		<span class="keyword">case</span> s := &lt;-sigs:</span><br><span class="line">			<span class="keyword">switch</span> s &#123;</span><br><span class="line">			<span class="keyword">case</span> syscall.SIGHUP:</span><br><span class="line">				log.Println(<span class="string">&quot;Received SIGHUP, restarting.&quot;</span>)</span><br><span class="line">				<span class="keyword">goto</span> restart</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				log.Printf(<span class="string">&quot;Received signal \&quot;%v\&quot;, shutting down.&quot;</span>, s)</span><br><span class="line">				<span class="keyword">goto</span> exit</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">exit:</span><br><span class="line">	err = stopPlugins(plugins)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error stopping plugins: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/01/06/46/k8s-device-plugin%E5%90%AF%E5%8A%A8.png" class="" title="k8s-device-plugin启动">

<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#92</em></u></p>
<p>K8s-device-plugin的启动流程中，nvidiaDevicePlugin.Start主要有三个步骤，1.启动device-plugin的grpc服务；2.向kubelet注册；3.启动协程对设备checkHealth。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Start() <span class="type">error</span> &#123;</span><br><span class="line">	plugin.initialize()</span><br><span class="line"></span><br><span class="line">	err := plugin.Serve()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;Could not start device plugin for &#x27;%s&#x27;: %s&quot;</span>, plugin.rm.Resource(), err)</span><br><span class="line">		plugin.cleanup()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Starting to serve &#x27;%s&#x27; on %s&quot;</span>, plugin.rm.Resource(), plugin.socket)</span><br><span class="line"></span><br><span class="line">	err = plugin.Register()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;Could not register device plugin: %s&quot;</span>, err)</span><br><span class="line">		plugin.Stop()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Registered device plugin for &#x27;%s&#x27; with Kubelet&quot;</span>, plugin.rm.Resource())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err := plugin.rm.CheckHealth(plugin.stop, plugin.health)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Failed to start health check: %v; continuing with health checks disabled&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/01/06/46/start%E6%B5%81%E7%A8%8B.png" class="" title="startl流程">

<h3 id="Serve"><a href="#Serve" class="headerlink" title="Serve"></a>Serve</h3><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#136</em></u></p>
<p>k8s-device-plugin 启动 gRPC 服务，对外提供服务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Serve() <span class="type">error</span> &#123;</span><br><span class="line">	os.Remove(plugin.socket)</span><br><span class="line">	sock, err := net.Listen(<span class="string">&quot;unix&quot;</span>, plugin.socket)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pluginapi.RegisterDevicePluginServer(plugin.server, plugin)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		lastCrashTime := time.Now()</span><br><span class="line">		restartCount := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Starting GRPC server for &#x27;%s&#x27;&quot;</span>, plugin.rm.Resource())</span><br><span class="line">			err := plugin.server.Serve(sock)</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			log.Printf(<span class="string">&quot;GRPC server for &#x27;%s&#x27; crashed with error: %v&quot;</span>, plugin.rm.Resource(), err)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// restart if it has not been too often</span></span><br><span class="line">			<span class="comment">// i.e. if server has crashed more than 5 times and it didn&#x27;t last more than one hour each time</span></span><br><span class="line">			<span class="keyword">if</span> restartCount &gt; <span class="number">5</span> &#123;</span><br><span class="line">				<span class="comment">// quit</span></span><br><span class="line">				log.Fatalf(<span class="string">&quot;GRPC server for &#x27;%s&#x27; has repeatedly crashed recently. Quitting&quot;</span>, plugin.rm.Resource())</span><br><span class="line">			&#125;</span><br><span class="line">			timeSinceLastCrash := time.Since(lastCrashTime).Seconds()</span><br><span class="line">			lastCrashTime = time.Now()</span><br><span class="line">			<span class="keyword">if</span> timeSinceLastCrash &gt; <span class="number">3600</span> &#123;</span><br><span class="line">				<span class="comment">// it has been one hour since the last crash.. reset the count</span></span><br><span class="line">				<span class="comment">// to reflect on the frequency</span></span><br><span class="line">				restartCount = <span class="number">1</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				restartCount++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for server to start by launching a blocking connexion</span></span><br><span class="line">	conn, err := plugin.dial(plugin.socket, <span class="number">5</span>*time.Second)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	conn.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/01/06/46/serve%E5%90%AF%E5%8A%A8.png" class="" title="serve启动">

<p>serve主要负责重建nvidia.sock文件，并且注册5个grpc接口到grpc.Server。</p>
<h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#186</em></u></p>
<p>Serve之后，接着进入Register流程，其代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Register() <span class="type">error</span> &#123;</span><br><span class="line">	conn, err := plugin.dial(pluginapi.KubeletSocket, <span class="number">5</span>*time.Second)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	client := pluginapi.NewRegistrationClient(conn)</span><br><span class="line">	reqt := &amp;pluginapi.RegisterRequest&#123;</span><br><span class="line">		Version:      pluginapi.Version,</span><br><span class="line">		Endpoint:     path.Base(plugin.socket),</span><br><span class="line">		ResourceName: <span class="type">string</span>(plugin.rm.Resource()),</span><br><span class="line">		Options: &amp;pluginapi.DevicePluginOptions&#123;</span><br><span class="line">			GetPreferredAllocationAvailable: <span class="literal">true</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = client.Register(context.Background(), reqt)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Register的实现流程图如下：</p>
<img src="/2023/01/06/46/register%E6%B5%81%E7%A8%8B.png" class="" title="register流程">

<ul>
<li>注册的Resource Name是<code>nvidia.com/gpu</code></li>
<li>注册的Version是<code>v1beta1</code></li>
</ul>
<h3 id="CheckHealth"><a href="#CheckHealth" class="headerlink" title="CheckHealth"></a>CheckHealth</h3><p><u><em>k8s-device-plugin/internal/rm/health.go#42</em></u></p>
<p>启动协程开始对管理的devices进行健康状态空空，一旦发现有device unhealthy，则发送到NvidiaDevicePlugin的health channel。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *nvmlResourceManager)</span></span> checkHealth(stop &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, devices Devices, unhealthy <span class="keyword">chan</span>&lt;- *Device) <span class="type">error</span> &#123;</span><br><span class="line">	disableHealthChecks := strings.ToLower(os.Getenv(envDisableHealthChecks))</span><br><span class="line">	<span class="keyword">if</span> disableHealthChecks == <span class="string">&quot;all&quot;</span> &#123;</span><br><span class="line">		disableHealthChecks = allHealthChecks</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> strings.Contains(disableHealthChecks, <span class="string">&quot;xids&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret := r.nvml.Init()</span><br><span class="line">	<span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">		<span class="keyword">if</span> *r.config.Flags.FailOnInitError &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to initialize NVML: %v&quot;</span>, ret)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ret := r.nvml.Shutdown()</span><br><span class="line">		<span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Error shutting down NVML: %v&quot;</span>, ret)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">FIXME:</span> formalize the full list and document it.</span></span><br><span class="line">	<span class="comment">// http://docs.nvidia.com/deploy/xid-errors/index.html#topic_4</span></span><br><span class="line">	<span class="comment">// Application errors: the GPU should still be healthy</span></span><br><span class="line">	applicationErrorXids := []<span class="type">uint64</span>&#123;</span><br><span class="line">		<span class="number">13</span>, <span class="comment">// Graphics Engine Exception</span></span><br><span class="line">		<span class="number">31</span>, <span class="comment">// GPU memory page fault</span></span><br><span class="line">		<span class="number">43</span>, <span class="comment">// GPU stopped processing</span></span><br><span class="line">		<span class="number">45</span>, <span class="comment">// Preemptive cleanup, due to previous errors</span></span><br><span class="line">		<span class="number">68</span>, <span class="comment">// Video processor exception</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	skippedXids := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]<span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, id := <span class="keyword">range</span> applicationErrorXids &#123;</span><br><span class="line">		skippedXids[id] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, additionalXid := <span class="keyword">range</span> getAdditionalXids(disableHealthChecks) &#123;</span><br><span class="line">		skippedXids[additionalXid] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	eventSet, ret := r.nvml.EventSetCreate()</span><br><span class="line">	<span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create event set: %v&quot;</span>, ret)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> eventSet.Free()</span><br><span class="line"></span><br><span class="line">	parentToDeviceMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*Device)</span><br><span class="line">	deviceIDToGiMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	deviceIDToCiMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	eventMask := <span class="type">uint64</span>(nvml.EventTypeXidCriticalError | nvml.EventTypeDoubleBitEccError | nvml.EventTypeSingleBitEccError)</span><br><span class="line">	<span class="keyword">for</span> _, d := <span class="keyword">range</span> devices &#123;</span><br><span class="line">		uuid, gi, ci, err := r.getDevicePlacement(d)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Warning: could not determine device placement for %v: %v; Marking it unhealthy.&quot;</span>, d.ID, err)</span><br><span class="line">			unhealthy &lt;- d</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		deviceIDToGiMap[d.ID] = gi</span><br><span class="line">		deviceIDToCiMap[d.ID] = ci</span><br><span class="line">		parentToDeviceMap[uuid] = d</span><br><span class="line"></span><br><span class="line">		gpu, ret := r.nvml.DeviceGetHandleByUUID(uuid)</span><br><span class="line">		<span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;unable to get device handle from UUID: %v; marking it as unhealthy&quot;</span>, ret)</span><br><span class="line">			unhealthy &lt;- d</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		supportedEvents, ret := gpu.GetSupportedEventTypes()</span><br><span class="line">		<span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;unabled to determine the supported events for %v: %v; marking it as unhealthy&quot;</span>, d.ID, ret)</span><br><span class="line">			unhealthy &lt;- d</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = gpu.RegisterEvents(eventMask&amp;supportedEvents, eventSet)</span><br><span class="line">		<span class="keyword">if</span> ret == nvml.ERROR_NOT_SUPPORTED &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Warning: Device %v is too old to support healthchecking.&quot;</span>, d.ID)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Marking device %v as unhealthy: %v&quot;</span>, d.ID, ret)</span><br><span class="line">			unhealthy &lt;- d</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-stop:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		e, ret := eventSet.Wait(<span class="number">5000</span>)</span><br><span class="line">		<span class="keyword">if</span> ret == nvml.ERROR_TIMEOUT &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Error waiting for event: %v; Marking all devices as unhealthy&quot;</span>, ret)</span><br><span class="line">			<span class="keyword">for</span> _, d := <span class="keyword">range</span> devices &#123;</span><br><span class="line">				unhealthy &lt;- d</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> e.EventType != nvml.EventTypeXidCriticalError &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Skipping non-nvmlEventTypeXidCriticalError event: %+v&quot;</span>, e)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> skippedXids[e.EventData] &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Skipping event %+v&quot;</span>, e)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		log.Printf(<span class="string">&quot;Processing event %+v&quot;</span>, e)</span><br><span class="line">		eventUUID, ret := e.Device.GetUUID()</span><br><span class="line">		<span class="keyword">if</span> ret != nvml.SUCCESS &#123;</span><br><span class="line">			<span class="comment">// If we cannot reliably determine the device UUID, we mark all devices as unhealthy.</span></span><br><span class="line">			log.Printf(<span class="string">&quot;Failed to determine uuid for event %v: %v; Marking all devices as unhealthy.&quot;</span>, e, ret)</span><br><span class="line">			<span class="keyword">for</span> _, d := <span class="keyword">range</span> devices &#123;</span><br><span class="line">				unhealthy &lt;- d</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		d, exists := parentToDeviceMap[eventUUID]</span><br><span class="line">		<span class="keyword">if</span> !exists &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Ignoring event for unexpected device: %v&quot;</span>, eventUUID)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> d.IsMigDevice() &amp;&amp; e.GpuInstanceId != <span class="number">0xFFFFFFFF</span> &amp;&amp; e.ComputeInstanceId != <span class="number">0xFFFFFFFF</span> &#123;</span><br><span class="line">			gi := deviceIDToGiMap[d.ID]</span><br><span class="line">			ci := deviceIDToCiMap[d.ID]</span><br><span class="line">			<span class="keyword">if</span> !(<span class="type">uint32</span>(gi) == e.GpuInstanceId &amp;&amp; <span class="type">uint32</span>(ci) == e.ComputeInstanceId) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			log.Printf(<span class="string">&quot;Event for mig device %v (gi=%v, ci=%v)&quot;</span>, d.ID, gi, ci)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		log.Printf(<span class="string">&quot;XidCriticalError: Xid=%d on Device=%s; marking device as unhealthy.&quot;</span>, e.EventData, d.ID)</span><br><span class="line">		unhealthy &lt;- d</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>checkhealth的主要原理图如下：</p>
<img src="/2023/01/06/46/checkhealth.png" class="" title="checkhealth">

<p>需要特别说明<code>healthcheck</code>部分：</p>
<ul>
<li>healthcheck启动协程对管理的devices进行健康状态监控，一旦发现有device unhealthy，则发送到NvidiaDevicePlugin的health channel。device plugin的ListAndWatch会从health channel中获取这些unhealthy devices，并通知到kubelet进行更新。</li>
<li>只监控<code>EventTypeXidCriticalError</code>事件，一旦监控到某个device的这个Event，就认为该device unhealthy。关于<code>EventTypeXidCriticalError</code>的说明，请参考NVIDIA的<a href="https://docs.nvidia.com/deploy/nvml-api/group__nvmlEventType.html">nvml api文档</a>。</li>
<li>可以通过设置NVIDIA device plugin Pod内的环境变量<code>DP_DISABLE_HEALTHCHECKS</code>为”all”来取消healthcheck。不设置或者设置为其他值都会启动healthcheck，默认部署时不设置。</li>
</ul>
<h2 id="stopPlugins"><a href="#stopPlugins" class="headerlink" title="stopPlugins"></a>stopPlugins</h2><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/main.go#275</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Stop() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> plugin == <span class="literal">nil</span> || plugin.server == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Stopping to serve &#x27;%s&#x27; on %s&quot;</span>, plugin.rm.Resource(), plugin.socket)</span><br><span class="line">	plugin.server.Stop()</span><br><span class="line">	<span class="keyword">if</span> err := os.Remove(plugin.socket); err != <span class="literal">nil</span> &amp;&amp; !os.IsNotExist(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	plugin.cleanup()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/01/06/46/stop-plugins.png" class="" title="stop-plugins">

<p>stopPlugins主要做三件事：</p>
<ol>
<li>停止 device-plugin 的 grpc server</li>
<li>移除 plugin socket 文件 （/var/lib/kubelet/device-plugins/nvidia-gpu.sock）</li>
<li>清空 nvidiaDevicePlugin 相关字段。（plugin.server=nil; plugin.health=nil; plugin.stop=nil）</li>
</ol>
<h2 id="ListAndWatch"><a href="#ListAndWatch" class="headerlink" title="ListAndWatch"></a>ListAndWatch</h2><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#219</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> ListAndWatch(e *pluginapi.Empty, s pluginapi.DevicePlugin_ListAndWatchServer) <span class="type">error</span> &#123;</span><br><span class="line">	s.Send(&amp;pluginapi.ListAndWatchResponse&#123;Devices: plugin.apiDevices()&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-plugin.stop:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> d := &lt;-plugin.health:</span><br><span class="line">			<span class="comment">// <span class="doctag">FIXME:</span> there is no way to recover from the Unhealthy state.</span></span><br><span class="line">			d.Health = pluginapi.Unhealthy</span><br><span class="line">			log.Printf(<span class="string">&quot;&#x27;%s&#x27; device marked unhealthy: %s&quot;</span>, plugin.rm.Resource(), d.ID)</span><br><span class="line">			s.Send(&amp;pluginapi.ListAndWatchResponse&#123;Devices: plugin.apiDevices()&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>listAndWatch 的实现流程图如下：</p>
<img src="/2023/01/06/46/listAndWatch.png" class="" title="listAndWatch">

<h2 id="Allocate"><a href="#Allocate" class="headerlink" title="Allocate"></a>Allocate</h2><p><u><em>k8s-device-plugin/cmd/nvidia-device-plugin/server.go#254</em></u></p>
<p>allocateRequest的请求结构体如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AllocateRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	ContainerRequests    []*ContainerAllocateRequest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ContainerAllocateRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	DevicesIDs           []<span class="type">string</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>allocateResponse的结构体如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AllocateResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	ContainerResponses   []*ContainerAllocateResponse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ContainerAllocateResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	Envs                <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> </span><br><span class="line">	Mounts              []*Mount </span><br><span class="line">	Devices             []*DeviceSpec</span><br><span class="line">	Annotations         <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Allocate 在容器创建期间调用，这样设备插件可以运行一些特定于设备的操作，并告诉 kubelet 如何令 Device 可在容器中访问的所需执行的具体步骤。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(plugin *NvidiaDevicePlugin)</span></span> Allocate(ctx context.Context, reqs *pluginapi.AllocateRequest) (*pluginapi.AllocateResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	responses := pluginapi.AllocateResponse&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, req := <span class="keyword">range</span> reqs.ContainerRequests &#123;</span><br><span class="line">		<span class="comment">// If the devices being allocated are replicas, then (conditionally)</span></span><br><span class="line">		<span class="comment">// error out if more than one resource is being allocated.</span></span><br><span class="line">		<span class="keyword">if</span> plugin.config.Sharing.TimeSlicing.FailRequestsGreaterThanOne &amp;&amp; rm.AnnotatedIDs(req.DevicesIDs).AnyHasAnnotations() &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(req.DevicesIDs) &gt; <span class="number">1</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;request for &#x27;%v: %v&#x27; too large: maximum request size for shared resources is 1&quot;</span>, plugin.rm.Resource(), <span class="built_in">len</span>(req.DevicesIDs))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> _, id := <span class="keyword">range</span> req.DevicesIDs &#123;</span><br><span class="line">			<span class="keyword">if</span> !plugin.rm.Devices().Contains(id) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;invalid allocation request for &#x27;%s&#x27;: unknown device: %s&quot;</span>, plugin.rm.Resource(), id)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		response := pluginapi.ContainerAllocateResponse&#123;&#125;</span><br><span class="line"></span><br><span class="line">		ids := req.DevicesIDs</span><br><span class="line">		deviceIDs := plugin.deviceIDsFromAnnotatedDeviceIDs(ids)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> *plugin.config.Flags.Plugin.DeviceListStrategy == spec.DeviceListStrategyEnvvar &#123;</span><br><span class="line">			response.Envs = plugin.apiEnvs(plugin.deviceListEnvvar, deviceIDs)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> *plugin.config.Flags.Plugin.DeviceListStrategy == spec.DeviceListStrategyVolumeMounts &#123;</span><br><span class="line">			response.Envs = plugin.apiEnvs(plugin.deviceListEnvvar, []<span class="type">string</span>&#123;deviceListAsVolumeMountsContainerPathRoot&#125;)</span><br><span class="line">			response.Mounts = plugin.apiMounts(deviceIDs)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> *plugin.config.Flags.Plugin.PassDeviceSpecs &#123;</span><br><span class="line">			response.Devices = plugin.apiDeviceSpecs(*plugin.config.Flags.NvidiaDriverRoot, ids)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> *plugin.config.Flags.GDSEnabled &#123;</span><br><span class="line">			response.Envs[<span class="string">&quot;NVIDIA_GDS&quot;</span>] = <span class="string">&quot;enabled&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> *plugin.config.Flags.MOFEDEnabled &#123;</span><br><span class="line">			response.Envs[<span class="string">&quot;NVIDIA_MOFED&quot;</span>] = <span class="string">&quot;enabled&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		responses.ContainerResponses = <span class="built_in">append</span>(responses.ContainerResponses, &amp;response)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;responses, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/01/06/46/allocate.png" class="" title="allocate">

<ul>
<li>Allocate中会遍历ContainerRequests，将DeviceIDs封装到ContainerAllocateResponse的<code>Envs:NVIDIA_VISIBLE_DEVICES</code>中，格式为：”<code>$&#123;ID_1&#125;,$&#123;ID_2&#125;,...</code>”</li>
<li>除此之外，并没有封装Mounts, Devices, Annotations。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>NVIDIA/k8s-device-plugin的代码中，依赖于nvidia-docker代码库，存在很多golang调用C库的地方，还需要大家自行到 <a href="https://docs.nvidia.com/deploy/nvml-api">nvml api文档</a> 中查看相关C函数声明。这篇博客介绍NVIDIA/k8s-device-plugin的代码实现流程，下一篇博客我觉得还有必要对kubelet device plugin manger进行代码分析，如此才能完整的理解整个交互细节。</p>
]]></content>
      <categories>
        <category>device-plugins</category>
      </categories>
      <tags>
        <tag>device-plugins</tag>
        <tag>nvidia</tag>
        <tag>gpu</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA/kubevirt-gpu-device-plugin源码分析</title>
    <url>/2023/01/10/32/</url>
    <content><![CDATA[<p>NVIDIA K8s Device Plugin为Kubevirt虚拟机分配gpu和vgpu，该篇文章基于NVIDIA/kubevirt-gpu-device-plugin:v1.2.1，<a href="https://github.com/NVIDIA/kubevirt-gpu-device-plugin/tree/v1.2.1">https://github.com/NVIDIA/kubevirt-gpu-device-plugin/tree/v1.2.1</a></p>
<h1 id="kubevirt-gpu-device-plugin启动"><a href="#kubevirt-gpu-device-plugin启动" class="headerlink" title="kubevirt-gpu-device-plugin启动"></a>kubevirt-gpu-device-plugin启动</h1><p>还是一样的套路，一切从main.go开始</p>
<p><u><em>Kubevirt-gpu-device-plugin/cmd/main.go#33</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	device_plugin.InitiateDevicePlugin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数调用 InitiateDevicePlugin 函数，直接看 InitiateDevicePlugin</p>
<p><u><em>Kubevirt-gpu-device-plugin/pkg/device_plugin/device_plugin.go#73</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitiateDevicePlugin</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//Identifies GPUs and represents it in appropriate structures</span></span><br><span class="line">	createIommuDeviceMap()</span><br><span class="line">	<span class="comment">//Identifies vGPUs and represents it in appropriate structures</span></span><br><span class="line">	createVgpuIDMap()</span><br><span class="line">	<span class="comment">//Creates and starts device plugin</span></span><br><span class="line">	createDevicePlugins()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InitiateDevicePlugin 函数主要做三件事：</p>
<ol>
<li>发现所有加载了 VFIO-PCI 驱动程序的 Nvidia gpu，并创建相应的映射</li>
<li>发现节点上配置的所有 Nvidia vgpu，并创建相应的映射</li>
<li>创建并启动 device-plugin</li>
</ol>
<h2 id="CreateIommuDeviceMap"><a href="#CreateIommuDeviceMap" class="headerlink" title="CreateIommuDeviceMap"></a>CreateIommuDeviceMap</h2><p><u><em>Kubevirt-gpu-device-plugin/pkg/device-plugin/device-plugin.go#155</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discovers all Nvidia GPUs which are loaded with VFIO-PCI driver and creates corresponding maps</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createIommuDeviceMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	iommuMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]NvidiaGpuDevice)</span><br><span class="line">	deviceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line">	<span class="comment">//Walk directory to discover pci devices</span></span><br><span class="line">	filepath.Walk(basePath, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Error accessing file path %q: %v\n&quot;</span>, path, err)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;Not a device, continuing&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//Retrieve vendor for the device</span></span><br><span class="line">		vendorID, err := readIDFromFile(basePath, info.Name(), <span class="string">&quot;vendor&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;Could not get vendor ID for device &quot;</span>, info.Name())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Nvidia vendor id is &quot;10de&quot;. Proceed if vendor id is 10de</span></span><br><span class="line">		<span class="keyword">if</span> vendorID == <span class="string">&quot;10de&quot;</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;Nvidia device &quot;</span>, info.Name())</span><br><span class="line">			<span class="comment">//Retrieve iommu group for the device</span></span><br><span class="line">			driver, err := readLink(basePath, info.Name(), <span class="string">&quot;driver&quot;</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Println(<span class="string">&quot;Could not get driver for device &quot;</span>, info.Name())</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> driver == <span class="string">&quot;vfio-pci&quot;</span> &#123;</span><br><span class="line">				iommuGroup, err := readLink(basePath, info.Name(), <span class="string">&quot;iommu_group&quot;</span>)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Println(<span class="string">&quot;Could not get IOMMU Group for device &quot;</span>, info.Name())</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">				log.Println(<span class="string">&quot;Iommu Group &quot;</span> + iommuGroup)</span><br><span class="line">				_, exists := iommuMap[iommuGroup]</span><br><span class="line">				<span class="keyword">if</span> !exists &#123;</span><br><span class="line">					deviceID, err := readIDFromFile(basePath, info.Name(), <span class="string">&quot;device&quot;</span>)</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						log.Println(<span class="string">&quot;Could get deviceID for PCI address &quot;</span>, info.Name())</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">					&#125;</span><br><span class="line">					log.Printf(<span class="string">&quot;Device Id %s&quot;</span>, deviceID)</span><br><span class="line">					deviceMap[deviceID] = <span class="built_in">append</span>(deviceMap[deviceID], iommuGroup)</span><br><span class="line">				&#125;</span><br><span class="line">				iommuMap[iommuGroup] = <span class="built_in">append</span>(iommuMap[iommuGroup], NvidiaGpuDevice&#123;info.Name()&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createIommuDeviceMap的主要流程如下图：</p>
<img src="/2023/01/10/32/createIommuDeviceMap.png" class="" title="createIommuDeviceMap">

<h2 id="CreateVgpuIDMap"><a href="#CreateVgpuIDMap" class="headerlink" title="CreateVgpuIDMap"></a>CreateVgpuIDMap</h2><p><u><em>Kubevirt-gpu-device-plugin/pkg/device-plugin/device-plugin.go#208</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discovers all Nvidia vGPUs configured on a node and creates corresponding maps</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createVgpuIDMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	vGpuMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]NvidiaGpuDevice)</span><br><span class="line">	gpuVgpuMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line">	<span class="comment">//Walk directory to discover vGPU devices</span></span><br><span class="line">	filepath.Walk(vGpuBasePath, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Error accessing file path %q: %v\n&quot;</span>, path, err)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;Not a device, continuing&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//Read vGPU type name</span></span><br><span class="line">		vGpuID, err := readVgpuIDFromFile(vGpuBasePath, info.Name(), <span class="string">&quot;mdev_type/name&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;Could not get vGPU type identifier for device &quot;</span>, info.Name())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//Retrieve the gpu ID for this vGPU</span></span><br><span class="line">		gpuID, err := readGpuIDForVgpu(vGpuBasePath, info.Name())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(<span class="string">&quot;Could not get vGPU type identifier for device &quot;</span>, info.Name())</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">&quot;Gpu id is %s&quot;</span>, gpuID)</span><br><span class="line">		log.Printf(<span class="string">&quot;Vgpu id is %s&quot;</span>, vGpuID)</span><br><span class="line">		gpuVgpuMap[gpuID] = <span class="built_in">append</span>(gpuVgpuMap[gpuID], info.Name())</span><br><span class="line">		vGpuMap[vGpuID] = <span class="built_in">append</span>(vGpuMap[vGpuID], NvidiaGpuDevice&#123;info.Name()&#125;)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/01/10/32/createVgpuIDMap.png" class="" title="createVgpuIDMap">

<ol>
<li>通过filePath.Walk遍历“/sys/bus/mdev/devices”目录下的所有文件，得到所有 vgpu 相应设备文件</li>
<li>读取readVgpuIDFromFile(“/sys/bus/mdev/devices”,info.Name(),”mdev_type/name”)，获得vgpu的vGpuID</li>
<li>读取readGpuIDFromVgpu(“/sys/bus/mdev/devices”,info.Name())，获取vgpu对应的gpuID</li>
<li>最后，通过 gpuVgpuMap=map[ <gpuID> ] []string{ <vgpu-id1>,<vgpu-id2>…} 和 vGpuMap=map[ <vGpuID> ] []NvidiaGpuDevice{ {addr:<addr1>},{addr:<addr2>}} 存储映射关系。</li>
</ol>
<h2 id="CreateDevicePlugins"><a href="#CreateDevicePlugins" class="headerlink" title="CreateDevicePlugins"></a>CreateDevicePlugins</h2><p><u><em>Kubevirt-gpu-device-plugin/pkg/device-plugin/device-plugin.go#82</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Starts gpu pass through and vGPU device plugin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createDevicePlugins</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> devicePlugins []*GenericDevicePlugin</span><br><span class="line">	<span class="keyword">var</span> vGpuDevicePlugins []*GenericVGpuDevicePlugin</span><br><span class="line">	<span class="keyword">var</span> devs []*pluginapi.Device</span><br><span class="line">	log.Printf(<span class="string">&quot;Iommu Map %s&quot;</span>, iommuMap)</span><br><span class="line">	log.Printf(<span class="string">&quot;Device Map %s&quot;</span>, deviceMap)</span><br><span class="line">	log.Println(<span class="string">&quot;vGPU Map &quot;</span>, vGpuMap)</span><br><span class="line">	log.Println(<span class="string">&quot;GPU vGPU Map &quot;</span>, gpuVgpuMap)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Iterate over deivceMap to create device plugin for each type of GPU on the host</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> deviceMap &#123;</span><br><span class="line">		devs = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">for</span> _, dev := <span class="keyword">range</span> v &#123;</span><br><span class="line">			devs = <span class="built_in">append</span>(devs, &amp;pluginapi.Device&#123;</span><br><span class="line">				ID:     dev,</span><br><span class="line">				Health: pluginapi.Healthy,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		deviceName := getDeviceName(k)</span><br><span class="line">		<span class="keyword">if</span> deviceName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Error: Could not find device name for device id: %s&quot;</span>, k)</span><br><span class="line">			deviceName = k</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">&quot;DP Name %s&quot;</span>, deviceName)</span><br><span class="line">		dp := NewGenericDevicePlugin(deviceName, <span class="string">&quot;/sys/kernel/iommu_groups/&quot;</span>, devs)</span><br><span class="line">		err := startDevicePlugin(dp)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Error starting %s device plugin: %v&quot;</span>, dp.deviceName, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			devicePlugins = <span class="built_in">append</span>(devicePlugins, dp)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Iterate over vGpuMap to create device plugin for each type of vGPU on the host</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> vGpuMap &#123;</span><br><span class="line">		devs = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">for</span> _, dev := <span class="keyword">range</span> v &#123;</span><br><span class="line">			devs = <span class="built_in">append</span>(devs, &amp;pluginapi.Device&#123;</span><br><span class="line">				ID:     dev.addr,</span><br><span class="line">				Health: pluginapi.Healthy,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		deviceName := getDeviceName(k)</span><br><span class="line">		<span class="keyword">if</span> deviceName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			deviceName = k</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">&quot;DP Name %s&quot;</span>, deviceName)</span><br><span class="line">		dp := NewGenericVGpuDevicePlugin(deviceName, vGpuBasePath, devs)</span><br><span class="line">		err := startVgpuDevicePlugin(dp)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Error starting %s device plugin: %v&quot;</span>, dp.deviceName, err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			vGpuDevicePlugins = <span class="built_in">append</span>(vGpuDevicePlugins, dp)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&lt;-stop</span><br><span class="line">	log.Printf(<span class="string">&quot;Shutting down device plugin controller&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> devicePlugins &#123;</span><br><span class="line">		v.Stop()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createDevicePlugin的流程图如下：</p>
<img src="/2023/01/10/32/kubevirt-device-plugin.png" class="" title="kubevirt-device-plugin">

<p>启动kubevirt-gpu-device-plugin步骤主要有以下几点：</p>
<ol>
<li>遍历 deviveMap 将所有 device 设备类型下的所有 gpu 标记为 healthy </li>
<li>remove 并重建 socket 文件（”/var/lib/kubelet/device-plugins”+”kubevirt-<deviceName>.sock”）</li>
<li>启动 devicePlugin 的 grpc server，对外提供服务</li>
<li>请求kubelet socket链接，进行Regster</li>
<li>启动一个协程对设备进行healthCheck，并监听device-plguin自身socket文件</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>kubevirt-gpu-device-plugin使用前提，是用户使用 vfio-pci 将设备透传至 vm 内，然后，通过读取 vm 内的 pci 设备文件，获取设备的相关信息。iommu,vfio-pci等相关的内容，后续有时间会再补充。</p>
<h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><p><a href="https://rtoax.blog.csdn.net/article/details/110843839#t11">https://rtoax.blog.csdn.net/article/details/110843839#t11</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1816469">https://cloud.tencent.com/developer/article/1816469</a></p>
]]></content>
      <categories>
        <category>device-plugins</category>
      </categories>
      <tags>
        <tag>device-plugins</tag>
        <tag>gpu</tag>
        <tag>kubevirt-gpu-device-plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>kubelet源码分析</title>
    <url>/2023/01/11/14/</url>
    <content><![CDATA[<h2 id="kubelet-主要功能"><a href="#kubelet-主要功能" class="headerlink" title="kubelet 主要功能"></a>kubelet 主要功能</h2><p>在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。</p>
<h2 id="pod管理"><a href="#pod管理" class="headerlink" title="pod管理"></a>pod管理</h2><p>Kubelet 以 PodSpec 的方式工作。PodSpec 是描述一个 Pod 的 YAML 或 JSON 对象。 kubelet 采用一组通过各种机制提供的 PodSpecs（主要通过 apiserver），并确保这些 PodSpecs 中描述的 Pod 正常健康运行。</p>
<p>官方提供了3种方式来获取容器信息：</p>
<ul>
<li>apiserver：通过 API Server 监听 etcd 目录获取数据；</li>
<li>File：启动参数 –config 指定的配置目录下的文件；</li>
<li>通过 url 从网络上某个地址来获取信息</li>
</ul>
<p>拿apiserver来说，如果Kubelet 监听到etcd中有新的绑定到本节点的 Pod，则按照 Pod 清单的要求创建该 Pod；如果发现本地的 Pod 被修改，则 Kubelet 会做出相应的修改。</p>
<img src="/2023/01/11/14/kubelet.png" class="" title="kubelet">
]]></content>
      <categories>
        <category>kubelet</category>
      </categories>
      <tags>
        <tag>kubelet</tag>
      </tags>
  </entry>
  <entry>
    <title>kubelet-device-manager 源码分析</title>
    <url>/2023/01/16/19/</url>
    <content><![CDATA[<h1 id="创建-DeviceManager"><a href="#创建-DeviceManager" class="headerlink" title="创建 DeviceManager"></a>创建 DeviceManager</h1><p>Device Manager 和 cgroup Manager、QoS Container Manager 等一样，都属于kubelet管理的众多 Manager 之一。Device Manager在kubelet启动时的 NewContainerManager 中创建。</p>
<p><u><em>kubernetes/pkg/kubelet/cm/container_manager_linux.go#198</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContainerManager</span><span class="params">(mountUtil mount.Interface, cadvisorInterface cadvisor.Interface, nodeConfig NodeConfig, failSwapOn <span class="type">bool</span>, devicePluginEnabled <span class="type">bool</span>, recorder record.EventRecorder)</span></span> (ContainerManager, <span class="type">error</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	cm := &amp;containerManagerImpl&#123;</span><br><span class="line">		cadvisorInterface:   cadvisorInterface,</span><br><span class="line">		mountUtil:           mountUtil,</span><br><span class="line">		NodeConfig:          nodeConfig,</span><br><span class="line">		subsystems:          subsystems,</span><br><span class="line">		cgroupManager:       cgroupManager,</span><br><span class="line">		capacity:            capacity,</span><br><span class="line">		internalCapacity:    internalCapacity,</span><br><span class="line">		cgroupRoot:          cgroupRoot,</span><br><span class="line">		recorder:            recorder,</span><br><span class="line">		qosContainerManager: qosContainerManager,</span><br><span class="line">	&#125;</span><br><span class="line">	... </span><br><span class="line">	klog.InfoS(<span class="string">&quot;Creating device plugin manager&quot;</span>, <span class="string">&quot;devicePluginEnabled&quot;</span>, devicePluginEnabled)</span><br><span class="line">	<span class="keyword">if</span> devicePluginEnabled &#123;</span><br><span class="line">		cm.deviceManager, err = devicemanager.NewManagerImpl(machineInfo.Topology, cm.topologyManager)</span><br><span class="line">		cm.topologyManager.AddHintProvider(cm.deviceManager)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cm.deviceManager, err = devicemanager.NewManagerStub()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">return</span> cm, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ManagerImpl结构体"><a href="#ManagerImpl结构体" class="headerlink" title="ManagerImpl结构体"></a>ManagerImpl结构体</h3><p>我们有必要先了解Device Manager的结构体：</p>
<p><u><em>kubernetes/pkg/kubelet/cm/devicemanager/manager.go#57</em></u></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ManagerImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">	checkpointdir <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	endpoints <span class="keyword">map</span>[<span class="type">string</span>]endpointInfo <span class="comment">// Key is ResourceName</span></span><br><span class="line">	mutex     sync.Mutex</span><br><span class="line"></span><br><span class="line">	server plugin.Server</span><br><span class="line"></span><br><span class="line">	<span class="comment">// activePods is a method for listing active pods on the node</span></span><br><span class="line">	<span class="comment">// so the amount of pluginResources requested by existing pods</span></span><br><span class="line">	<span class="comment">// could be counted when updating allocated devices</span></span><br><span class="line">	activePods ActivePodsFunc</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sourcesReady provides the readiness of kubelet configuration sources such as apiserver update readiness.</span></span><br><span class="line">	<span class="comment">// We use it to determine when we can purge inactive pods from checkpointed state.</span></span><br><span class="line">	sourcesReady config.SourcesReady</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allDevices holds all the devices currently registered to the device manager</span></span><br><span class="line">	allDevices ResourceDeviceInstances</span><br><span class="line"></span><br><span class="line">	<span class="comment">// healthyDevices contains all of the registered healthy resourceNames and their exported device IDs.</span></span><br><span class="line">	healthyDevices <span class="keyword">map</span>[<span class="type">string</span>]sets.String</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unhealthyDevices contains all of the unhealthy devices and their exported device IDs.</span></span><br><span class="line">	unhealthyDevices <span class="keyword">map</span>[<span class="type">string</span>]sets.String</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocatedDevices contains allocated deviceIds, keyed by resourceName.</span></span><br><span class="line">	allocatedDevices <span class="keyword">map</span>[<span class="type">string</span>]sets.String</span><br><span class="line"></span><br><span class="line">	<span class="comment">// podDevices contains pod to allocated device mapping.</span></span><br><span class="line">	podDevices        *podDevices</span><br><span class="line">	checkpointManager checkpointmanager.CheckpointManager</span><br><span class="line"></span><br><span class="line">	<span class="comment">// List of NUMA Nodes available on the underlying machine</span></span><br><span class="line">	numaNodes []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Store of Topology Affinties that the Device Manager can query.</span></span><br><span class="line">	topologyAffinityStore topologymanager.Store</span><br><span class="line"></span><br><span class="line">	<span class="comment">// devicesToReuse contains devices that can be reused as they have been allocated to</span></span><br><span class="line">	<span class="comment">// init containers.</span></span><br><span class="line">	devicesToReuse PodReusableDevices</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pendingAdmissionPod contain the pod during the admission phase</span></span><br><span class="line">	pendingAdmissionPod *v1.Pod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是核心字段 的说明：</p>
<ul>
<li><p><code>checkpointdir</code>：kubelet对外暴露的socket文件，/var/lib/kubelet/device-plugins/kubelet.sock</p>
</li>
<li><p><code>endpoints</code>：map对象，key 为 Resource Name，value 为 endpoint 接口( 包括 getPreferredAllocation、allocate、preStartContainer、setStopTime、isStopped、stopGracePeriodExpired )，每个 endpoint 接口对应一个已注册的 device plugin，负责与 device plugin 的 gRPC 通信及缓存 device plugin 反馈的 device states。</p>
</li>
<li><p><code>server</code>：暴漏一个 gRPC 服务。</p>
</li>
<li><p><code>activePods</code>：用来获取该节点上所有 active pods，即 non-Terminated 状态的 Pods。在 kubelet 的initializeRuntimeDependentModules 时会注册 activePods Func 为如下函数</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *Kubelet)</span></span> GetActivePods() []*v1.Pod &#123;</span><br><span class="line">	allPods := kl.podManager.GetPods()</span><br><span class="line">	activePods := kl.filterOutInactivePods(allPods)</span><br><span class="line">	<span class="keyword">return</span> activePods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li></li>
</ul>
]]></content>
      <categories>
        <category>kubelet</category>
      </categories>
      <tags>
        <tag>kubelet</tag>
        <tag>device-manager</tag>
      </tags>
  </entry>
</search>
